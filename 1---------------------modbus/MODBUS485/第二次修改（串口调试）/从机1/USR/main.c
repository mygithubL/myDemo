#include "pbdata.h"
#include "mb.h"
#include "mbport.h"

/* ----------------------- Defines ------------------------------------------*/
#define REG_INPUT_START    0x0000  //输入寄存器起始地址
#define REG_INPUT_NREGS    8       //输入寄存器数量//保持寄存器起始地址
  

#define REG_HOLDING_START  0x0000  //保持寄存器起始地址
#define REG_HOLDING_NREGS  8       //保持寄存器数量

void RCC_Configuration(void);
void GPIO_Configuration(void);

void serial_send(u8 bytes,u8 *answer);	               //串口发送数据

/* Private variables ---------------------------------------------------------*/

//输入寄存器内容
uint16_t usRegInputBuf[REG_INPUT_NREGS] = {0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008};
//寄存器起始地址
uint16_t usRegInputStart =0000;

//保持寄存器内容
uint16_t usRegHoldingBuf[REG_HOLDING_NREGS] = {0x1000,0x2000,0x3000,0x4000,0x5000,0x6000,0x7000,0x8000};
//保持寄存器起始地址
uint16_t usRegHoldingStart = REG_HOLDING_START;

u16 crc16(unsigned char *puchMsg,unsigned short usDataLen);
u8 Get_Crc8(u8 *ptr,u16 len); 


extern const u8 chCRCHTalbe[];
extern const u8 chCRCLTalbe[];

extern u8 str2;
extern int rx_bz ;
extern int tx_bz ;


u8 RS485_RX_BUFF[100];//接收缓冲区
u8 send_buf[100];//发送缓冲区
u8 user_data[10]={0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09};
u8 send_mun;

const unsigned char auchCRCHi[] = { /* T able Of CRC  V alues forhigh-order byte CRC 校验高位*/ 
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,0x00, 0xC1, 0x81,
0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81,0x40, 0x01, 0xC0, 
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00,0xC1,0x81, 0x40, 0x01, 
0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,0xC0,0x80, 0x41, 
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,0x00, 0xC1, 0x81, 
0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80,0x41, 0x01, 0xC0, 
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,0xC0,0x80, 0x41, 0x01,
0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00,0xC1,0x81, 0x40, 
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,0x00, 0xC1, 0x81, 
0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,0x40, 0x01, 0xC0, 
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00,0xC1,0x81, 0x40, 0x01, 
0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01,0xC0,0x80, 0x41, 
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,0x00, 0xC1, 0x81, 
0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,0x40, 0x01, 0xC0, 
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,0xC0,0x80, 0x41, 0x01, 
0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,0xC0,0x80, 0x41, 
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,0x00, 0xC1, 0x81, 
0x40 
}; 

/* T able of CRC values forlow-order byte CRC 校验低位*/ 
const unsigned char  auchCRCLo[] = { 
0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
0x04, 0xCC, 0x0C, 0x0D, 0xCD,0x0F , 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB,
0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
0x5D, 0x9D, 0x5F, 0x9F ,0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F ,0x8D, 0x4D, 0x4C, 0x8C, 
0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80,0x40 
}; 

u16 crc16(unsigned char *puchMsg,unsigned short usDataLen)// puchMsg message to calculate CRC upon 
{ // usDataLenquantityof bytes inmessage
	 u8 uIndex ;// will index into CRC lookup table  将 index 在 CRC 里查找
 
	 u8 uchCRCHi =0xFF ; // high byte of CRCinitialized  预设高校验值
	 u8 uchCRCLo = 0xFF; //low byteof CRC initialized 预设低校验值
	while (usDataLen--)// Pass through message buffer 经过信息缓冲
	{ 
	uIndex = uchCRCHi ^ *puchMsg++; // calculate the CRC 计算 CRC
	uchCRCHi = uchCRCLo ^ auchCRCHi [uIndex] ; 
	uchCRCLo = auchCRCLo[uIndex] ; 
	} 
	return(((u8)(uchCRCLo) << 8) |  uchCRCHi); 
}


u8 Get_Crc8(u8 *ptr,u16 len) 
{ 
	u8 crc; 
	u8 i; 
	crc=0; 
	while(len--) 
	{ 
		crc^=*ptr++; 
		for(i=0;i<8;i++) 
		{ 
			if(crc&0x01)crc=(crc>>1)^0x8C; 
			else crc >>= 1; 
		} 
	} 
	return crc; 
} 

int i,k,z,t,a;

int main(void) 
{   
   eMBInit(MB_RTU, 0x01, 0x02, 9600, MB_PAR_NONE); //初始化 RTU模式 从机地址为1 USART2 9600 无校验
   eMBEnable(); //启动FreeModbus 	
	 RCC_Configuration();
	 GPIO_Configuration();

  while(1)
  {
	    eMBPoll();
	    //出现发送的值被覆盖问题
			for(i =0; i < 10; i++)
			{
				RS485_RX_BUFF[i] = USART_ReceiveData(USART2);
				if(RS485_RX_BUFF[0]==0x03)					
				break;
			}
			if((rx_bz==1)&&(RS485_RX_BUFF[i]==0x03))
			 {  
					send_buf[0] = RS485_RX_BUFF[0];     //发送第一个字节
					send_buf[1] = 0x03;                 //发送功能码
				
					crc16(RS485_RX_BUFF,6);									   //接收字节CRC校验
//					
//				if((RS485_RX_BUFF[6]==uchCRCLo)&&(RS485_RX_BUFF[7]==uchCRCHi))	   //判断校验是否正确
//				if((RS485_RX_BUFF[6]==crc16(RS485_RX_BUFF,6))&&(RS485_RX_BUFF[7]==crc16(RS485_RX_BUFF,7)))	   //判断校验是否正确
//				{
					send_buf[0]=RS485_RX_BUFF[0];						   //发送第一个字节
					send_buf[1]=0x03;						   //发送第二个字节
				 
					k=RS485_RX_BUFF[2];
					k=(k<<8|RS485_RX_BUFF[3])*2;							   //将两个字节转换成一个字，在乘2作为MODBUS读取的首地址
					z=RS485_RX_BUFF[4];
					z=(z<<8|RS485_RX_BUFF[5])*2;							   //将两个字节转换成一个字，在乘2作为MODBUS读取的字节数
					send_buf[2]=z;	
		
					for(t=0;t<z;t++) //要发送的j个数据
					{
						send_buf[3+t]=user_data[i+t]; 				
					}
				
					send_buf[(z+3)]=crc16(send_buf,(z+3));							   //发送的第j+3位为CRC检验低位
					send_buf[(z+4)]=crc16(send_buf,(z+4));							   //发送的第j+4位为CRC检验高位
//					send_mun=z+5;			//发送的总字节数等于j+5		
					
					serial_send((z+5),send_buf);					   //串口发送函数
					for(a = 0; a < 1; a++)
					{
						 GPIO_ResetBits(GPIOB,GPIO_Pin_5);
						 //GPIO_ResetBits(GPIOD,GPIO_Pin_3);
						 GPIO_ResetBits(GPIOD,GPIO_Pin_6);
						 delay(6000000);//0.5s
						 GPIO_SetBits(GPIOB,GPIO_Pin_5);
						 //GPIO_SetBits(GPIOD,GPIO_Pin_3);
						 GPIO_SetBits(GPIOD,GPIO_Pin_6);
						 delay(6000000);//0.5s		
					}
				}


	    
        if(GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_1) == Bit_RESET)
        {
            delay(0xfffff);
            if(GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_1) == Bit_RESET)
            {
            GPIO_SetBits(GPIOE,GPIO_Pin_5);
            delay_ms(1);
            while(USART_GetFlagStatus(USART2,USART_FLAG_TXE)==RESET);
            USART_SendData(USART2, 0x6);	//发送字符N
            while(USART_GetFlagStatus(USART2,USART_FLAG_TXE)==RESET);
            delay_ms(2);
            GPIO_ResetBits(GPIOE,GPIO_Pin_5);
            delay_ms(1);
            }
         }
   }	
}
void RCC_Configuration(void)
{
    SystemInit();//72m
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD,ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);
}

void serial_send(u8 bytes,u8 *answer)	               //串口发送数据
{
  u8 i;														   //定义循环变量
	for(i=0;i<bytes;i++)												   //循环发送
	{
		GPIO_SetBits(GPIOE,GPIO_Pin_5);
		delay_ms(1);
		USART_SendData(USART2,*answer);													   //发送指针内数据
		while(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);														   //等待发送完成
		delay_ms(2);
		USART_ClearFlag(USART2,USART_FLAG_TC);
		GPIO_ResetBits(GPIOE,GPIO_Pin_5);
		answer++;														   //指针加1
	}
	rx_bz=0;
	tx_bz=0;
}

void GPIO_Configuration(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;	
  
	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_5;
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
	GPIO_Init(GPIOB,&GPIO_InitStructure);
	
	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_3|GPIO_Pin_6;
	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
	GPIO_Init(GPIOD,&GPIO_InitStructure);
	
		/*PC1按键参数设置*/			
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;	/*选择要用的GPIO引脚*/					 
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;			/*设置引脚模式*/	
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;			/*设置引脚速度*/
	GPIO_Init(GPIOC, &GPIO_InitStructure);
	
	GPIO_ResetBits(GPIOB,GPIO_Pin_5);
	GPIO_SetBits(GPIOD,GPIO_Pin_3);
	GPIO_SetBits(GPIOD,GPIO_Pin_6);	
}

eMBErrorCode
eMBRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
{
    eMBErrorCode    eStatus = MB_ENOERR;
    int             iRegIndex;

    if( ( usAddress >= REG_INPUT_START )
        && ( usAddress + usNRegs <= REG_INPUT_START + REG_INPUT_NREGS ) )
    {
        iRegIndex = ( int )( usAddress - usRegInputStart );
        while( usNRegs > 0 )
        {
            *pucRegBuffer++ =
                ( unsigned char )( usRegInputBuf[iRegIndex] >> 8 );
            *pucRegBuffer++ =
                ( unsigned char )( usRegInputBuf[iRegIndex] & 0xFF );
            iRegIndex++;
            usNRegs--;
        }
    }
    else
    {
        eStatus = MB_ENOREG;
    }

    return eStatus;
}

eMBErrorCode
eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs,
                 eMBRegisterMode eMode )
{
    return MB_ENOREG;
}


eMBErrorCode
eMBRegCoilsCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNCoils,
               eMBRegisterMode eMode )
{
    return MB_ENOREG;
}

eMBErrorCode
eMBRegDiscreteCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNDiscrete )
{
    return MB_ENOREG;
}

