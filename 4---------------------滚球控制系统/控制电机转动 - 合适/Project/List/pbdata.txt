; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\pbdata.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\pbdata.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\BaseDrive -I"C:\Users\Administrator\Desktop\控制电机转动 - 合适\Project\RTE" -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\pbdata.crf ..\User\pbdata.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  RCC_HSE_Configuration PROC
;;;14     
;;;15     void RCC_HSE_Configuration(void) //HSE作为PLL时钟，PLL作为SYSCLK 
000000  b510              PUSH     {r4,lr}
;;;16     { 
;;;17        RCC_DeInit(); /*将外设RCC寄存器重设为缺省值 */ 
000002  f7fffffe          BL       RCC_DeInit
;;;18        RCC_HSEConfig(RCC_HSE_ON); 	 /*设置外部高速晶振（HSE） HSE晶振打开(ON)*/ 
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;19     
;;;20        if(RCC_WaitForHSEStartUp() == SUCCESS) {  /*等待HSE起振,  SUCCESS：HSE晶振稳定且就绪*/  
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  2801              CMP      r0,#1
000014  d120              BNE      |L1.88|
;;;21     
;;;22        RCC_HCLKConfig(RCC_SYSCLK_Div1);/*设置AHB时钟(HCLK)RCC_SYSCLK_Div1――AHB时钟 = 系统时*/  
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       RCC_HCLKConfig
;;;23        RCC_PCLK2Config(RCC_HCLK_Div1); /*设置高速AHB时钟(PCLK2)RCC_HCLK_Div1――APB2时钟 = HCLK*/     
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       RCC_PCLK2Config
;;;24        RCC_PCLK1Config(RCC_HCLK_Div2); /*设置低速AHB时钟(PCLK1)RCC_HCLK_Div2――APB1时钟 = HCLK / 2*/      
000022  f44f6080          MOV      r0,#0x400
000026  f7fffffe          BL       RCC_PCLK1Config
;;;25     
;;;26        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);/*设置PLL时钟源及倍频系数*/    
00002a  f44f11e0          MOV      r1,#0x1c0000
00002e  f44f3080          MOV      r0,#0x10000
000032  f7fffffe          BL       RCC_PLLConfig
;;;27        RCC_PLLCmd(ENABLE); 	 /*使能PLL */ 
000036  2001              MOVS     r0,#1
000038  f7fffffe          BL       RCC_PLLCmd
;;;28        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) ; /*检查指定的RCC标志位(PLL准备好标志)设置与否*/ 
00003c  bf00              NOP      
                  |L1.62|
00003e  2039              MOVS     r0,#0x39
000040  f7fffffe          BL       RCC_GetFlagStatus
000044  2800              CMP      r0,#0
000046  d0fa              BEQ      |L1.62|
;;;29         
;;;30        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);  /*设置系统时钟（SYSCLK） */  
000048  2002              MOVS     r0,#2
00004a  f7fffffe          BL       RCC_SYSCLKConfig
;;;31        while(RCC_GetSYSCLKSource() != 0x08);     /*0x08：PLL作为系统时钟 */	    
00004e  bf00              NOP      
                  |L1.80|
000050  f7fffffe          BL       RCC_GetSYSCLKSource
000054  2808              CMP      r0,#8
000056  d1fb              BNE      |L1.80|
                  |L1.88|
;;;32      } 
;;;33     } 
000058  bd10              POP      {r4,pc}
;;;34     
                          ENDP

                  delay PROC
;;;35     void delay(u32 nCount)
00005a  e000              B        |L1.94|
                  |L1.92|
;;;36     {
;;;37     	for(;nCount!=0;nCount--);
00005c  1e40              SUBS     r0,r0,#1
                  |L1.94|
00005e  2800              CMP      r0,#0
000060  d1fc              BNE      |L1.92|
;;;38     }
000062  4770              BX       lr
;;;39     
                          ENDP

                  delay_us PROC
;;;47     ****************************************************************************/ 
;;;48     void delay_us(u32 nus)
000064  4601              MOV      r1,r0
;;;49     {
;;;50     	 u32 temp;
;;;51     	 SysTick->LOAD = 9*nus;
000066  eb0102c1          ADD      r2,r1,r1,LSL #3
00006a  f04f23e0          MOV      r3,#0xe000e000
00006e  615a              STR      r2,[r3,#0x14]
;;;52     	 SysTick->VAL=0X00;//清空计数器
000070  2200              MOVS     r2,#0
000072  619a              STR      r2,[r3,#0x18]
;;;53     	 SysTick->CTRL=0X01;//使能，减到零是无动作，采用外部时钟源
000074  2201              MOVS     r2,#1
000076  611a              STR      r2,[r3,#0x10]
;;;54     	 do
000078  bf00              NOP      
                  |L1.122|
;;;55     	 {
;;;56     	  temp=SysTick->CTRL;//读取当前倒计数值
00007a  f04f22e0          MOV      r2,#0xe000e000
00007e  6910              LDR      r0,[r2,#0x10]
;;;57     	 }while((temp&0x01)&&(!(temp&(1<<16))));//等待时间到达
000080  f0000201          AND      r2,r0,#1
000084  b11a              CBZ      r2,|L1.142|
000086  f4003280          AND      r2,r0,#0x10000
00008a  2a00              CMP      r2,#0
00008c  d0f5              BEQ      |L1.122|
                  |L1.142|
;;;58     	 
;;;59     	 SysTick->CTRL=0x00; //关闭计数器
00008e  2200              MOVS     r2,#0
000090  f04f23e0          MOV      r3,#0xe000e000
000094  611a              STR      r2,[r3,#0x10]
;;;60     	 SysTick->VAL =0X00; //清空计数器
000096  619a              STR      r2,[r3,#0x18]
;;;61     }
000098  4770              BX       lr
;;;62     
                          ENDP

                  delay_ms PROC
;;;70     ****************************************************************************/ 
;;;71     void delay_ms(u16 nms)
00009a  4601              MOV      r1,r0
;;;72     {
;;;73          //注意 delay_ms函数输入范围是1-1863
;;;74     	 //所以最大延时为1.8秒
;;;75     
;;;76     	 u32 temp;
;;;77     	 SysTick->LOAD = 9000*nms;
00009c  f2423228          MOV      r2,#0x2328
0000a0  434a              MULS     r2,r1,r2
0000a2  f04f23e0          MOV      r3,#0xe000e000
0000a6  615a              STR      r2,[r3,#0x14]
;;;78     	 SysTick->VAL=0X00;//清空计数器
0000a8  2200              MOVS     r2,#0
0000aa  619a              STR      r2,[r3,#0x18]
;;;79     	 SysTick->CTRL=0X01;//使能，减到零是无动作，采用外部时钟源
0000ac  2201              MOVS     r2,#1
0000ae  611a              STR      r2,[r3,#0x10]
;;;80     	 do
0000b0  bf00              NOP      
                  |L1.178|
;;;81     	 {
;;;82     	  temp=SysTick->CTRL;//读取当前倒计数值
0000b2  f04f22e0          MOV      r2,#0xe000e000
0000b6  6910              LDR      r0,[r2,#0x10]
;;;83     	 }while((temp&0x01)&&(!(temp&(1<<16))));//等待时间到达
0000b8  f0000201          AND      r2,r0,#1
0000bc  b11a              CBZ      r2,|L1.198|
0000be  f4003280          AND      r2,r0,#0x10000
0000c2  2a00              CMP      r2,#0
0000c4  d0f5              BEQ      |L1.178|
                  |L1.198|
;;;84     	 SysTick->CTRL=0x00; //关闭计数器
0000c6  2200              MOVS     r2,#0
0000c8  f04f23e0          MOV      r3,#0xe000e000
0000cc  611a              STR      r2,[r3,#0x10]
;;;85     	 SysTick->VAL =0X00; //清空计数器
0000ce  619a              STR      r2,[r3,#0x18]
;;;86     }
0000d0  4770              BX       lr
;;;87     
                          ENDP

                  RCC_Configuration PROC
;;;88     void RCC_Configuration(void)
0000d2  b510              PUSH     {r4,lr}
;;;89     {
;;;90       SystemInit();//72m
0000d4  f7fffffe          BL       SystemInit
;;;91     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
0000d8  2101              MOVS     r1,#1
0000da  2004              MOVS     r0,#4
0000dc  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;92     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
0000e0  2101              MOVS     r1,#1
0000e2  2008              MOVS     r0,#8
0000e4  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;93     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);
0000e8  2101              MOVS     r1,#1
0000ea  2010              MOVS     r0,#0x10
0000ec  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;94     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD,ENABLE);
0000f0  2101              MOVS     r1,#1
0000f2  2020              MOVS     r0,#0x20
0000f4  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;95     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);
0000f8  2101              MOVS     r1,#1
0000fa  2040              MOVS     r0,#0x40
0000fc  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;96     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF,ENABLE);
000100  2101              MOVS     r1,#1
000102  2080              MOVS     r0,#0x80
000104  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;97     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
000108  2101              MOVS     r1,#1
00010a  4608              MOV      r0,r1
00010c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;98       RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);
000110  2101              MOVS     r1,#1
000112  0388              LSLS     r0,r1,#14
000114  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;99     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);
000118  2101              MOVS     r1,#1
00011a  0448              LSLS     r0,r1,#17
00011c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;100    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC,ENABLE);
000120  2101              MOVS     r1,#1
000122  0208              LSLS     r0,r1,#8
000124  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;101    }
000128  bd10              POP      {r4,pc}
;;;102    /********************************************************************************************
                          ENDP

                  NVIC_Configuration PROC
;;;105    *******************************************************************************************/
;;;106    void NVIC_Configuration(void)
00012a  b50e              PUSH     {r1-r3,lr}
;;;107    {
;;;108    	NVIC_InitTypeDef NVIC_InitStructure;
;;;109    	EXTI_InitTypeDef EXTI_InitStructure;
;;;110    	
;;;111    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置优先级组
00012c  f44f60a0          MOV      r0,#0x500
000130  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;112    	/* 使能TIM中断 */
;;;113    	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;	//注意TIM1与TIM8的中断名称与TIM2-TIM7不同
000134  201c              MOVS     r0,#0x1c
000136  f88d0008          STRB     r0,[sp,#8]
;;;114    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //先占优先级设定
00013a  2000              MOVS     r0,#0
00013c  f88d0009          STRB     r0,[sp,#9]
;;;115    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; //从优先级设定
000140  2001              MOVS     r0,#1
000142  f88d000a          STRB     r0,[sp,#0xa]
;;;116    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能中断
000146  f88d000b          STRB     r0,[sp,#0xb]
;;;117    	NVIC_Init(&NVIC_InitStructure);  //写入配置
00014a  a802              ADD      r0,sp,#8
00014c  f7fffffe          BL       NVIC_Init
;;;118    	
;;;119    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; 
000150  2025              MOVS     r0,#0x25
000152  f88d0008          STRB     r0,[sp,#8]
;;;120    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; 
000156  2000              MOVS     r0,#0
000158  f88d0009          STRB     r0,[sp,#9]
;;;121    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; 
00015c  2001              MOVS     r0,#1
00015e  f88d000a          STRB     r0,[sp,#0xa]
;;;122    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; 
000162  f88d000b          STRB     r0,[sp,#0xb]
;;;123    	NVIC_Init(&NVIC_InitStructure);
000166  a802              ADD      r0,sp,#8
000168  f7fffffe          BL       NVIC_Init
;;;124    	
;;;125    	NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn ;				 //外部中断4
00016c  200a              MOVS     r0,#0xa
00016e  f88d0008          STRB     r0,[sp,#8]
;;;126    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;	     //抢占优先级 0
000172  2000              MOVS     r0,#0
000174  f88d0009          STRB     r0,[sp,#9]
;;;127    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;			 //子优先级0  
000178  f88d000a          STRB     r0,[sp,#0xa]
;;;128    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;				 //使能
00017c  2001              MOVS     r0,#1
00017e  f88d000b          STRB     r0,[sp,#0xb]
;;;129    	NVIC_Init(&NVIC_InitStructure);
000182  a802              ADD      r0,sp,#8
000184  f7fffffe          BL       NVIC_Init
;;;130    	
;;;131    	//用于配置AFIO外部中断配置寄存器AFIO_EXTICR1，用于选择EXTI4外部中断的输入源是PE4。
;;;132    	GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, GPIO_PinSource4);     //外部中断配置AFIO--ETXI12
000188  2104              MOVS     r1,#4
00018a  4608              MOV      r0,r1
00018c  f7fffffe          BL       GPIO_EXTILineConfig
;;;133    	
;;;134    	EXTI_InitStructure.EXTI_Line = EXTI_Line4;						//PD12 作为摄像头帧同步检测 检测一帧FIFO接收完成
000190  2010              MOVS     r0,#0x10
000192  9000              STR      r0,[sp,#0]
;;;135    	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;			    //中断模式
000194  2000              MOVS     r0,#0
000196  f88d0004          STRB     r0,[sp,#4]
;;;136    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;		    //下降沿触发
00019a  200c              MOVS     r0,#0xc
00019c  f88d0005          STRB     r0,[sp,#5]
;;;137    	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
0001a0  2001              MOVS     r0,#1
0001a2  f88d0006          STRB     r0,[sp,#6]
;;;138    	EXTI_Init(&EXTI_InitStructure);
0001a6  4668              MOV      r0,sp
0001a8  f7fffffe          BL       EXTI_Init
;;;139    
;;;140    }
0001ac  bd0e              POP      {r1-r3,pc}
;;;141    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  IIC_buf
                          %        14

                          AREA ||.data||, DATA, ALIGN=2

                  ||ax||
                          DCD      0x00000000
                  ||ay||
                          DCD      0x00000000
                  ||az||
                          DCD      0x00000000
                  ||gx||
                          DCD      0x00000000
                  ||gy||
                          DCD      0x00000000
                  ||gz||
                          DCD      0x00000000
