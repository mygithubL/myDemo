; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\mpu6050.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\mpu6050.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\BaseDrive -I"C:\Users\Administrator\Desktop\控制电机转动 - 合适\Project\RTE" -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\mpu6050.crf ..\User\mpu6050.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_Write_Buffer PROC
;;;23     //data：将要写入的一串数据	  
;;;24     u8 I2C_Write_Buffer(u8 addr, u8 reg, u8 len, u8 * data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;25     {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461c              MOV      r4,r3
;;;26         int i;
;;;27         I2C_Start();
00000c  f7fffffe          BL       I2C_Start
;;;28         I2C_Send_Byte(addr << 1 | 0);//7位器件从地址+读写位
000010  2100              MOVS     r1,#0
000012  ea410146          ORR      r1,r1,r6,LSL #1
000016  b2c8              UXTB     r0,r1
000018  f7fffffe          BL       I2C_Send_Byte
;;;29         if (I2C_Wait_Ack()) 
00001c  f7fffffe          BL       I2C_Wait_Ack
000020  b120              CBZ      r0,|L1.44|
;;;30     	{
;;;31             I2C_Stop();
000022  f7fffffe          BL       I2C_Stop
;;;32             return 0;
000026  2000              MOVS     r0,#0
                  |L1.40|
;;;33         }
;;;34         I2C_Send_Byte(reg);
;;;35         I2C_Wait_Ack();
;;;36         for (i = 0; i < len; i++) 
;;;37     	{
;;;38             I2C_Send_Byte(*data);
;;;39             if (I2C_Wait_Ack()) 
;;;40     		{
;;;41                 I2C_Stop();
;;;42                 return 0;
;;;43             }
;;;44     		data++;
;;;45         }
;;;46         I2C_Stop();
;;;47         return 1;
;;;48     }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L1.44|
00002c  4638              MOV      r0,r7                 ;34
00002e  f7fffffe          BL       I2C_Send_Byte
000032  f7fffffe          BL       I2C_Wait_Ack
000036  2500              MOVS     r5,#0                 ;36
000038  e00b              B        |L1.82|
                  |L1.58|
00003a  7820              LDRB     r0,[r4,#0]            ;38
00003c  f7fffffe          BL       I2C_Send_Byte
000040  f7fffffe          BL       I2C_Wait_Ack
000044  b118              CBZ      r0,|L1.78|
000046  f7fffffe          BL       I2C_Stop
00004a  2000              MOVS     r0,#0                 ;42
00004c  e7ec              B        |L1.40|
                  |L1.78|
00004e  1c64              ADDS     r4,r4,#1              ;44
000050  1c6d              ADDS     r5,r5,#1              ;36
                  |L1.82|
000052  4545              CMP      r5,r8                 ;36
000054  dbf1              BLT      |L1.58|
000056  f7fffffe          BL       I2C_Stop
00005a  2001              MOVS     r0,#1                 ;47
00005c  e7e4              B        |L1.40|
;;;49     
                          ENDP

                  I2C_Read_Buffer PROC
;;;53     //buf ：将要读出的数据存储位置
;;;54     u8 I2C_Read_Buffer(u8 addr, u8 reg, u8 len, u8* buf)
00005e  e92d41f0          PUSH     {r4-r8,lr}
;;;55     {
000062  4605              MOV      r5,r0
000064  460f              MOV      r7,r1
000066  4614              MOV      r4,r2
000068  461e              MOV      r6,r3
;;;56         I2C_Start();
00006a  f7fffffe          BL       I2C_Start
;;;57         I2C_Send_Byte(addr << 1 | 0);
00006e  2100              MOVS     r1,#0
000070  ea410145          ORR      r1,r1,r5,LSL #1
000074  b2c8              UXTB     r0,r1
000076  f7fffffe          BL       I2C_Send_Byte
;;;58         if (I2C_Wait_Ack())
00007a  f7fffffe          BL       I2C_Wait_Ack
00007e  b120              CBZ      r0,|L1.138|
;;;59     	  {
;;;60             I2C_Stop();
000080  f7fffffe          BL       I2C_Stop
;;;61             return 0;
000084  2000              MOVS     r0,#0
                  |L1.134|
;;;62         }
;;;63         I2C_Send_Byte(reg);
;;;64         I2C_Wait_Ack();
;;;65     
;;;66         I2C_Start();
;;;67         I2C_Send_Byte(addr << 1 | 1);
;;;68         I2C_Wait_Ack();
;;;69         while (len)
;;;70     	   {
;;;71             *buf = I2C_Read_Byte();
;;;72             if (len == 1)
;;;73                 I2C_NAck();
;;;74             else
;;;75                 I2C_Ack();
;;;76             buf++;
;;;77             len--;
;;;78         }
;;;79         I2C_Stop();
;;;80         return 1;
;;;81     }
000086  e8bd81f0          POP      {r4-r8,pc}
                  |L1.138|
00008a  4638              MOV      r0,r7                 ;63
00008c  f7fffffe          BL       I2C_Send_Byte
000090  f7fffffe          BL       I2C_Wait_Ack
000094  f7fffffe          BL       I2C_Start
000098  2101              MOVS     r1,#1                 ;67
00009a  eb010145          ADD      r1,r1,r5,LSL #1       ;67
00009e  b2c8              UXTB     r0,r1                 ;67
0000a0  f7fffffe          BL       I2C_Send_Byte
0000a4  f7fffffe          BL       I2C_Wait_Ack
0000a8  e00c              B        |L1.196|
                  |L1.170|
0000aa  f7fffffe          BL       I2C_Read_Byte
0000ae  7030              STRB     r0,[r6,#0]            ;71
0000b0  2c01              CMP      r4,#1                 ;72
0000b2  d102              BNE      |L1.186|
0000b4  f7fffffe          BL       I2C_NAck
0000b8  e001              B        |L1.190|
                  |L1.186|
0000ba  f7fffffe          BL       I2C_Ack
                  |L1.190|
0000be  1c76              ADDS     r6,r6,#1              ;76
0000c0  1e60              SUBS     r0,r4,#1              ;77
0000c2  b2c4              UXTB     r4,r0                 ;77
                  |L1.196|
0000c4  2c00              CMP      r4,#0                 ;69
0000c6  d1f0              BNE      |L1.170|
0000c8  f7fffffe          BL       I2C_Stop
0000cc  2001              MOVS     r0,#1                 ;80
0000ce  e7da              B        |L1.134|
;;;82     
                          ENDP

                  I2C_Read PROC
;;;84     //		-1：读失败
;;;85     int I2C_Read(u8 addr, u8 reg, u8 len, u8 *buf)
0000d0  e92d41f0          PUSH     {r4-r8,lr}
;;;86     {
0000d4  4604              MOV      r4,r0
0000d6  460d              MOV      r5,r1
0000d8  4616              MOV      r6,r2
0000da  461f              MOV      r7,r3
;;;87     	if(I2C_Read_Buffer(addr,reg,len,buf))
0000dc  463b              MOV      r3,r7
0000de  4632              MOV      r2,r6
0000e0  4629              MOV      r1,r5
0000e2  4620              MOV      r0,r4
0000e4  f7fffffe          BL       I2C_Read_Buffer
0000e8  b110              CBZ      r0,|L1.240|
;;;88     		return 0;
0000ea  2000              MOVS     r0,#0
                  |L1.236|
;;;89     	else
;;;90     		return -1;
;;;91     }
0000ec  e8bd81f0          POP      {r4-r8,pc}
                  |L1.240|
0000f0  f04f30ff          MOV      r0,#0xffffffff        ;90
0000f4  e7fa              B        |L1.236|
;;;92     //返回值 0：写成功
                          ENDP

                  I2C_Write PROC
;;;93     //		-1：写失败
;;;94     int I2C_Write(u8 addr, u8 reg, u8 len, u8* data)
0000f6  e92d41f0          PUSH     {r4-r8,lr}
;;;95     {
0000fa  4604              MOV      r4,r0
0000fc  460d              MOV      r5,r1
0000fe  4616              MOV      r6,r2
000100  461f              MOV      r7,r3
;;;96     	if(I2C_Write_Buffer(addr,reg,len,data))
000102  463b              MOV      r3,r7
000104  4632              MOV      r2,r6
000106  4629              MOV      r1,r5
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       I2C_Write_Buffer
00010e  b110              CBZ      r0,|L1.278|
;;;97     		return 0;
000110  2000              MOVS     r0,#0
                  |L1.274|
;;;98     	else
;;;99     		return -1;
;;;100    }
000112  e8bd81f0          POP      {r4-r8,pc}
                  |L1.278|
000116  f04f30ff          MOV      r0,#0xffffffff        ;99
00011a  e7fa              B        |L1.274|
;;;101    
                          ENDP

                  MPU6050_Init PROC
;;;103    
;;;104    void MPU6050_Init(void)
00011c  b570              PUSH     {r4-r6,lr}
;;;105    {
;;;106    	int result=0;
00011e  2400              MOVS     r4,#0
;;;107    	I2C_Init_IO();
000120  f7fffffe          BL       I2C_Init_IO
;;;108    	result=mpu_init();
000124  f7fffffe          BL       mpu_init
000128  4604              MOV      r4,r0
;;;109    	if(!result)
00012a  bb1c              CBNZ     r4,|L1.372|
;;;110    	{	 		 
;;;111    		if(!mpu_set_sensors(INV_XYZ_GYRO | INV_XYZ_ACCEL))		//mpu_set_sensor
00012c  2078              MOVS     r0,#0x78
00012e  f7fffffe          BL       mpu_set_sensors
000132  b9e0              CBNZ     r0,|L1.366|
;;;112    		if(!mpu_configure_fifo(INV_XYZ_GYRO | INV_XYZ_ACCEL))	//mpu_configure_fifo
000134  2078              MOVS     r0,#0x78
000136  f7fffffe          BL       mpu_configure_fifo
00013a  b9c0              CBNZ     r0,|L1.366|
;;;113    		if(!mpu_set_sample_rate(DEFAULT_MPU_HZ))	   	  		//mpu_set_sample_rate
00013c  2064              MOVS     r0,#0x64
00013e  f7fffffe          BL       mpu_set_sample_rate
000142  b9a0              CBNZ     r0,|L1.366|
;;;114    		if(!dmp_load_motion_driver_firmware())   	  			//dmp_load_motion_driver_firmvare
000144  f7fffffe          BL       dmp_load_motion_driver_firmware
000148  b988              CBNZ     r0,|L1.366|
;;;115    		if(!dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation))) 	  //dmp_set_orientation
00014a  48be              LDR      r0,|L1.1092|
00014c  f7fffffe          BL       inv_orientation_matrix_to_scalar
000150  4605              MOV      r5,r0
000152  f7fffffe          BL       dmp_set_orientation
000156  b950              CBNZ     r0,|L1.366|
;;;116    		if(!dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT | DMP_FEATURE_TAP |
000158  f2401073          MOV      r0,#0x173
00015c  f7fffffe          BL       dmp_enable_feature
000160  b928              CBNZ     r0,|L1.366|
;;;117    		    DMP_FEATURE_ANDROID_ORIENT | DMP_FEATURE_SEND_RAW_ACCEL | DMP_FEATURE_SEND_CAL_GYRO |
;;;118    		    DMP_FEATURE_GYRO_CAL))		   	 					 //dmp_enable_feature
;;;119    		if(!dmp_set_fifo_rate(DEFAULT_MPU_HZ))   	 			 //dmp_set_fifo_rate
000162  2064              MOVS     r0,#0x64
000164  f7fffffe          BL       dmp_set_fifo_rate
000168  b908              CBNZ     r0,|L1.366|
;;;120    		run_self_test();		//??
00016a  f7fffffe          BL       run_self_test
                  |L1.366|
;;;121    		if(!mpu_set_dmp_state(1));
00016e  2001              MOVS     r0,#1
000170  f7fffffe          BL       mpu_set_dmp_state
                  |L1.372|
;;;122    	}
;;;123    }
000174  bd70              POP      {r4-r6,pc}
;;;124    
                          ENDP

                  MPU6050_Pose PROC
;;;125    
;;;126    void MPU6050_Pose(void)
000176  e92d4ff0          PUSH     {r4-r11,lr}
;;;127    {
00017a  b089              SUB      sp,sp,#0x24
;;;128    	dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors,&more);	 
00017c  48b2              LDR      r0,|L1.1096|
00017e  49b3              LDR      r1,|L1.1100|
000180  4bb3              LDR      r3,|L1.1104|
000182  4ab4              LDR      r2,|L1.1108|
000184  e9cd1000          STRD     r1,r0,[sp,#0]
000188  49b3              LDR      r1,|L1.1112|
00018a  48b4              LDR      r0,|L1.1116|
00018c  f7fffffe          BL       dmp_read_fifo
;;;129    	if(sensors & INV_WXYZ_QUAT )
000190  48ae              LDR      r0,|L1.1100|
000192  8800              LDRH     r0,[r0,#0]  ; sensors
000194  f4007080          AND      r0,r0,#0x100
000198  2800              CMP      r0,#0
00019a  d07d              BEQ      |L1.664|
;;;130    	{
;;;131    		q0 = quat[0] / q30;	
00019c  49ad              LDR      r1,|L1.1108|
00019e  6808              LDR      r0,[r1,#0]  ; quat
0001a0  f7fffffe          BL       __aeabi_i2f
0001a4  4604              MOV      r4,r0
0001a6  f04f419d          MOV      r1,#0x4e800000
0001aa  f7fffffe          BL       __aeabi_fdiv
0001ae  49ac              LDR      r1,|L1.1120|
0001b0  6008              STR      r0,[r1,#0]  ; q0
;;;132    		q1 = quat[1] / q30;
0001b2  49a8              LDR      r1,|L1.1108|
0001b4  6848              LDR      r0,[r1,#4]  ; quat
0001b6  f7fffffe          BL       __aeabi_i2f
0001ba  4604              MOV      r4,r0
0001bc  f04f419d          MOV      r1,#0x4e800000
0001c0  f7fffffe          BL       __aeabi_fdiv
0001c4  49a7              LDR      r1,|L1.1124|
0001c6  6008              STR      r0,[r1,#0]  ; q1
;;;133    		q2 = quat[2] / q30;
0001c8  49a2              LDR      r1,|L1.1108|
0001ca  6888              LDR      r0,[r1,#8]  ; quat
0001cc  f7fffffe          BL       __aeabi_i2f
0001d0  4604              MOV      r4,r0
0001d2  f04f419d          MOV      r1,#0x4e800000
0001d6  f7fffffe          BL       __aeabi_fdiv
0001da  49a3              LDR      r1,|L1.1128|
0001dc  6008              STR      r0,[r1,#0]  ; q2
;;;134    		q3 = quat[3] / q30;
0001de  499d              LDR      r1,|L1.1108|
0001e0  68c8              LDR      r0,[r1,#0xc]  ; quat
0001e2  f7fffffe          BL       __aeabi_i2f
0001e6  4604              MOV      r4,r0
0001e8  f04f419d          MOV      r1,#0x4e800000
0001ec  f7fffffe          BL       __aeabi_fdiv
0001f0  499e              LDR      r1,|L1.1132|
0001f2  6008              STR      r0,[r1,#0]  ; q3
;;;135    
;;;136    		Pitch = asin(-2 * q1 * q3 + 2 * q0* q2)* 57.3;	// pitch
0001f4  489a              LDR      r0,|L1.1120|
0001f6  6801              LDR      r1,[r0,#0]  ; q0
0001f8  f04f4080          MOV      r0,#0x40000000
0001fc  f7fffffe          BL       __aeabi_fmul
000200  9006              STR      r0,[sp,#0x18]
000202  4899              LDR      r0,|L1.1128|
000204  6801              LDR      r1,[r0,#0]  ; q2
000206  9806              LDR      r0,[sp,#0x18]
000208  f7fffffe          BL       __aeabi_fmul
00020c  4682              MOV      r10,r0
00020e  4895              LDR      r0,|L1.1124|
000210  6801              LDR      r1,[r0,#0]  ; q1
000212  f04f4040          MOV      r0,#0xc0000000
000216  f7fffffe          BL       __aeabi_fmul
00021a  9006              STR      r0,[sp,#0x18]
00021c  4893              LDR      r0,|L1.1132|
00021e  6801              LDR      r1,[r0,#0]  ; q3
000220  9806              LDR      r0,[sp,#0x18]
000222  f7fffffe          BL       __aeabi_fmul
000226  4683              MOV      r11,r0
000228  4651              MOV      r1,r10
00022a  f7fffffe          BL       __aeabi_fadd
00022e  9007              STR      r0,[sp,#0x1c]
000230  f7fffffe          BL       __aeabi_f2d
000234  4606              MOV      r6,r0
000236  f7fffffe          BL       asin
00023a  4680              MOV      r8,r0
00023c  f04f3266          MOV      r2,#0x66666666
000240  4b8b              LDR      r3,|L1.1136|
000242  f7fffffe          BL       __aeabi_dmul
000246  4604              MOV      r4,r0
000248  f7fffffe          BL       __aeabi_d2f
00024c  4989              LDR      r1,|L1.1140|
00024e  6008              STR      r0,[r1,#0]  ; Pitch
;;;137    		Roll  = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2* q2 + 1)* 57.3;	// roll
000250  4885              LDR      r0,|L1.1128|
000252  6801              LDR      r1,[r0,#0]  ; q2
000254  f04f4080          MOV      r0,#0x40000000
000258  f7fffffe          BL       __aeabi_fmul
00025c  9003              STR      r0,[sp,#0xc]
00025e  4882              LDR      r0,|L1.1128|
000260  6801              LDR      r1,[r0,#0]  ; q2
000262  9803              LDR      r0,[sp,#0xc]
000264  f7fffffe          BL       __aeabi_fmul
000268  4682              MOV      r10,r0
00026a  487e              LDR      r0,|L1.1124|
00026c  6801              LDR      r1,[r0,#0]  ; q1
00026e  f04f4040          MOV      r0,#0xc0000000
000272  f7fffffe          BL       __aeabi_fmul
000276  9003              STR      r0,[sp,#0xc]
000278  487a              LDR      r0,|L1.1124|
00027a  6801              LDR      r1,[r0,#0]  ; q1
00027c  9803              LDR      r0,[sp,#0xc]
00027e  f7fffffe          BL       __aeabi_fmul
000282  4683              MOV      r11,r0
000284  4651              MOV      r1,r10
000286  f7fffffe          BL       __aeabi_fsub
00028a  4681              MOV      r9,r0
00028c  f04f517e          MOV      r1,#0x3f800000
000290  f7fffffe          BL       __aeabi_fadd
000294  4604              MOV      r4,r0
000296  e000              B        |L1.666|
                  |L1.664|
000298  e086              B        |L1.936|
                  |L1.666|
00029a  f7fffffe          BL       __aeabi_f2d
00029e  e9cd0104          STRD     r0,r1,[sp,#0x10]
0002a2  486f              LDR      r0,|L1.1120|
0002a4  6801              LDR      r1,[r0,#0]  ; q0
0002a6  f04f4080          MOV      r0,#0x40000000
0002aa  f7fffffe          BL       __aeabi_fmul
0002ae  4683              MOV      r11,r0
0002b0  486c              LDR      r0,|L1.1124|
0002b2  6801              LDR      r1,[r0,#0]  ; q1
0002b4  4658              MOV      r0,r11
0002b6  f7fffffe          BL       __aeabi_fmul
0002ba  4681              MOV      r9,r0
0002bc  486a              LDR      r0,|L1.1128|
0002be  6801              LDR      r1,[r0,#0]  ; q2
0002c0  f04f4080          MOV      r0,#0x40000000
0002c4  f7fffffe          BL       __aeabi_fmul
0002c8  4683              MOV      r11,r0
0002ca  4868              LDR      r0,|L1.1132|
0002cc  6801              LDR      r1,[r0,#0]  ; q3
0002ce  4658              MOV      r0,r11
0002d0  f7fffffe          BL       __aeabi_fmul
0002d4  4682              MOV      r10,r0
0002d6  4649              MOV      r1,r9
0002d8  f7fffffe          BL       __aeabi_fadd
0002dc  4604              MOV      r4,r0
0002de  f7fffffe          BL       __aeabi_f2d
0002e2  4607              MOV      r7,r0
0002e4  e9dd2304          LDRD     r2,r3,[sp,#0x10]
0002e8  f7fffffe          BL       atan2
0002ec  f04f3266          MOV      r2,#0x66666666
0002f0  4b5f              LDR      r3,|L1.1136|
0002f2  e9cd0106          STRD     r0,r1,[sp,#0x18]
0002f6  f7fffffe          BL       __aeabi_dmul
0002fa  4605              MOV      r5,r0
0002fc  f7fffffe          BL       __aeabi_d2f
000300  495d              LDR      r1,|L1.1144|
000302  6008              STR      r0,[r1,#0]  ; Roll
;;;138    		Yaw   = atan2(2*(q1*q2 + q0*q3),q0*q0+q1*q1-q2*q2-q3*q3) * 57.3;	//yaw
000304  4859              LDR      r0,|L1.1132|
000306  6801              LDR      r1,[r0,#0]  ; q3
000308  6800              LDR      r0,[r0,#0]  ; q3
00030a  f7fffffe          BL       __aeabi_fmul
00030e  9003              STR      r0,[sp,#0xc]
000310  4855              LDR      r0,|L1.1128|
000312  6801              LDR      r1,[r0,#0]  ; q2
000314  6800              LDR      r0,[r0,#0]  ; q2
000316  f7fffffe          BL       __aeabi_fmul
00031a  9002              STR      r0,[sp,#8]
00031c  4851              LDR      r0,|L1.1124|
00031e  6801              LDR      r1,[r0,#0]  ; q1
000320  6800              LDR      r0,[r0,#0]  ; q1
000322  f7fffffe          BL       __aeabi_fmul
000326  4683              MOV      r11,r0
000328  484d              LDR      r0,|L1.1120|
00032a  6801              LDR      r1,[r0,#0]  ; q0
00032c  6800              LDR      r0,[r0,#0]  ; q0
00032e  f7fffffe          BL       __aeabi_fmul
000332  4659              MOV      r1,r11
000334  9001              STR      r0,[sp,#4]
000336  f7fffffe          BL       __aeabi_fadd
00033a  4682              MOV      r10,r0
00033c  9902              LDR      r1,[sp,#8]
00033e  f7fffffe          BL       __aeabi_fsub
000342  4681              MOV      r9,r0
000344  9903              LDR      r1,[sp,#0xc]
000346  f7fffffe          BL       __aeabi_fsub
00034a  4604              MOV      r4,r0
00034c  f7fffffe          BL       __aeabi_f2d
000350  e9cd0104          STRD     r0,r1,[sp,#0x10]
000354  4845              LDR      r0,|L1.1132|
000356  6801              LDR      r1,[r0,#0]  ; q3
000358  4841              LDR      r0,|L1.1120|
00035a  6800              LDR      r0,[r0,#0]  ; q0
00035c  f7fffffe          BL       __aeabi_fmul
000360  4682              MOV      r10,r0
000362  4841              LDR      r0,|L1.1128|
000364  6801              LDR      r1,[r0,#0]  ; q2
000366  483f              LDR      r0,|L1.1124|
000368  6800              LDR      r0,[r0,#0]  ; q1
00036a  f7fffffe          BL       __aeabi_fmul
00036e  4683              MOV      r11,r0
000370  4651              MOV      r1,r10
000372  f7fffffe          BL       __aeabi_fadd
000376  4681              MOV      r9,r0
000378  f04f4180          MOV      r1,#0x40000000
00037c  f7fffffe          BL       __aeabi_fmul
000380  4604              MOV      r4,r0
000382  f7fffffe          BL       __aeabi_f2d
000386  4607              MOV      r7,r0
000388  e9dd2304          LDRD     r2,r3,[sp,#0x10]
00038c  f7fffffe          BL       atan2
000390  f04f3266          MOV      r2,#0x66666666
000394  4b36              LDR      r3,|L1.1136|
000396  e9cd0106          STRD     r0,r1,[sp,#0x18]
00039a  f7fffffe          BL       __aeabi_dmul
00039e  4605              MOV      r5,r0
0003a0  f7fffffe          BL       __aeabi_d2f
0003a4  4935              LDR      r1,|L1.1148|
0003a6  6008              STR      r0,[r1,#0]  ; Yaw
                  |L1.936|
;;;139    	}
;;;140    }
0003a8  b009              ADD      sp,sp,#0x24
0003aa  e8bd8ff0          POP      {r4-r11,pc}
;;;141    //通用定时器中断初始化
                          ENDP

                  Timer2_Init PROC
;;;145    //这里使用的是定时器2!
;;;146    void Timer2_Init(u16 arr,u16 psc)
0003ae  b57f              PUSH     {r0-r6,lr}
;;;147    {
0003b0  4605              MOV      r5,r0
0003b2  460c              MOV      r4,r1
;;;148    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;149    	NVIC_InitTypeDef NVIC_InitStructure;
;;;150    
;;;151    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //时钟使能
0003b4  2101              MOVS     r1,#1
0003b6  2002              MOVS     r0,#2
0003b8  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;152    
;;;153    	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	 计数到5000为500ms
0003bc  f8ad5008          STRH     r5,[sp,#8]
;;;154    	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值  10Khz的计数频率  
0003c0  f8ad4004          STRH     r4,[sp,#4]
;;;155    	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim
0003c4  2000              MOVS     r0,#0
0003c6  f8ad000a          STRH     r0,[sp,#0xa]
;;;156    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
0003ca  f8ad0006          STRH     r0,[sp,#6]
;;;157    	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
0003ce  a901              ADD      r1,sp,#4
0003d0  482b              LDR      r0,|L1.1152|
0003d2  f7fffffe          BL       TIM_TimeBaseInit
;;;158     
;;;159    	TIM_ITConfig(TIM3,TIM_IT_Update ,ENABLE );//使能或者失能指定的TIM2中断
0003d6  2201              MOVS     r2,#1
0003d8  4611              MOV      r1,r2
0003da  4829              LDR      r0,|L1.1152|
0003dc  f7fffffe          BL       TIM_ITConfig
;;;160    	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;  //TIM2中断
0003e0  201d              MOVS     r0,#0x1d
0003e2  f88d0000          STRB     r0,[sp,#0]
;;;161    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;  //先占优先级1级
0003e6  2001              MOVS     r0,#1
0003e8  f88d0001          STRB     r0,[sp,#1]
;;;162    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;  //从优先级3级
0003ec  2003              MOVS     r0,#3
0003ee  f88d0002          STRB     r0,[sp,#2]
;;;163    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能
0003f2  2001              MOVS     r0,#1
0003f4  f88d0003          STRB     r0,[sp,#3]
;;;164    	NVIC_Init(&NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
0003f8  4668              MOV      r0,sp
0003fa  f7fffffe          BL       NVIC_Init
;;;165    
;;;166    	TIM_Cmd(TIM3, ENABLE);  //使能TIMx外设						 
0003fe  2101              MOVS     r1,#1
000400  481f              LDR      r0,|L1.1152|
000402  f7fffffe          BL       TIM_Cmd
;;;167    }
000406  bd7f              POP      {r0-r6,pc}
;;;168    //定时器3中断服务程序	 
                          ENDP

                  TIM3_IRQHandler PROC
;;;169    void TIM3_IRQHandler(void)
000408  b510              PUSH     {r4,lr}
;;;170    { 		    		  			    
;;;171    	if(TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) //溢出中断
00040a  2101              MOVS     r1,#1
00040c  481c              LDR      r0,|L1.1152|
00040e  f7fffffe          BL       TIM_GetITStatus
000412  b108              CBZ      r0,|L1.1048|
;;;172    	{
;;;173    				MPU6050_Pose();
000414  f7fffffe          BL       MPU6050_Pose
                  |L1.1048|
;;;174    	}				   
;;;175    	TIM_ClearITPendingBit(TIM3, TIM_IT_Update);  //清除TIMx的中断待处理位:TIM 中断源 
000418  2101              MOVS     r1,#1
00041a  4819              LDR      r0,|L1.1152|
00041c  f7fffffe          BL       TIM_ClearITPendingBit
;;;176    }
000420  bd10              POP      {r4,pc}
;;;177    
                          ENDP

                  MPU6050_Strat PROC
;;;178    void MPU6050_Strat(void)
000422  b510              PUSH     {r4,lr}
;;;179    {
;;;180    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  //初始化NVIC
000424  f44f60a0          MOV      r0,#0x500
000428  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;181      delay_ms(200);     
00042c  20c8              MOVS     r0,#0xc8
00042e  f7fffffe          BL       delay_ms
;;;182    	MPU6050_Init();  //初始化陀螺仪
000432  f7fffffe          BL       MPU6050_Init
;;;183      Timer2_Init(499,71);//Tout（溢出时间）=（ARR+1)(PSC+1)/Tclk =500*72/72000000s=500us	
000436  2147              MOVS     r1,#0x47
000438  f24010f3          MOV      r0,#0x1f3
00043c  f7fffffe          BL       Timer2_Init
;;;184    	
;;;185    }
000440  bd10              POP      {r4,pc}
;;;186    
                          ENDP

000442  0000              DCW      0x0000
                  |L1.1092|
                          DCD      gyro_orientation
                  |L1.1096|
                          DCD      more
                  |L1.1100|
                          DCD      sensors
                  |L1.1104|
                          DCD      sensor_timestamp
                  |L1.1108|
                          DCD      quat
                  |L1.1112|
                          DCD      accel
                  |L1.1116|
                          DCD      gyro
                  |L1.1120|
                          DCD      ||q0||
                  |L1.1124|
                          DCD      ||q1||
                  |L1.1128|
                          DCD      ||q2||
                  |L1.1132|
                          DCD      ||q3||
                  |L1.1136|
                          DCD      0x404ca666
                  |L1.1140|
                          DCD      Pitch
                  |L1.1144|
                          DCD      Roll
                  |L1.1148|
                          DCD      Yaw
                  |L1.1152|
                          DCD      0x40000400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  quat
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  gyro_orientation
000000  ff000000          DCB      0xff,0x00,0x00,0x00
000004  ff000000          DCB      0xff,0x00,0x00,0x00
000008  01000000          DCB      0x01,0x00,0x00,0x00
                  ||q0||
00000c  3f800000          DCFS     0x3f800000 ; 1
                  ||q1||
000010  00000000          DCFS     0x00000000 ; 0
                  ||q2||
000014  00000000          DCFS     0x00000000 ; 0
                  ||q3||
000018  00000000          DCFS     0x00000000 ; 0
                  Pitch
                          DCD      0x00000000
                  Roll
                          DCD      0x00000000
                  Yaw
                          DCD      0x00000000
                  sensor_timestamp
                          DCD      0x00000000
                  gyro
                          DCD      0x00000000
000030  0000              DCB      0x00,0x00
                  accel
000032  0000              DCB      0x00,0x00
                          DCD      0x00000000
                  sensors
000038  0000              DCB      0x00,0x00
                  more
00003a  00                DCB      0x00
