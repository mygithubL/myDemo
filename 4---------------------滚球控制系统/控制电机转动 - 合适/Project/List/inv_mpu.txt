; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\inv_mpu.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\inv_mpu.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\BaseDrive -I"C:\Users\Administrator\Desktop\控制电机转动 - 合适\Project\RTE" -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\inv_mpu.crf ..\User\inv_mpu.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  mpu_get_accel_sens PROC
;;;1587    */
;;;1588   int mpu_get_accel_sens(unsigned short *sens)
000000  4601              MOV      r1,r0
;;;1589   {
;;;1590       switch (st.chip_cfg.accel_fsr) {
000002  48fe              LDR      r0,|L1.1020|
000004  7a40              LDRB     r0,[r0,#9]
000006  b130              CBZ      r0,|L1.22|
000008  2801              CMP      r0,#1
00000a  d008              BEQ      |L1.30|
00000c  2802              CMP      r0,#2
00000e  d00a              BEQ      |L1.38|
000010  2803              CMP      r0,#3
000012  d110              BNE      |L1.54|
000014  e00b              B        |L1.46|
                  |L1.22|
;;;1591       case INV_FSR_2G:
;;;1592           sens[0] = 16384;
000016  f44f4080          MOV      r0,#0x4000
00001a  8008              STRH     r0,[r1,#0]
;;;1593           break;
00001c  e00e              B        |L1.60|
                  |L1.30|
;;;1594       case INV_FSR_4G:
;;;1595           sens[0] = 8092;
00001e  f641709c          MOV      r0,#0x1f9c
000022  8008              STRH     r0,[r1,#0]
;;;1596           break;
000024  e00a              B        |L1.60|
                  |L1.38|
;;;1597       case INV_FSR_8G:
;;;1598           sens[0] = 4096;
000026  f44f5080          MOV      r0,#0x1000
00002a  8008              STRH     r0,[r1,#0]
;;;1599           break;
00002c  e006              B        |L1.60|
                  |L1.46|
;;;1600       case INV_FSR_16G:
;;;1601           sens[0] = 2048;
00002e  f44f6000          MOV      r0,#0x800
000032  8008              STRH     r0,[r1,#0]
;;;1602           break;
000034  e002              B        |L1.60|
                  |L1.54|
;;;1603       default:
;;;1604           return -1;
000036  f04f30ff          MOV      r0,#0xffffffff
                  |L1.58|
;;;1605       }
;;;1606       if (st.chip_cfg.accel_half)
;;;1607           sens[0] >>= 1;
;;;1608       return 0;
;;;1609   }
00003a  4770              BX       lr
                  |L1.60|
00003c  bf00              NOP                            ;1593
00003e  48ef              LDR      r0,|L1.1020|
000040  7cc0              LDRB     r0,[r0,#0x13]         ;1606
000042  b110              CBZ      r0,|L1.74|
000044  8808              LDRH     r0,[r1,#0]            ;1607
000046  1040              ASRS     r0,r0,#1              ;1607
000048  8008              STRH     r0,[r1,#0]            ;1607
                  |L1.74|
00004a  2000              MOVS     r0,#0                 ;1608
00004c  e7f5              B        |L1.58|
;;;1610   
                          ENDP

                  mpu_get_gyro_sens PROC
;;;1561    */
;;;1562   int mpu_get_gyro_sens(float *sens)
00004e  4601              MOV      r1,r0
;;;1563   {
;;;1564       switch (st.chip_cfg.gyro_fsr) {
000050  48ea              LDR      r0,|L1.1020|
000052  7a00              LDRB     r0,[r0,#8]  ; st
000054  b130              CBZ      r0,|L1.100|
000056  2801              CMP      r0,#1
000058  d007              BEQ      |L1.106|
00005a  2802              CMP      r0,#2
00005c  d008              BEQ      |L1.112|
00005e  2803              CMP      r0,#3
000060  d10c              BNE      |L1.124|
000062  e008              B        |L1.118|
                  |L1.100|
;;;1565       case INV_FSR_250DPS:
;;;1566           sens[0] = 131.f;
000064  48e6              LDR      r0,|L1.1024|
000066  6008              STR      r0,[r1,#0]
;;;1567           break;
000068  e00b              B        |L1.130|
                  |L1.106|
;;;1568       case INV_FSR_500DPS:
;;;1569           sens[0] = 65.5f;
00006a  48e6              LDR      r0,|L1.1028|
00006c  6008              STR      r0,[r1,#0]
;;;1570           break;
00006e  e008              B        |L1.130|
                  |L1.112|
;;;1571       case INV_FSR_1000DPS:
;;;1572           sens[0] = 32.8f;
000070  48e5              LDR      r0,|L1.1032|
000072  6008              STR      r0,[r1,#0]
;;;1573           break;
000074  e005              B        |L1.130|
                  |L1.118|
;;;1574       case INV_FSR_2000DPS:
;;;1575           sens[0] = 16.4f;
000076  48e5              LDR      r0,|L1.1036|
000078  6008              STR      r0,[r1,#0]
;;;1576           break;
00007a  e002              B        |L1.130|
                  |L1.124|
;;;1577       default:
;;;1578           return -1;
00007c  f04f30ff          MOV      r0,#0xffffffff
                  |L1.128|
;;;1579       }
;;;1580       return 0;
;;;1581   }
000080  4770              BX       lr
                  |L1.130|
000082  bf00              NOP                            ;1567
000084  2000              MOVS     r0,#0                 ;1580
000086  e7fb              B        |L1.128|
;;;1582   
                          ENDP

                  mpu_reset_fifo PROC
;;;1195    */
;;;1196   int mpu_reset_fifo(void)
000088  b508              PUSH     {r3,lr}
;;;1197   {
;;;1198       unsigned char data;
;;;1199   
;;;1200       if (!(st.chip_cfg.sensors))
00008a  48dc              LDR      r0,|L1.1020|
00008c  7a80              LDRB     r0,[r0,#0xa]
00008e  b910              CBNZ     r0,|L1.150|
;;;1201           return -1;
000090  f04f30ff          MOV      r0,#0xffffffff
                  |L1.148|
;;;1202   
;;;1203       data = 0;
;;;1204       if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
;;;1205           return -1;
;;;1206       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
;;;1207           return -1;
;;;1208       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;1209           return -1;
;;;1210   
;;;1211       if (st.chip_cfg.dmp_on) {
;;;1212           data = BIT_FIFO_RST | BIT_DMP_RST;
;;;1213           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;1214               return -1;
;;;1215           delay_ms(50);
;;;1216           data = BIT_DMP_EN | BIT_FIFO_EN;
;;;1217           if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
;;;1218               data |= BIT_AUX_IF_EN;
;;;1219           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;1220               return -1;
;;;1221           if (st.chip_cfg.int_enable)
;;;1222               data = BIT_DMP_INT_EN;
;;;1223           else
;;;1224               data = 0;
;;;1225           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
;;;1226               return -1;
;;;1227           data = 0;
;;;1228           if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
;;;1229               return -1;
;;;1230       } else {
;;;1231           data = BIT_FIFO_RST;
;;;1232           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;1233               return -1;
;;;1234           if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
;;;1235               data = BIT_FIFO_EN;
;;;1236           else
;;;1237               data = BIT_FIFO_EN | BIT_AUX_IF_EN;
;;;1238           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;1239               return -1;
;;;1240           delay_ms(50);
;;;1241           if (st.chip_cfg.int_enable)
;;;1242               data = BIT_DATA_RDY_EN;
;;;1243           else
;;;1244               data = 0;
;;;1245           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
;;;1246               return -1;
;;;1247           if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
;;;1248               return -1;
;;;1249       }
;;;1250       return 0;
;;;1251   }
000094  bd08              POP      {r3,pc}
                  |L1.150|
000096  2000              MOVS     r0,#0                 ;1203
000098  9000              STR      r0,[sp,#0]            ;1203
00009a  4ad8              LDR      r2,|L1.1020|
00009c  6812              LDR      r2,[r2,#0]            ;1204  ; st
00009e  7bd1              LDRB     r1,[r2,#0xf]          ;1204
0000a0  4ad6              LDR      r2,|L1.1020|
0000a2  6852              LDR      r2,[r2,#4]            ;1204  ; st
0000a4  7810              LDRB     r0,[r2,#0]            ;1204
0000a6  466b              MOV      r3,sp                 ;1204
0000a8  2201              MOVS     r2,#1                 ;1204
0000aa  f7fffffe          BL       I2C_Write
0000ae  b110              CBZ      r0,|L1.182|
0000b0  f04f30ff          MOV      r0,#0xffffffff        ;1205
0000b4  e7ee              B        |L1.148|
                  |L1.182|
0000b6  4ad1              LDR      r2,|L1.1020|
0000b8  6812              LDR      r2,[r2,#0]            ;1206  ; st
0000ba  7951              LDRB     r1,[r2,#5]            ;1206
0000bc  4acf              LDR      r2,|L1.1020|
0000be  6852              LDR      r2,[r2,#4]            ;1206  ; st
0000c0  7810              LDRB     r0,[r2,#0]            ;1206
0000c2  466b              MOV      r3,sp                 ;1206
0000c4  2201              MOVS     r2,#1                 ;1206
0000c6  f7fffffe          BL       I2C_Write
0000ca  b110              CBZ      r0,|L1.210|
0000cc  f04f30ff          MOV      r0,#0xffffffff        ;1207
0000d0  e7e0              B        |L1.148|
                  |L1.210|
0000d2  4aca              LDR      r2,|L1.1020|
0000d4  6812              LDR      r2,[r2,#0]            ;1208  ; st
0000d6  7911              LDRB     r1,[r2,#4]            ;1208
0000d8  4ac8              LDR      r2,|L1.1020|
0000da  6852              LDR      r2,[r2,#4]            ;1208  ; st
0000dc  7810              LDRB     r0,[r2,#0]            ;1208
0000de  466b              MOV      r3,sp                 ;1208
0000e0  2201              MOVS     r2,#1                 ;1208
0000e2  f7fffffe          BL       I2C_Write
0000e6  b110              CBZ      r0,|L1.238|
0000e8  f04f30ff          MOV      r0,#0xffffffff        ;1209
0000ec  e7d2              B        |L1.148|
                  |L1.238|
0000ee  48c3              LDR      r0,|L1.1020|
0000f0  f8900024          LDRB     r0,[r0,#0x24]         ;1211
0000f4  2800              CMP      r0,#0                 ;1211
0000f6  d053              BEQ      |L1.416|
0000f8  200c              MOVS     r0,#0xc               ;1212
0000fa  9000              STR      r0,[sp,#0]            ;1212
0000fc  4abf              LDR      r2,|L1.1020|
0000fe  6812              LDR      r2,[r2,#0]            ;1213  ; st
000100  7911              LDRB     r1,[r2,#4]            ;1213
000102  4abe              LDR      r2,|L1.1020|
000104  6852              LDR      r2,[r2,#4]            ;1213  ; st
000106  7810              LDRB     r0,[r2,#0]            ;1213
000108  466b              MOV      r3,sp                 ;1213
00010a  2201              MOVS     r2,#1                 ;1213
00010c  f7fffffe          BL       I2C_Write
000110  b110              CBZ      r0,|L1.280|
000112  f04f30ff          MOV      r0,#0xffffffff        ;1214
000116  e7bd              B        |L1.148|
                  |L1.280|
000118  2032              MOVS     r0,#0x32              ;1215
00011a  f7fffffe          BL       delay_ms
00011e  20c0              MOVS     r0,#0xc0              ;1216
000120  9000              STR      r0,[sp,#0]            ;1216
000122  48b6              LDR      r0,|L1.1020|
000124  7a80              LDRB     r0,[r0,#0xa]          ;1217
000126  f0000001          AND      r0,r0,#1              ;1217
00012a  b120              CBZ      r0,|L1.310|
00012c  f89d0000          LDRB     r0,[sp,#0]            ;1218
000130  f0400020          ORR      r0,r0,#0x20           ;1218
000134  9000              STR      r0,[sp,#0]            ;1218
                  |L1.310|
000136  4ab1              LDR      r2,|L1.1020|
000138  6812              LDR      r2,[r2,#0]            ;1219  ; st
00013a  7911              LDRB     r1,[r2,#4]            ;1219
00013c  4aaf              LDR      r2,|L1.1020|
00013e  6852              LDR      r2,[r2,#4]            ;1219  ; st
000140  7810              LDRB     r0,[r2,#0]            ;1219
000142  466b              MOV      r3,sp                 ;1219
000144  2201              MOVS     r2,#1                 ;1219
000146  f7fffffe          BL       I2C_Write
00014a  b110              CBZ      r0,|L1.338|
00014c  f04f30ff          MOV      r0,#0xffffffff        ;1220
000150  e7a0              B        |L1.148|
                  |L1.338|
000152  48aa              LDR      r0,|L1.1020|
000154  7c40              LDRB     r0,[r0,#0x11]         ;1221
000156  b110              CBZ      r0,|L1.350|
000158  2002              MOVS     r0,#2                 ;1222
00015a  9000              STR      r0,[sp,#0]            ;1222
00015c  e001              B        |L1.354|
                  |L1.350|
00015e  2000              MOVS     r0,#0                 ;1224
000160  9000              STR      r0,[sp,#0]            ;1224
                  |L1.354|
000162  4aa6              LDR      r2,|L1.1020|
000164  6812              LDR      r2,[r2,#0]            ;1225  ; st
000166  7bd1              LDRB     r1,[r2,#0xf]          ;1225
000168  4aa4              LDR      r2,|L1.1020|
00016a  6852              LDR      r2,[r2,#4]            ;1225  ; st
00016c  7810              LDRB     r0,[r2,#0]            ;1225
00016e  466b              MOV      r3,sp                 ;1225
000170  2201              MOVS     r2,#1                 ;1225
000172  f7fffffe          BL       I2C_Write
000176  b110              CBZ      r0,|L1.382|
000178  f04f30ff          MOV      r0,#0xffffffff        ;1226
00017c  e78a              B        |L1.148|
                  |L1.382|
00017e  2000              MOVS     r0,#0                 ;1227
000180  9000              STR      r0,[sp,#0]            ;1227
000182  4a9e              LDR      r2,|L1.1020|
000184  6812              LDR      r2,[r2,#0]            ;1228  ; st
000186  7951              LDRB     r1,[r2,#5]            ;1228
000188  4a9c              LDR      r2,|L1.1020|
00018a  6852              LDR      r2,[r2,#4]            ;1228  ; st
00018c  7810              LDRB     r0,[r2,#0]            ;1228
00018e  466b              MOV      r3,sp                 ;1228
000190  2201              MOVS     r2,#1                 ;1228
000192  f7fffffe          BL       I2C_Write
000196  2800              CMP      r0,#0                 ;1228
000198  d055              BEQ      |L1.582|
00019a  f04f30ff          MOV      r0,#0xffffffff        ;1229
00019e  e779              B        |L1.148|
                  |L1.416|
0001a0  2004              MOVS     r0,#4                 ;1231
0001a2  9000              STR      r0,[sp,#0]            ;1231
0001a4  4a95              LDR      r2,|L1.1020|
0001a6  6812              LDR      r2,[r2,#0]            ;1232  ; st
0001a8  7911              LDRB     r1,[r2,#4]            ;1232
0001aa  4a94              LDR      r2,|L1.1020|
0001ac  6852              LDR      r2,[r2,#4]            ;1232  ; st
0001ae  7810              LDRB     r0,[r2,#0]            ;1232
0001b0  466b              MOV      r3,sp                 ;1232
0001b2  2201              MOVS     r2,#1                 ;1232
0001b4  f7fffffe          BL       I2C_Write
0001b8  b110              CBZ      r0,|L1.448|
0001ba  f04f30ff          MOV      r0,#0xffffffff        ;1233
0001be  e769              B        |L1.148|
                  |L1.448|
0001c0  488e              LDR      r0,|L1.1020|
0001c2  7c80              LDRB     r0,[r0,#0x12]         ;1234
0001c4  b920              CBNZ     r0,|L1.464|
0001c6  488d              LDR      r0,|L1.1020|
0001c8  7a80              LDRB     r0,[r0,#0xa]          ;1234
0001ca  f0000001          AND      r0,r0,#1              ;1234
0001ce  b910              CBNZ     r0,|L1.470|
                  |L1.464|
0001d0  2040              MOVS     r0,#0x40              ;1235
0001d2  9000              STR      r0,[sp,#0]            ;1235
0001d4  e001              B        |L1.474|
                  |L1.470|
0001d6  2060              MOVS     r0,#0x60              ;1237
0001d8  9000              STR      r0,[sp,#0]            ;1237
                  |L1.474|
0001da  4a88              LDR      r2,|L1.1020|
0001dc  6812              LDR      r2,[r2,#0]            ;1238  ; st
0001de  7911              LDRB     r1,[r2,#4]            ;1238
0001e0  4a86              LDR      r2,|L1.1020|
0001e2  6852              LDR      r2,[r2,#4]            ;1238  ; st
0001e4  7810              LDRB     r0,[r2,#0]            ;1238
0001e6  466b              MOV      r3,sp                 ;1238
0001e8  2201              MOVS     r2,#1                 ;1238
0001ea  f7fffffe          BL       I2C_Write
0001ee  b110              CBZ      r0,|L1.502|
0001f0  f04f30ff          MOV      r0,#0xffffffff        ;1239
0001f4  e74e              B        |L1.148|
                  |L1.502|
0001f6  2032              MOVS     r0,#0x32              ;1240
0001f8  f7fffffe          BL       delay_ms
0001fc  487f              LDR      r0,|L1.1020|
0001fe  7c40              LDRB     r0,[r0,#0x11]         ;1241
000200  b110              CBZ      r0,|L1.520|
000202  2001              MOVS     r0,#1                 ;1242
000204  9000              STR      r0,[sp,#0]            ;1242
000206  e001              B        |L1.524|
                  |L1.520|
000208  2000              MOVS     r0,#0                 ;1244
00020a  9000              STR      r0,[sp,#0]            ;1244
                  |L1.524|
00020c  4a7b              LDR      r2,|L1.1020|
00020e  6812              LDR      r2,[r2,#0]            ;1245  ; st
000210  7bd1              LDRB     r1,[r2,#0xf]          ;1245
000212  4a7a              LDR      r2,|L1.1020|
000214  6852              LDR      r2,[r2,#4]            ;1245  ; st
000216  7810              LDRB     r0,[r2,#0]            ;1245
000218  466b              MOV      r3,sp                 ;1245
00021a  2201              MOVS     r2,#1                 ;1245
00021c  f7fffffe          BL       I2C_Write
000220  b110              CBZ      r0,|L1.552|
000222  f04f30ff          MOV      r0,#0xffffffff        ;1246
000226  e735              B        |L1.148|
                  |L1.552|
000228  4a74              LDR      r2,|L1.1020|
00022a  6812              LDR      r2,[r2,#0]            ;1247  ; st
00022c  7951              LDRB     r1,[r2,#5]            ;1247
00022e  4a73              LDR      r2,|L1.1020|
000230  6852              LDR      r2,[r2,#4]            ;1247  ; st
000232  7810              LDRB     r0,[r2,#0]            ;1247
000234  4b71              LDR      r3,|L1.1020|
000236  3310              ADDS     r3,r3,#0x10           ;1247
000238  2201              MOVS     r2,#1                 ;1247
00023a  f7fffffe          BL       I2C_Write
00023e  b110              CBZ      r0,|L1.582|
000240  f04f30ff          MOV      r0,#0xffffffff        ;1248
000244  e726              B        |L1.148|
                  |L1.582|
000246  2000              MOVS     r0,#0                 ;1250
000248  e724              B        |L1.148|
;;;1252   
                          ENDP

                  set_int_enable PROC
;;;784     */
;;;785    static int set_int_enable(unsigned char enable)
00024a  b538              PUSH     {r3-r5,lr}
;;;786    {
00024c  4604              MOV      r4,r0
;;;787        unsigned char tmp;
;;;788    
;;;789        if (st.chip_cfg.dmp_on) {
00024e  486b              LDR      r0,|L1.1020|
000250  f8900024          LDRB     r0,[r0,#0x24]
000254  b1c0              CBZ      r0,|L1.648|
;;;790            if (enable)
000256  b114              CBZ      r4,|L1.606|
;;;791                tmp = BIT_DMP_INT_EN;
000258  2002              MOVS     r0,#2
00025a  9000              STR      r0,[sp,#0]
00025c  e001              B        |L1.610|
                  |L1.606|
;;;792            else
;;;793                tmp = 0x00;
00025e  2000              MOVS     r0,#0
000260  9000              STR      r0,[sp,#0]
                  |L1.610|
;;;794            if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
000262  4a66              LDR      r2,|L1.1020|
000264  6812              LDR      r2,[r2,#0]  ; st
000266  7bd1              LDRB     r1,[r2,#0xf]
000268  4a64              LDR      r2,|L1.1020|
00026a  6852              LDR      r2,[r2,#4]  ; st
00026c  7810              LDRB     r0,[r2,#0]
00026e  466b              MOV      r3,sp
000270  2201              MOVS     r2,#1
000272  f7fffffe          BL       I2C_Write
000276  b110              CBZ      r0,|L1.638|
;;;795                return -1;
000278  f04f30ff          MOV      r0,#0xffffffff
                  |L1.636|
;;;796            st.chip_cfg.int_enable = tmp;
;;;797        } else {
;;;798            if (!st.chip_cfg.sensors)
;;;799                return -1;
;;;800            if (enable && st.chip_cfg.int_enable)
;;;801                return 0;
;;;802            if (enable)
;;;803                tmp = BIT_DATA_RDY_EN;
;;;804            else
;;;805                tmp = 0x00;
;;;806            if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
;;;807                return -1;
;;;808            st.chip_cfg.int_enable = tmp;
;;;809        }
;;;810        return 0;
;;;811    }
00027c  bd38              POP      {r3-r5,pc}
                  |L1.638|
00027e  f89d1000          LDRB     r1,[sp,#0]            ;796
000282  485e              LDR      r0,|L1.1020|
000284  7441              STRB     r1,[r0,#0x11]         ;796
000286  e023              B        |L1.720|
                  |L1.648|
000288  485c              LDR      r0,|L1.1020|
00028a  7a80              LDRB     r0,[r0,#0xa]          ;798
00028c  b910              CBNZ     r0,|L1.660|
00028e  f04f30ff          MOV      r0,#0xffffffff        ;799
000292  e7f3              B        |L1.636|
                  |L1.660|
000294  b124              CBZ      r4,|L1.672|
000296  4859              LDR      r0,|L1.1020|
000298  7c40              LDRB     r0,[r0,#0x11]         ;800
00029a  b108              CBZ      r0,|L1.672|
00029c  2000              MOVS     r0,#0                 ;801
00029e  e7ed              B        |L1.636|
                  |L1.672|
0002a0  b114              CBZ      r4,|L1.680|
0002a2  2001              MOVS     r0,#1                 ;803
0002a4  9000              STR      r0,[sp,#0]            ;803
0002a6  e001              B        |L1.684|
                  |L1.680|
0002a8  2000              MOVS     r0,#0                 ;805
0002aa  9000              STR      r0,[sp,#0]            ;805
                  |L1.684|
0002ac  4a53              LDR      r2,|L1.1020|
0002ae  6812              LDR      r2,[r2,#0]            ;806  ; st
0002b0  7bd1              LDRB     r1,[r2,#0xf]          ;806
0002b2  4a52              LDR      r2,|L1.1020|
0002b4  6852              LDR      r2,[r2,#4]            ;806  ; st
0002b6  7810              LDRB     r0,[r2,#0]            ;806
0002b8  466b              MOV      r3,sp                 ;806
0002ba  2201              MOVS     r2,#1                 ;806
0002bc  f7fffffe          BL       I2C_Write
0002c0  b110              CBZ      r0,|L1.712|
0002c2  f04f30ff          MOV      r0,#0xffffffff        ;807
0002c6  e7d9              B        |L1.636|
                  |L1.712|
0002c8  f89d1000          LDRB     r1,[sp,#0]            ;808
0002cc  484b              LDR      r0,|L1.1020|
0002ce  7441              STRB     r1,[r0,#0x11]         ;808
                  |L1.720|
0002d0  2000              MOVS     r0,#0                 ;810
0002d2  e7d3              B        |L1.636|
;;;812    
                          ENDP

                  mpu_set_lpf PROC
;;;1422    */
;;;1423   int mpu_set_lpf(unsigned short lpf)
0002d4  b538              PUSH     {r3-r5,lr}
;;;1424   {
0002d6  4604              MOV      r4,r0
;;;1425       unsigned char data;
;;;1426   
;;;1427       if (!(st.chip_cfg.sensors))
0002d8  4848              LDR      r0,|L1.1020|
0002da  7a80              LDRB     r0,[r0,#0xa]
0002dc  b910              CBNZ     r0,|L1.740|
;;;1428           return -1;
0002de  f04f30ff          MOV      r0,#0xffffffff
                  |L1.738|
;;;1429   
;;;1430       if (lpf >= 188)
;;;1431           data = INV_FILTER_188HZ;
;;;1432       else if (lpf >= 98)
;;;1433           data = INV_FILTER_98HZ;
;;;1434       else if (lpf >= 42)
;;;1435           data = INV_FILTER_42HZ;
;;;1436       else if (lpf >= 20)
;;;1437           data = INV_FILTER_20HZ;
;;;1438       else if (lpf >= 10)
;;;1439           data = INV_FILTER_10HZ;
;;;1440       else
;;;1441           data = INV_FILTER_5HZ;
;;;1442   
;;;1443       if (st.chip_cfg.lpf == data)
;;;1444           return 0;
;;;1445       if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
;;;1446           return -1;
;;;1447       st.chip_cfg.lpf = data;
;;;1448       return 0;
;;;1449   }
0002e2  bd38              POP      {r3-r5,pc}
                  |L1.740|
0002e4  2cbc              CMP      r4,#0xbc              ;1430
0002e6  db02              BLT      |L1.750|
0002e8  2001              MOVS     r0,#1                 ;1431
0002ea  9000              STR      r0,[sp,#0]            ;1431
0002ec  e015              B        |L1.794|
                  |L1.750|
0002ee  2c62              CMP      r4,#0x62              ;1432
0002f0  db02              BLT      |L1.760|
0002f2  2002              MOVS     r0,#2                 ;1433
0002f4  9000              STR      r0,[sp,#0]            ;1433
0002f6  e010              B        |L1.794|
                  |L1.760|
0002f8  2c2a              CMP      r4,#0x2a              ;1434
0002fa  db02              BLT      |L1.770|
0002fc  2003              MOVS     r0,#3                 ;1435
0002fe  9000              STR      r0,[sp,#0]            ;1435
000300  e00b              B        |L1.794|
                  |L1.770|
000302  2c14              CMP      r4,#0x14              ;1436
000304  db02              BLT      |L1.780|
000306  2004              MOVS     r0,#4                 ;1437
000308  9000              STR      r0,[sp,#0]            ;1437
00030a  e006              B        |L1.794|
                  |L1.780|
00030c  2c0a              CMP      r4,#0xa               ;1438
00030e  db02              BLT      |L1.790|
000310  2005              MOVS     r0,#5                 ;1439
000312  9000              STR      r0,[sp,#0]            ;1439
000314  e001              B        |L1.794|
                  |L1.790|
000316  2006              MOVS     r0,#6                 ;1441
000318  9000              STR      r0,[sp,#0]            ;1441
                  |L1.794|
00031a  4838              LDR      r0,|L1.1020|
00031c  7ac0              LDRB     r0,[r0,#0xb]          ;1443
00031e  f89d1000          LDRB     r1,[sp,#0]            ;1443
000322  4288              CMP      r0,r1                 ;1443
000324  d101              BNE      |L1.810|
000326  2000              MOVS     r0,#0                 ;1444
000328  e7db              B        |L1.738|
                  |L1.810|
00032a  4a34              LDR      r2,|L1.1020|
00032c  6812              LDR      r2,[r2,#0]            ;1445  ; st
00032e  7891              LDRB     r1,[r2,#2]            ;1445
000330  4a32              LDR      r2,|L1.1020|
000332  6852              LDR      r2,[r2,#4]            ;1445  ; st
000334  7810              LDRB     r0,[r2,#0]            ;1445
000336  466b              MOV      r3,sp                 ;1445
000338  2201              MOVS     r2,#1                 ;1445
00033a  f7fffffe          BL       I2C_Write
00033e  b110              CBZ      r0,|L1.838|
000340  f04f30ff          MOV      r0,#0xffffffff        ;1446
000344  e7cd              B        |L1.738|
                  |L1.838|
000346  f89d1000          LDRB     r1,[sp,#0]            ;1447
00034a  482c              LDR      r0,|L1.1020|
00034c  72c1              STRB     r1,[r0,#0xb]          ;1447
00034e  2000              MOVS     r0,#0                 ;1448
000350  e7c7              B        |L1.738|
;;;1450   
                          ENDP

                  mpu_configure_fifo PROC
;;;1634    */
;;;1635   int mpu_configure_fifo(unsigned char sensors)
000352  b570              PUSH     {r4-r6,lr}
;;;1636   {
000354  4604              MOV      r4,r0
;;;1637       unsigned char prev;
;;;1638       int result = 0;
000356  2600              MOVS     r6,#0
;;;1639   
;;;1640       /* Compass data isn't going into the FIFO. Stop trying. */
;;;1641       sensors &= ~INV_XYZ_COMPASS;
000358  f0240401          BIC      r4,r4,#1
;;;1642   
;;;1643       if (st.chip_cfg.dmp_on)
00035c  4827              LDR      r0,|L1.1020|
00035e  f8900024          LDRB     r0,[r0,#0x24]
000362  b108              CBZ      r0,|L1.872|
;;;1644           return 0;
000364  2000              MOVS     r0,#0
                  |L1.870|
;;;1645       else {
;;;1646           if (!(st.chip_cfg.sensors))
;;;1647               return -1;
;;;1648           prev = st.chip_cfg.fifo_enable;
;;;1649           st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
;;;1650           if (st.chip_cfg.fifo_enable != sensors)
;;;1651               /* You're not getting what you asked for. Some sensors are
;;;1652                * asleep.
;;;1653                */
;;;1654               result = -1;
;;;1655           else
;;;1656               result = 0;
;;;1657           if (sensors || st.chip_cfg.lp_accel_mode)
;;;1658               set_int_enable(1);
;;;1659           else
;;;1660               set_int_enable(0);
;;;1661           if (sensors) {
;;;1662               if (mpu_reset_fifo()) {
;;;1663                   st.chip_cfg.fifo_enable = prev;
;;;1664                   return -1;
;;;1665               }
;;;1666           }
;;;1667       }
;;;1668   
;;;1669       return result;
;;;1670   }
000366  bd70              POP      {r4-r6,pc}
                  |L1.872|
000368  4824              LDR      r0,|L1.1020|
00036a  7a80              LDRB     r0,[r0,#0xa]          ;1646
00036c  b910              CBNZ     r0,|L1.884|
00036e  f04f30ff          MOV      r0,#0xffffffff        ;1647
000372  e7f8              B        |L1.870|
                  |L1.884|
000374  4821              LDR      r0,|L1.1020|
000376  7c05              LDRB     r5,[r0,#0x10]         ;1648
000378  7a80              LDRB     r0,[r0,#0xa]          ;1649
00037a  4020              ANDS     r0,r0,r4              ;1649
00037c  491f              LDR      r1,|L1.1020|
00037e  7408              STRB     r0,[r1,#0x10]         ;1649
000380  4608              MOV      r0,r1                 ;1650
000382  7c00              LDRB     r0,[r0,#0x10]         ;1650
000384  42a0              CMP      r0,r4                 ;1650
000386  d002              BEQ      |L1.910|
000388  f04f36ff          MOV      r6,#0xffffffff        ;1654
00038c  e000              B        |L1.912|
                  |L1.910|
00038e  2600              MOVS     r6,#0                 ;1656
                  |L1.912|
000390  b914              CBNZ     r4,|L1.920|
000392  481a              LDR      r0,|L1.1020|
000394  7d00              LDRB     r0,[r0,#0x14]         ;1657
000396  b118              CBZ      r0,|L1.928|
                  |L1.920|
000398  2001              MOVS     r0,#1                 ;1658
00039a  f7fffffe          BL       set_int_enable
00039e  e002              B        |L1.934|
                  |L1.928|
0003a0  2000              MOVS     r0,#0                 ;1660
0003a2  f7fffffe          BL       set_int_enable
                  |L1.934|
0003a6  b13c              CBZ      r4,|L1.952|
0003a8  f7fffffe          BL       mpu_reset_fifo
0003ac  b120              CBZ      r0,|L1.952|
0003ae  4813              LDR      r0,|L1.1020|
0003b0  7405              STRB     r5,[r0,#0x10]         ;1663
0003b2  f04f30ff          MOV      r0,#0xffffffff        ;1664
0003b6  e7d6              B        |L1.870|
                  |L1.952|
0003b8  4630              MOV      r0,r6                 ;1669
0003ba  e7d4              B        |L1.870|
;;;1671   
                          ENDP

                  mpu_set_int_latched PROC
;;;1982    */
;;;1983   int mpu_set_int_latched(unsigned char enable)
0003bc  b538              PUSH     {r3-r5,lr}
;;;1984   {
0003be  4604              MOV      r4,r0
;;;1985       unsigned char tmp;
;;;1986       if (st.chip_cfg.latched_int == enable)
0003c0  480e              LDR      r0,|L1.1020|
0003c2  f8900023          LDRB     r0,[r0,#0x23]
0003c6  42a0              CMP      r0,r4
0003c8  d101              BNE      |L1.974|
;;;1987           return 0;
0003ca  2000              MOVS     r0,#0
                  |L1.972|
;;;1988   
;;;1989       if (enable)
;;;1990           tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
;;;1991       else
;;;1992           tmp = 0;
;;;1993       if (st.chip_cfg.bypass_mode)
;;;1994           tmp |= BIT_BYPASS_EN;
;;;1995       if (st.chip_cfg.active_low_int)
;;;1996           tmp |= BIT_ACTL;
;;;1997       if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
;;;1998           return -1;
;;;1999       st.chip_cfg.latched_int = enable;
;;;2000       return 0;
;;;2001   }
0003cc  bd38              POP      {r3-r5,pc}
                  |L1.974|
0003ce  b114              CBZ      r4,|L1.982|
0003d0  2030              MOVS     r0,#0x30              ;1990
0003d2  9000              STR      r0,[sp,#0]            ;1990
0003d4  e001              B        |L1.986|
                  |L1.982|
0003d6  2000              MOVS     r0,#0                 ;1992
0003d8  9000              STR      r0,[sp,#0]            ;1992
                  |L1.986|
0003da  4808              LDR      r0,|L1.1020|
0003dc  7c80              LDRB     r0,[r0,#0x12]         ;1993
0003de  b120              CBZ      r0,|L1.1002|
0003e0  f89d0000          LDRB     r0,[sp,#0]            ;1994
0003e4  f0400002          ORR      r0,r0,#2              ;1994
0003e8  9000              STR      r0,[sp,#0]            ;1994
                  |L1.1002|
0003ea  4804              LDR      r0,|L1.1020|
0003ec  f8900022          LDRB     r0,[r0,#0x22]         ;1995
0003f0  b178              CBZ      r0,|L1.1042|
0003f2  f89d0000          LDRB     r0,[sp,#0]            ;1996
0003f6  f0400080          ORR      r0,r0,#0x80           ;1996
0003fa  e009              B        |L1.1040|
                  |L1.1020|
                          DCD      ||st||
                  |L1.1024|
                          DCD      0x43030000
                  |L1.1028|
                          DCD      0x42830000
                  |L1.1032|
                          DCD      0x42033333
                  |L1.1036|
                          DCD      0x41833333
                  |L1.1040|
000410  9000              STR      r0,[sp,#0]            ;1996
                  |L1.1042|
000412  4afe              LDR      r2,|L1.2060|
000414  6812              LDR      r2,[r2,#0]            ;1997  ; st
000416  7d11              LDRB     r1,[r2,#0x14]         ;1997
000418  4afc              LDR      r2,|L1.2060|
00041a  6852              LDR      r2,[r2,#4]            ;1997  ; st
00041c  7810              LDRB     r0,[r2,#0]            ;1997
00041e  466b              MOV      r3,sp                 ;1997
000420  2201              MOVS     r2,#1                 ;1997
000422  f7fffffe          BL       I2C_Write
000426  b110              CBZ      r0,|L1.1070|
000428  f04f30ff          MOV      r0,#0xffffffff        ;1998
00042c  e7ce              B        |L1.972|
                  |L1.1070|
00042e  48f7              LDR      r0,|L1.2060|
000430  f8804023          STRB     r4,[r0,#0x23]         ;1999
000434  2000              MOVS     r0,#0                 ;2000
000436  e7c9              B        |L1.972|
;;;2002   
                          ENDP

                  mpu_lp_accel_mode PROC
;;;991     */
;;;992    int mpu_lp_accel_mode(unsigned char rate)
000438  b538              PUSH     {r3-r5,lr}
;;;993    {
00043a  4604              MOV      r4,r0
;;;994        unsigned char tmp[2];
;;;995    
;;;996        if (rate > 40)
00043c  2c28              CMP      r4,#0x28
00043e  dd02              BLE      |L1.1094|
;;;997            return -1;
000440  f04f30ff          MOV      r0,#0xffffffff
                  |L1.1092|
;;;998    
;;;999        if (!rate) {
;;;1000           mpu_set_int_latched(0);
;;;1001           tmp[0] = 0;
;;;1002           tmp[1] = BIT_STBY_XYZG;
;;;1003           if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
;;;1004               return -1;
;;;1005           st.chip_cfg.lp_accel_mode = 0;
;;;1006           return 0;
;;;1007       }
;;;1008       /* For LP accel, we automatically configure the hardware to produce latched
;;;1009        * interrupts. In LP accel mode, the hardware cycles into sleep mode before
;;;1010        * it gets a chance to deassert the interrupt pin; therefore, we shift this
;;;1011        * responsibility over to the MCU.
;;;1012        *
;;;1013        * Any register read will clear the interrupt.
;;;1014        */
;;;1015       mpu_set_int_latched(1);
;;;1016   #if defined MPU6050
;;;1017       tmp[0] = BIT_LPA_CYCLE;
;;;1018       if (rate == 1) {
;;;1019           tmp[1] = INV_LPA_1_25HZ;
;;;1020           mpu_set_lpf(5);
;;;1021       } else if (rate <= 5) {
;;;1022           tmp[1] = INV_LPA_5HZ;
;;;1023           mpu_set_lpf(5);
;;;1024       } else if (rate <= 20) {
;;;1025           tmp[1] = INV_LPA_20HZ;
;;;1026           mpu_set_lpf(10);
;;;1027       } else {
;;;1028           tmp[1] = INV_LPA_40HZ;
;;;1029           mpu_set_lpf(20);
;;;1030       }
;;;1031       tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
;;;1032       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
;;;1033           return -1;
;;;1034   #elif defined MPU6500
;;;1035       /* Set wake frequency. */
;;;1036       if (rate == 1)
;;;1037           tmp[0] = INV_LPA_1_25HZ;
;;;1038       else if (rate == 2)
;;;1039           tmp[0] = INV_LPA_2_5HZ;
;;;1040       else if (rate <= 5)
;;;1041           tmp[0] = INV_LPA_5HZ;
;;;1042       else if (rate <= 10)
;;;1043           tmp[0] = INV_LPA_10HZ;
;;;1044       else if (rate <= 20)
;;;1045           tmp[0] = INV_LPA_20HZ;
;;;1046       else if (rate <= 40)
;;;1047           tmp[0] = INV_LPA_40HZ;
;;;1048       else if (rate <= 80)
;;;1049           tmp[0] = INV_LPA_80HZ;
;;;1050       else if (rate <= 160)
;;;1051           tmp[0] = INV_LPA_160HZ;
;;;1052       else if (rate <= 320)
;;;1053           tmp[0] = INV_LPA_320HZ;
;;;1054       else
;;;1055           tmp[0] = INV_LPA_640HZ;
;;;1056       if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
;;;1057           return -1;
;;;1058       tmp[0] = BIT_LPA_CYCLE;
;;;1059       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
;;;1060           return -1;
;;;1061   #endif
;;;1062       st.chip_cfg.sensors = INV_XYZ_ACCEL;
;;;1063       st.chip_cfg.clk_src = 0;
;;;1064       st.chip_cfg.lp_accel_mode = 1;
;;;1065       mpu_configure_fifo(0);
;;;1066   
;;;1067       return 0;
;;;1068   }
000444  bd38              POP      {r3-r5,pc}
                  |L1.1094|
000446  b9dc              CBNZ     r4,|L1.1152|
000448  2000              MOVS     r0,#0                 ;1000
00044a  f7fffffe          BL       mpu_set_int_latched
00044e  2000              MOVS     r0,#0                 ;1001
000450  f88d0000          STRB     r0,[sp,#0]            ;1001
000454  2007              MOVS     r0,#7                 ;1002
000456  f88d0001          STRB     r0,[sp,#1]            ;1002
00045a  4aec              LDR      r2,|L1.2060|
00045c  6812              LDR      r2,[r2,#0]            ;1003  ; st
00045e  7c91              LDRB     r1,[r2,#0x12]         ;1003
000460  4aea              LDR      r2,|L1.2060|
000462  6852              LDR      r2,[r2,#4]            ;1003  ; st
000464  7810              LDRB     r0,[r2,#0]            ;1003
000466  466b              MOV      r3,sp                 ;1003
000468  2202              MOVS     r2,#2                 ;1003
00046a  f7fffffe          BL       I2C_Write
00046e  b110              CBZ      r0,|L1.1142|
000470  f04f30ff          MOV      r0,#0xffffffff        ;1004
000474  e7e6              B        |L1.1092|
                  |L1.1142|
000476  2100              MOVS     r1,#0                 ;1005
000478  48e4              LDR      r0,|L1.2060|
00047a  7501              STRB     r1,[r0,#0x14]         ;1005
00047c  2000              MOVS     r0,#0                 ;1006
00047e  e7e1              B        |L1.1092|
                  |L1.1152|
000480  2001              MOVS     r0,#1                 ;1015
000482  f7fffffe          BL       mpu_set_int_latched
000486  2020              MOVS     r0,#0x20              ;1017
000488  f88d0000          STRB     r0,[sp,#0]            ;1017
00048c  2c01              CMP      r4,#1                 ;1018
00048e  d106              BNE      |L1.1182|
000490  2000              MOVS     r0,#0                 ;1019
000492  f88d0001          STRB     r0,[sp,#1]            ;1019
000496  2005              MOVS     r0,#5                 ;1020
000498  f7fffffe          BL       mpu_set_lpf
00049c  e017              B        |L1.1230|
                  |L1.1182|
00049e  2c05              CMP      r4,#5                 ;1021
0004a0  dc06              BGT      |L1.1200|
0004a2  2001              MOVS     r0,#1                 ;1022
0004a4  f88d0001          STRB     r0,[sp,#1]            ;1022
0004a8  2005              MOVS     r0,#5                 ;1023
0004aa  f7fffffe          BL       mpu_set_lpf
0004ae  e00e              B        |L1.1230|
                  |L1.1200|
0004b0  2c14              CMP      r4,#0x14              ;1024
0004b2  dc06              BGT      |L1.1218|
0004b4  2002              MOVS     r0,#2                 ;1025
0004b6  f88d0001          STRB     r0,[sp,#1]            ;1025
0004ba  200a              MOVS     r0,#0xa               ;1026
0004bc  f7fffffe          BL       mpu_set_lpf
0004c0  e005              B        |L1.1230|
                  |L1.1218|
0004c2  2003              MOVS     r0,#3                 ;1028
0004c4  f88d0001          STRB     r0,[sp,#1]            ;1028
0004c8  2014              MOVS     r0,#0x14              ;1029
0004ca  f7fffffe          BL       mpu_set_lpf
                  |L1.1230|
0004ce  f89d0001          LDRB     r0,[sp,#1]            ;1031
0004d2  2107              MOVS     r1,#7                 ;1031
0004d4  eb011080          ADD      r0,r1,r0,LSL #6       ;1031
0004d8  b2c0              UXTB     r0,r0                 ;1031
0004da  f88d0001          STRB     r0,[sp,#1]            ;1031
0004de  4acb              LDR      r2,|L1.2060|
0004e0  6812              LDR      r2,[r2,#0]            ;1032  ; st
0004e2  7c91              LDRB     r1,[r2,#0x12]         ;1032
0004e4  4ac9              LDR      r2,|L1.2060|
0004e6  6852              LDR      r2,[r2,#4]            ;1032  ; st
0004e8  7810              LDRB     r0,[r2,#0]            ;1032
0004ea  466b              MOV      r3,sp                 ;1032
0004ec  2202              MOVS     r2,#2                 ;1032
0004ee  f7fffffe          BL       I2C_Write
0004f2  b110              CBZ      r0,|L1.1274|
0004f4  f04f30ff          MOV      r0,#0xffffffff        ;1033
0004f8  e7a4              B        |L1.1092|
                  |L1.1274|
0004fa  2108              MOVS     r1,#8                 ;1062
0004fc  48c3              LDR      r0,|L1.2060|
0004fe  7281              STRB     r1,[r0,#0xa]          ;1062
000500  2100              MOVS     r1,#0                 ;1063
000502  7301              STRB     r1,[r0,#0xc]          ;1063
000504  2101              MOVS     r1,#1                 ;1064
000506  7501              STRB     r1,[r0,#0x14]         ;1064
000508  2000              MOVS     r0,#0                 ;1065
00050a  f7fffffe          BL       mpu_configure_fifo
00050e  2000              MOVS     r0,#0                 ;1067
000510  e798              B        |L1.1092|
;;;1069   
                          ENDP

                  mpu_set_sample_rate PROC
;;;1470    */
;;;1471   int mpu_set_sample_rate(unsigned short rate)
000512  b538              PUSH     {r3-r5,lr}
;;;1472   {
000514  4604              MOV      r4,r0
;;;1473       unsigned char data;
;;;1474   
;;;1475       if (!(st.chip_cfg.sensors))
000516  48bd              LDR      r0,|L1.2060|
000518  7a80              LDRB     r0,[r0,#0xa]
00051a  b910              CBNZ     r0,|L1.1314|
;;;1476           return -1;
00051c  f04f30ff          MOV      r0,#0xffffffff
                  |L1.1312|
;;;1477   
;;;1478       if (st.chip_cfg.dmp_on)
;;;1479           return -1;
;;;1480       else {
;;;1481           if (st.chip_cfg.lp_accel_mode) {
;;;1482               if (rate && (rate <= 40)) {
;;;1483                   /* Just stay in low-power accel mode. */
;;;1484                   mpu_lp_accel_mode(rate);
;;;1485                   return 0;
;;;1486               }
;;;1487               /* Requested rate exceeds the allowed frequencies in LP accel mode,
;;;1488                * switch back to full-power mode.
;;;1489                */
;;;1490               mpu_lp_accel_mode(0);
;;;1491           }
;;;1492           if (rate < 4)
;;;1493               rate = 4;
;;;1494           else if (rate > 1000)
;;;1495               rate = 1000;
;;;1496   
;;;1497           data = 1000 / rate - 1;
;;;1498           if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
;;;1499               return -1;
;;;1500   
;;;1501           st.chip_cfg.sample_rate = 1000 / (1 + data);
;;;1502   
;;;1503   #ifdef AK89xx_SECONDARY
;;;1504           mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
;;;1505   #endif
;;;1506   
;;;1507           /* Automatically set LPF to 1/2 sampling rate. */
;;;1508           mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
;;;1509           return 0;
;;;1510       }
;;;1511   }
000520  bd38              POP      {r3-r5,pc}
                  |L1.1314|
000522  48ba              LDR      r0,|L1.2060|
000524  f8900024          LDRB     r0,[r0,#0x24]         ;1478
000528  b110              CBZ      r0,|L1.1328|
00052a  f04f30ff          MOV      r0,#0xffffffff        ;1479
00052e  e7f7              B        |L1.1312|
                  |L1.1328|
000530  48b6              LDR      r0,|L1.2060|
000532  7d00              LDRB     r0,[r0,#0x14]         ;1481
000534  b150              CBZ      r0,|L1.1356|
000536  b134              CBZ      r4,|L1.1350|
000538  2c28              CMP      r4,#0x28              ;1482
00053a  dc04              BGT      |L1.1350|
00053c  b2e0              UXTB     r0,r4                 ;1484
00053e  f7fffffe          BL       mpu_lp_accel_mode
000542  2000              MOVS     r0,#0                 ;1485
000544  e7ec              B        |L1.1312|
                  |L1.1350|
000546  2000              MOVS     r0,#0                 ;1490
000548  f7fffffe          BL       mpu_lp_accel_mode
                  |L1.1356|
00054c  2c04              CMP      r4,#4                 ;1492
00054e  da01              BGE      |L1.1364|
000550  2404              MOVS     r4,#4                 ;1493
000552  e004              B        |L1.1374|
                  |L1.1364|
000554  f5b47f7a          CMP      r4,#0x3e8             ;1494
000558  dd01              BLE      |L1.1374|
00055a  f44f747a          MOV      r4,#0x3e8             ;1495
                  |L1.1374|
00055e  f44f707a          MOV      r0,#0x3e8             ;1497
000562  fb90f0f4          SDIV     r0,r0,r4              ;1497
000566  1e40              SUBS     r0,r0,#1              ;1497
000568  b2c0              UXTB     r0,r0                 ;1497
00056a  9000              STR      r0,[sp,#0]            ;1497
00056c  4aa7              LDR      r2,|L1.2060|
00056e  6812              LDR      r2,[r2,#0]            ;1498  ; st
000570  7851              LDRB     r1,[r2,#1]            ;1498
000572  4aa6              LDR      r2,|L1.2060|
000574  6852              LDR      r2,[r2,#4]            ;1498  ; st
000576  7810              LDRB     r0,[r2,#0]            ;1498
000578  466b              MOV      r3,sp                 ;1498
00057a  2201              MOVS     r2,#1                 ;1498
00057c  f7fffffe          BL       I2C_Write
000580  b110              CBZ      r0,|L1.1416|
000582  f04f30ff          MOV      r0,#0xffffffff        ;1499
000586  e7cb              B        |L1.1312|
                  |L1.1416|
000588  f89d0000          LDRB     r0,[sp,#0]            ;1501
00058c  1c40              ADDS     r0,r0,#1              ;1501
00058e  f44f717a          MOV      r1,#0x3e8             ;1501
000592  fb91f0f0          SDIV     r0,r1,r0              ;1501
000596  b281              UXTH     r1,r0                 ;1501
000598  489c              LDR      r0,|L1.2060|
00059a  81c1              STRH     r1,[r0,#0xe]          ;1501
00059c  4601              MOV      r1,r0                 ;1508
00059e  89c9              LDRH     r1,[r1,#0xe]          ;1508
0005a0  1048              ASRS     r0,r1,#1              ;1508
0005a2  f7fffffe          BL       mpu_set_lpf
0005a6  2000              MOVS     r0,#0                 ;1509
0005a8  e7ba              B        |L1.1312|
;;;1512   
                          ENDP

                  mpu_set_bypass PROC
;;;1920    */
;;;1921   int mpu_set_bypass(unsigned char bypass_on)
0005aa  b538              PUSH     {r3-r5,lr}
;;;1922   {
0005ac  4604              MOV      r4,r0
;;;1923       unsigned char tmp;
;;;1924   
;;;1925       if (st.chip_cfg.bypass_mode == bypass_on)
0005ae  4897              LDR      r0,|L1.2060|
0005b0  7c80              LDRB     r0,[r0,#0x12]
0005b2  42a0              CMP      r0,r4
0005b4  d101              BNE      |L1.1466|
;;;1926           return 0;
0005b6  2000              MOVS     r0,#0
                  |L1.1464|
;;;1927   
;;;1928       if (bypass_on) {
;;;1929           if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1930               return -1;
;;;1931           tmp &= ~BIT_AUX_IF_EN;
;;;1932           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1933               return -1;
;;;1934           delay_ms(3);
;;;1935           tmp = BIT_BYPASS_EN;
;;;1936           if (st.chip_cfg.active_low_int)
;;;1937               tmp |= BIT_ACTL;
;;;1938           if (st.chip_cfg.latched_int)
;;;1939               tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
;;;1940           if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
;;;1941               return -1;
;;;1942       } else {
;;;1943           /* Enable I2C master mode if compass is being used. */
;;;1944           if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1945               return -1;
;;;1946           if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
;;;1947               tmp |= BIT_AUX_IF_EN;
;;;1948           else
;;;1949               tmp &= ~BIT_AUX_IF_EN;
;;;1950           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1951               return -1;
;;;1952           delay_ms(3);
;;;1953           if (st.chip_cfg.active_low_int)
;;;1954               tmp = BIT_ACTL;
;;;1955           else
;;;1956               tmp = 0;
;;;1957           if (st.chip_cfg.latched_int)
;;;1958               tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
;;;1959           if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
;;;1960               return -1;
;;;1961       }
;;;1962       st.chip_cfg.bypass_mode = bypass_on;
;;;1963       return 0;
;;;1964   }
0005b8  bd38              POP      {r3-r5,pc}
                  |L1.1466|
0005ba  2c00              CMP      r4,#0                 ;1928
0005bc  d046              BEQ      |L1.1612|
0005be  4a93              LDR      r2,|L1.2060|
0005c0  6812              LDR      r2,[r2,#0]            ;1929  ; st
0005c2  7911              LDRB     r1,[r2,#4]            ;1929
0005c4  4a91              LDR      r2,|L1.2060|
0005c6  6852              LDR      r2,[r2,#4]            ;1929  ; st
0005c8  7810              LDRB     r0,[r2,#0]            ;1929
0005ca  466b              MOV      r3,sp                 ;1929
0005cc  2201              MOVS     r2,#1                 ;1929
0005ce  f7fffffe          BL       I2C_Read
0005d2  b110              CBZ      r0,|L1.1498|
0005d4  f04f30ff          MOV      r0,#0xffffffff        ;1930
0005d8  e7ee              B        |L1.1464|
                  |L1.1498|
0005da  f89d0000          LDRB     r0,[sp,#0]            ;1931
0005de  f0200020          BIC      r0,r0,#0x20           ;1931
0005e2  9000              STR      r0,[sp,#0]            ;1931
0005e4  4a89              LDR      r2,|L1.2060|
0005e6  6812              LDR      r2,[r2,#0]            ;1932  ; st
0005e8  7911              LDRB     r1,[r2,#4]            ;1932
0005ea  4a88              LDR      r2,|L1.2060|
0005ec  6852              LDR      r2,[r2,#4]            ;1932  ; st
0005ee  7810              LDRB     r0,[r2,#0]            ;1932
0005f0  466b              MOV      r3,sp                 ;1932
0005f2  2201              MOVS     r2,#1                 ;1932
0005f4  f7fffffe          BL       I2C_Write
0005f8  b110              CBZ      r0,|L1.1536|
0005fa  f04f30ff          MOV      r0,#0xffffffff        ;1933
0005fe  e7db              B        |L1.1464|
                  |L1.1536|
000600  2003              MOVS     r0,#3                 ;1934
000602  f7fffffe          BL       delay_ms
000606  2002              MOVS     r0,#2                 ;1935
000608  9000              STR      r0,[sp,#0]            ;1935
00060a  4880              LDR      r0,|L1.2060|
00060c  f8900022          LDRB     r0,[r0,#0x22]         ;1936
000610  b120              CBZ      r0,|L1.1564|
000612  f89d0000          LDRB     r0,[sp,#0]            ;1937
000616  f0400080          ORR      r0,r0,#0x80           ;1937
00061a  9000              STR      r0,[sp,#0]            ;1937
                  |L1.1564|
00061c  487b              LDR      r0,|L1.2060|
00061e  f8900023          LDRB     r0,[r0,#0x23]         ;1938
000622  b120              CBZ      r0,|L1.1582|
000624  f89d0000          LDRB     r0,[sp,#0]            ;1939
000628  f0400030          ORR      r0,r0,#0x30           ;1939
00062c  9000              STR      r0,[sp,#0]            ;1939
                  |L1.1582|
00062e  4a77              LDR      r2,|L1.2060|
000630  6812              LDR      r2,[r2,#0]            ;1940  ; st
000632  7d11              LDRB     r1,[r2,#0x14]         ;1940
000634  4a75              LDR      r2,|L1.2060|
000636  6852              LDR      r2,[r2,#4]            ;1940  ; st
000638  7810              LDRB     r0,[r2,#0]            ;1940
00063a  466b              MOV      r3,sp                 ;1940
00063c  2201              MOVS     r2,#1                 ;1940
00063e  f7fffffe          BL       I2C_Write
000642  2800              CMP      r0,#0                 ;1940
000644  d051              BEQ      |L1.1770|
000646  f04f30ff          MOV      r0,#0xffffffff        ;1941
00064a  e7b5              B        |L1.1464|
                  |L1.1612|
00064c  4a6f              LDR      r2,|L1.2060|
00064e  6812              LDR      r2,[r2,#0]            ;1944  ; st
000650  7911              LDRB     r1,[r2,#4]            ;1944
000652  4a6e              LDR      r2,|L1.2060|
000654  6852              LDR      r2,[r2,#4]            ;1944  ; st
000656  7810              LDRB     r0,[r2,#0]            ;1944
000658  466b              MOV      r3,sp                 ;1944
00065a  2201              MOVS     r2,#1                 ;1944
00065c  f7fffffe          BL       I2C_Read
000660  b110              CBZ      r0,|L1.1640|
000662  f04f30ff          MOV      r0,#0xffffffff        ;1945
000666  e7a7              B        |L1.1464|
                  |L1.1640|
000668  4868              LDR      r0,|L1.2060|
00066a  7a80              LDRB     r0,[r0,#0xa]          ;1946
00066c  f0000001          AND      r0,r0,#1              ;1946
000670  b128              CBZ      r0,|L1.1662|
000672  f89d0000          LDRB     r0,[sp,#0]            ;1947
000676  f0400020          ORR      r0,r0,#0x20           ;1947
00067a  9000              STR      r0,[sp,#0]            ;1947
00067c  e004              B        |L1.1672|
                  |L1.1662|
00067e  f89d0000          LDRB     r0,[sp,#0]            ;1949
000682  f0200020          BIC      r0,r0,#0x20           ;1949
000686  9000              STR      r0,[sp,#0]            ;1949
                  |L1.1672|
000688  4a60              LDR      r2,|L1.2060|
00068a  6812              LDR      r2,[r2,#0]            ;1950  ; st
00068c  7911              LDRB     r1,[r2,#4]            ;1950
00068e  4a5f              LDR      r2,|L1.2060|
000690  6852              LDR      r2,[r2,#4]            ;1950  ; st
000692  7810              LDRB     r0,[r2,#0]            ;1950
000694  466b              MOV      r3,sp                 ;1950
000696  2201              MOVS     r2,#1                 ;1950
000698  f7fffffe          BL       I2C_Write
00069c  b110              CBZ      r0,|L1.1700|
00069e  f04f30ff          MOV      r0,#0xffffffff        ;1951
0006a2  e789              B        |L1.1464|
                  |L1.1700|
0006a4  2003              MOVS     r0,#3                 ;1952
0006a6  f7fffffe          BL       delay_ms
0006aa  4858              LDR      r0,|L1.2060|
0006ac  f8900022          LDRB     r0,[r0,#0x22]         ;1953
0006b0  b110              CBZ      r0,|L1.1720|
0006b2  2080              MOVS     r0,#0x80              ;1954
0006b4  9000              STR      r0,[sp,#0]            ;1954
0006b6  e001              B        |L1.1724|
                  |L1.1720|
0006b8  2000              MOVS     r0,#0                 ;1956
0006ba  9000              STR      r0,[sp,#0]            ;1956
                  |L1.1724|
0006bc  4853              LDR      r0,|L1.2060|
0006be  f8900023          LDRB     r0,[r0,#0x23]         ;1957
0006c2  b120              CBZ      r0,|L1.1742|
0006c4  f89d0000          LDRB     r0,[sp,#0]            ;1958
0006c8  f0400030          ORR      r0,r0,#0x30           ;1958
0006cc  9000              STR      r0,[sp,#0]            ;1958
                  |L1.1742|
0006ce  4a4f              LDR      r2,|L1.2060|
0006d0  6812              LDR      r2,[r2,#0]            ;1959  ; st
0006d2  7d11              LDRB     r1,[r2,#0x14]         ;1959
0006d4  4a4d              LDR      r2,|L1.2060|
0006d6  6852              LDR      r2,[r2,#4]            ;1959  ; st
0006d8  7810              LDRB     r0,[r2,#0]            ;1959
0006da  466b              MOV      r3,sp                 ;1959
0006dc  2201              MOVS     r2,#1                 ;1959
0006de  f7fffffe          BL       I2C_Write
0006e2  b110              CBZ      r0,|L1.1770|
0006e4  f04f30ff          MOV      r0,#0xffffffff        ;1960
0006e8  e766              B        |L1.1464|
                  |L1.1770|
0006ea  4848              LDR      r0,|L1.2060|
0006ec  7484              STRB     r4,[r0,#0x12]         ;1962
0006ee  2000              MOVS     r0,#0                 ;1963
0006f0  e762              B        |L1.1464|
;;;1965   
                          ENDP

                  mpu_set_dmp_state PROC
;;;2480    */
;;;2481   int mpu_set_dmp_state(unsigned char enable)
0006f2  b538              PUSH     {r3-r5,lr}
;;;2482   {
0006f4  4604              MOV      r4,r0
;;;2483       unsigned char tmp;
;;;2484       if (st.chip_cfg.dmp_on == enable)
0006f6  4845              LDR      r0,|L1.2060|
0006f8  f8900024          LDRB     r0,[r0,#0x24]
0006fc  42a0              CMP      r0,r4
0006fe  d101              BNE      |L1.1796|
;;;2485           return 0;
000700  2000              MOVS     r0,#0
                  |L1.1794|
;;;2486   
;;;2487       if (enable) {
;;;2488           if (!st.chip_cfg.dmp_loaded)
;;;2489               return -1;
;;;2490           /* Disable data ready interrupt. */
;;;2491           set_int_enable(0);
;;;2492           /* Disable bypass mode. */
;;;2493           mpu_set_bypass(0);
;;;2494           /* Keep constant sample rate, FIFO rate controlled by DMP. */
;;;2495           mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
;;;2496           /* Remove FIFO elements. */
;;;2497           tmp = 0;
;;;2498           i2c_write(st.hw->addr, 0x23, 1, &tmp);
;;;2499           st.chip_cfg.dmp_on = 1;
;;;2500           /* Enable DMP interrupt. */
;;;2501           set_int_enable(1);
;;;2502           mpu_reset_fifo();
;;;2503       } else {
;;;2504           /* Disable DMP interrupt. */
;;;2505           set_int_enable(0);
;;;2506           /* Restore FIFO settings. */
;;;2507           tmp = st.chip_cfg.fifo_enable;
;;;2508           i2c_write(st.hw->addr, 0x23, 1, &tmp);
;;;2509           st.chip_cfg.dmp_on = 0;
;;;2510           mpu_reset_fifo();
;;;2511       }
;;;2512       return 0;
;;;2513   }
000702  bd38              POP      {r3-r5,pc}
                  |L1.1796|
000704  b324              CBZ      r4,|L1.1872|
000706  4841              LDR      r0,|L1.2060|
000708  f8900025          LDRB     r0,[r0,#0x25]         ;2488
00070c  b910              CBNZ     r0,|L1.1812|
00070e  f04f30ff          MOV      r0,#0xffffffff        ;2489
000712  e7f6              B        |L1.1794|
                  |L1.1812|
000714  2000              MOVS     r0,#0                 ;2491
000716  f7fffffe          BL       set_int_enable
00071a  2000              MOVS     r0,#0                 ;2493
00071c  f7fffffe          BL       mpu_set_bypass
000720  493a              LDR      r1,|L1.2060|
000722  8cc8              LDRH     r0,[r1,#0x26]         ;2495
000724  f7fffffe          BL       mpu_set_sample_rate
000728  2000              MOVS     r0,#0                 ;2497
00072a  9000              STR      r0,[sp,#0]            ;2497
00072c  4937              LDR      r1,|L1.2060|
00072e  6849              LDR      r1,[r1,#4]            ;2498  ; st
000730  7808              LDRB     r0,[r1,#0]            ;2498
000732  466b              MOV      r3,sp                 ;2498
000734  2201              MOVS     r2,#1                 ;2498
000736  2123              MOVS     r1,#0x23              ;2498
000738  f7fffffe          BL       I2C_Write
00073c  2101              MOVS     r1,#1                 ;2499
00073e  4833              LDR      r0,|L1.2060|
000740  f8801024          STRB     r1,[r0,#0x24]         ;2499
000744  2001              MOVS     r0,#1                 ;2501
000746  f7fffffe          BL       set_int_enable
00074a  f7fffffe          BL       mpu_reset_fifo
00074e  e013              B        |L1.1912|
                  |L1.1872|
000750  2000              MOVS     r0,#0                 ;2505
000752  f7fffffe          BL       set_int_enable
000756  482d              LDR      r0,|L1.2060|
000758  7c00              LDRB     r0,[r0,#0x10]         ;2507
00075a  9000              STR      r0,[sp,#0]            ;2507
00075c  492b              LDR      r1,|L1.2060|
00075e  6849              LDR      r1,[r1,#4]            ;2508  ; st
000760  7808              LDRB     r0,[r1,#0]            ;2508
000762  466b              MOV      r3,sp                 ;2508
000764  2201              MOVS     r2,#1                 ;2508
000766  2123              MOVS     r1,#0x23              ;2508
000768  f7fffffe          BL       I2C_Write
00076c  2100              MOVS     r1,#0                 ;2509
00076e  4827              LDR      r0,|L1.2060|
000770  f8801024          STRB     r1,[r0,#0x24]         ;2509
000774  f7fffffe          BL       mpu_reset_fifo
                  |L1.1912|
000778  2000              MOVS     r0,#0                 ;2512
00077a  e7c2              B        |L1.1794|
;;;2514   
                          ENDP

                  mpu_set_sensors PROC
;;;1695    */
;;;1696   int mpu_set_sensors(unsigned char sensors)
00077c  b538              PUSH     {r3-r5,lr}
;;;1697   {
00077e  4604              MOV      r4,r0
;;;1698       unsigned char data;
;;;1699   #ifdef AK89xx_SECONDARY
;;;1700       unsigned char user_ctrl;
;;;1701   #endif
;;;1702   
;;;1703       if (sensors & INV_XYZ_GYRO)
000780  f0040070          AND      r0,r4,#0x70
000784  b110              CBZ      r0,|L1.1932|
;;;1704           data = INV_CLK_PLL;
000786  2001              MOVS     r0,#1
000788  9000              STR      r0,[sp,#0]
00078a  e005              B        |L1.1944|
                  |L1.1932|
;;;1705       else if (sensors)
00078c  b114              CBZ      r4,|L1.1940|
;;;1706           data = 0;
00078e  2000              MOVS     r0,#0
000790  9000              STR      r0,[sp,#0]
000792  e001              B        |L1.1944|
                  |L1.1940|
;;;1707       else
;;;1708           data = BIT_SLEEP;
000794  2040              MOVS     r0,#0x40
000796  9000              STR      r0,[sp,#0]
                  |L1.1944|
;;;1709       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
000798  4a1c              LDR      r2,|L1.2060|
00079a  6812              LDR      r2,[r2,#0]  ; st
00079c  7c91              LDRB     r1,[r2,#0x12]
00079e  4a1b              LDR      r2,|L1.2060|
0007a0  6852              LDR      r2,[r2,#4]  ; st
0007a2  7810              LDRB     r0,[r2,#0]
0007a4  466b              MOV      r3,sp
0007a6  2201              MOVS     r2,#1
0007a8  f7fffffe          BL       I2C_Write
0007ac  b120              CBZ      r0,|L1.1976|
;;;1710           st.chip_cfg.sensors = 0;
0007ae  2100              MOVS     r1,#0
0007b0  4816              LDR      r0,|L1.2060|
0007b2  7281              STRB     r1,[r0,#0xa]
;;;1711           return -1;
0007b4  1e48              SUBS     r0,r1,#1
                  |L1.1974|
;;;1712       }
;;;1713       st.chip_cfg.clk_src = data & ~BIT_SLEEP;
;;;1714   
;;;1715       data = 0;
;;;1716       if (!(sensors & INV_X_GYRO))
;;;1717           data |= BIT_STBY_XG;
;;;1718       if (!(sensors & INV_Y_GYRO))
;;;1719           data |= BIT_STBY_YG;
;;;1720       if (!(sensors & INV_Z_GYRO))
;;;1721           data |= BIT_STBY_ZG;
;;;1722       if (!(sensors & INV_XYZ_ACCEL))
;;;1723           data |= BIT_STBY_XYZA;
;;;1724       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
;;;1725           st.chip_cfg.sensors = 0;
;;;1726           return -1;
;;;1727       }
;;;1728   
;;;1729       if (sensors && (sensors != INV_XYZ_ACCEL))
;;;1730           /* Latched interrupts only used in LP accel mode. */
;;;1731           mpu_set_int_latched(0);
;;;1732   
;;;1733   #ifdef AK89xx_SECONDARY
;;;1734   #ifdef AK89xx_BYPASS
;;;1735       if (sensors & INV_XYZ_COMPASS)
;;;1736           mpu_set_bypass(1);
;;;1737       else
;;;1738           mpu_set_bypass(0);
;;;1739   #else
;;;1740       if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
;;;1741           return -1;
;;;1742       /* Handle AKM power management. */
;;;1743       if (sensors & INV_XYZ_COMPASS) {
;;;1744           data = AKM_SINGLE_MEASUREMENT;
;;;1745           user_ctrl |= BIT_AUX_IF_EN;
;;;1746       } else {
;;;1747           data = AKM_POWER_DOWN;
;;;1748           user_ctrl &= ~BIT_AUX_IF_EN;
;;;1749       }
;;;1750       if (st.chip_cfg.dmp_on)
;;;1751           user_ctrl |= BIT_DMP_EN;
;;;1752       else
;;;1753           user_ctrl &= ~BIT_DMP_EN;
;;;1754       if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
;;;1755           return -1;
;;;1756       /* Enable/disable I2C master mode. */
;;;1757       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
;;;1758           return -1;
;;;1759   #endif
;;;1760   #endif
;;;1761   
;;;1762       st.chip_cfg.sensors = sensors;
;;;1763       st.chip_cfg.lp_accel_mode = 0;
;;;1764       delay_ms(50);
;;;1765       return 0;
;;;1766   }
0007b6  bd38              POP      {r3-r5,pc}
                  |L1.1976|
0007b8  f89d0000          LDRB     r0,[sp,#0]            ;1713
0007bc  f0200140          BIC      r1,r0,#0x40           ;1713
0007c0  4812              LDR      r0,|L1.2060|
0007c2  7301              STRB     r1,[r0,#0xc]          ;1713
0007c4  2000              MOVS     r0,#0                 ;1715
0007c6  9000              STR      r0,[sp,#0]            ;1715
0007c8  f0040040          AND      r0,r4,#0x40           ;1716
0007cc  b920              CBNZ     r0,|L1.2008|
0007ce  f89d0000          LDRB     r0,[sp,#0]            ;1717
0007d2  f0400004          ORR      r0,r0,#4              ;1717
0007d6  9000              STR      r0,[sp,#0]            ;1717
                  |L1.2008|
0007d8  f0040020          AND      r0,r4,#0x20           ;1718
0007dc  b920              CBNZ     r0,|L1.2024|
0007de  f89d0000          LDRB     r0,[sp,#0]            ;1719
0007e2  f0400002          ORR      r0,r0,#2              ;1719
0007e6  9000              STR      r0,[sp,#0]            ;1719
                  |L1.2024|
0007e8  f0040010          AND      r0,r4,#0x10           ;1720
0007ec  b920              CBNZ     r0,|L1.2040|
0007ee  f89d0000          LDRB     r0,[sp,#0]            ;1721
0007f2  f0400001          ORR      r0,r0,#1              ;1721
0007f6  9000              STR      r0,[sp,#0]            ;1721
                  |L1.2040|
0007f8  f0040008          AND      r0,r4,#8              ;1722
0007fc  b920              CBNZ     r0,|L1.2056|
0007fe  f89d0000          LDRB     r0,[sp,#0]            ;1723
000802  f0400038          ORR      r0,r0,#0x38           ;1723
000806  9000              STR      r0,[sp,#0]            ;1723
                  |L1.2056|
000808  4a00              LDR      r2,|L1.2060|
00080a  e001              B        |L1.2064|
                  |L1.2060|
                          DCD      ||st||
                  |L1.2064|
000810  6812              LDR      r2,[r2,#0]            ;1724  ; st
000812  7cd1              LDRB     r1,[r2,#0x13]         ;1724
000814  4af9              LDR      r2,|L1.3068|
000816  6852              LDR      r2,[r2,#4]            ;1724  ; st
000818  7810              LDRB     r0,[r2,#0]            ;1724
00081a  466b              MOV      r3,sp                 ;1724
00081c  2201              MOVS     r2,#1                 ;1724
00081e  f7fffffe          BL       I2C_Write
000822  b120              CBZ      r0,|L1.2094|
000824  2100              MOVS     r1,#0                 ;1725
000826  48f5              LDR      r0,|L1.3068|
000828  7281              STRB     r1,[r0,#0xa]          ;1725
00082a  1e48              SUBS     r0,r1,#1              ;1726
00082c  e7c3              B        |L1.1974|
                  |L1.2094|
00082e  b124              CBZ      r4,|L1.2106|
000830  2c08              CMP      r4,#8                 ;1729
000832  d002              BEQ      |L1.2106|
000834  2000              MOVS     r0,#0                 ;1731
000836  f7fffffe          BL       mpu_set_int_latched
                  |L1.2106|
00083a  48f0              LDR      r0,|L1.3068|
00083c  7284              STRB     r4,[r0,#0xa]          ;1762
00083e  2100              MOVS     r1,#0                 ;1763
000840  7501              STRB     r1,[r0,#0x14]         ;1763
000842  2032              MOVS     r0,#0x32              ;1764
000844  f7fffffe          BL       delay_ms
000848  2000              MOVS     r0,#0                 ;1765
00084a  e7b4              B        |L1.1974|
;;;1767   
                          ENDP

                  mpu_set_accel_fsr PROC
;;;1349    */
;;;1350   int mpu_set_accel_fsr(unsigned char fsr)
00084c  b538              PUSH     {r3-r5,lr}
;;;1351   {
00084e  4604              MOV      r4,r0
;;;1352       unsigned char data;
;;;1353   
;;;1354       if (!(st.chip_cfg.sensors))
000850  48ea              LDR      r0,|L1.3068|
000852  7a80              LDRB     r0,[r0,#0xa]
000854  b910              CBNZ     r0,|L1.2140|
;;;1355           return -1;
000856  f04f30ff          MOV      r0,#0xffffffff
                  |L1.2138|
;;;1356   
;;;1357       switch (fsr) {
;;;1358       case 2:
;;;1359           data = INV_FSR_2G << 3;
;;;1360           break;
;;;1361       case 4:
;;;1362           data = INV_FSR_4G << 3;
;;;1363           break;
;;;1364       case 8:
;;;1365           data = INV_FSR_8G << 3;
;;;1366           break;
;;;1367       case 16:
;;;1368           data = INV_FSR_16G << 3;
;;;1369           break;
;;;1370       default:
;;;1371           return -1;
;;;1372       }
;;;1373   
;;;1374       if (st.chip_cfg.accel_fsr == (data >> 3))
;;;1375           return 0;
;;;1376       if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
;;;1377           return -1;
;;;1378       st.chip_cfg.accel_fsr = data >> 3;
;;;1379       return 0;
;;;1380   }
00085a  bd38              POP      {r3-r5,pc}
                  |L1.2140|
00085c  2c02              CMP      r4,#2                 ;1357
00085e  d006              BEQ      |L1.2158|
000860  2c04              CMP      r4,#4                 ;1357
000862  d007              BEQ      |L1.2164|
000864  2c08              CMP      r4,#8                 ;1357
000866  d008              BEQ      |L1.2170|
000868  2c10              CMP      r4,#0x10              ;1357
00086a  d10c              BNE      |L1.2182|
00086c  e008              B        |L1.2176|
                  |L1.2158|
00086e  2000              MOVS     r0,#0                 ;1359
000870  9000              STR      r0,[sp,#0]            ;1359
000872  e00b              B        |L1.2188|
                  |L1.2164|
000874  2008              MOVS     r0,#8                 ;1362
000876  9000              STR      r0,[sp,#0]            ;1362
000878  e008              B        |L1.2188|
                  |L1.2170|
00087a  2010              MOVS     r0,#0x10              ;1365
00087c  9000              STR      r0,[sp,#0]            ;1365
00087e  e005              B        |L1.2188|
                  |L1.2176|
000880  2018              MOVS     r0,#0x18              ;1368
000882  9000              STR      r0,[sp,#0]            ;1368
000884  e002              B        |L1.2188|
                  |L1.2182|
000886  f04f30ff          MOV      r0,#0xffffffff        ;1371
00088a  e7e6              B        |L1.2138|
                  |L1.2188|
00088c  bf00              NOP                            ;1360
00088e  48db              LDR      r0,|L1.3068|
000890  7a40              LDRB     r0,[r0,#9]            ;1374
000892  f89d1000          LDRB     r1,[sp,#0]            ;1374
000896  ebb00fe1          CMP      r0,r1,ASR #3          ;1374
00089a  d101              BNE      |L1.2208|
00089c  2000              MOVS     r0,#0                 ;1375
00089e  e7dc              B        |L1.2138|
                  |L1.2208|
0008a0  4ad6              LDR      r2,|L1.3068|
0008a2  6812              LDR      r2,[r2,#0]            ;1376  ; st
0008a4  79d1              LDRB     r1,[r2,#7]            ;1376
0008a6  4ad5              LDR      r2,|L1.3068|
0008a8  6852              LDR      r2,[r2,#4]            ;1376  ; st
0008aa  7810              LDRB     r0,[r2,#0]            ;1376
0008ac  466b              MOV      r3,sp                 ;1376
0008ae  2201              MOVS     r2,#1                 ;1376
0008b0  f7fffffe          BL       I2C_Write
0008b4  b110              CBZ      r0,|L1.2236|
0008b6  f04f30ff          MOV      r0,#0xffffffff        ;1377
0008ba  e7ce              B        |L1.2138|
                  |L1.2236|
0008bc  f89d0000          LDRB     r0,[sp,#0]            ;1378
0008c0  10c1              ASRS     r1,r0,#3              ;1378
0008c2  48ce              LDR      r0,|L1.3068|
0008c4  7241              STRB     r1,[r0,#9]            ;1378
0008c6  2000              MOVS     r0,#0                 ;1379
0008c8  e7c7              B        |L1.2138|
;;;1381   
                          ENDP

                  mpu_set_gyro_fsr PROC
;;;1284    */
;;;1285   int mpu_set_gyro_fsr(unsigned short fsr)
0008ca  b538              PUSH     {r3-r5,lr}
;;;1286   {
0008cc  4604              MOV      r4,r0
;;;1287       unsigned char data;
;;;1288   
;;;1289       if (!(st.chip_cfg.sensors))
0008ce  48cb              LDR      r0,|L1.3068|
0008d0  7a80              LDRB     r0,[r0,#0xa]
0008d2  b910              CBNZ     r0,|L1.2266|
;;;1290           return -1;
0008d4  f04f30ff          MOV      r0,#0xffffffff
                  |L1.2264|
;;;1291   
;;;1292       switch (fsr) {
;;;1293       case 250:
;;;1294           data = INV_FSR_250DPS << 3;
;;;1295           break;
;;;1296       case 500:
;;;1297           data = INV_FSR_500DPS << 3;
;;;1298           break;
;;;1299       case 1000:
;;;1300           data = INV_FSR_1000DPS << 3;
;;;1301           break;
;;;1302       case 2000:
;;;1303           data = INV_FSR_2000DPS << 3;
;;;1304           break;
;;;1305       default:
;;;1306           return -1;
;;;1307       }
;;;1308   
;;;1309       if (st.chip_cfg.gyro_fsr == (data >> 3))
;;;1310           return 0;
;;;1311       if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
;;;1312           return -1;
;;;1313       st.chip_cfg.gyro_fsr = data >> 3;
;;;1314       return 0;
;;;1315   }
0008d8  bd38              POP      {r3-r5,pc}
                  |L1.2266|
0008da  2cfa              CMP      r4,#0xfa              ;1292
0008dc  d009              BEQ      |L1.2290|
0008de  f5b47ffa          CMP      r4,#0x1f4             ;1292
0008e2  d009              BEQ      |L1.2296|
0008e4  f5b47f7a          CMP      r4,#0x3e8             ;1292
0008e8  d009              BEQ      |L1.2302|
0008ea  f5b46ffa          CMP      r4,#0x7d0             ;1292
0008ee  d10c              BNE      |L1.2314|
0008f0  e008              B        |L1.2308|
                  |L1.2290|
0008f2  2000              MOVS     r0,#0                 ;1294
0008f4  9000              STR      r0,[sp,#0]            ;1294
0008f6  e00b              B        |L1.2320|
                  |L1.2296|
0008f8  2008              MOVS     r0,#8                 ;1297
0008fa  9000              STR      r0,[sp,#0]            ;1297
0008fc  e008              B        |L1.2320|
                  |L1.2302|
0008fe  2010              MOVS     r0,#0x10              ;1300
000900  9000              STR      r0,[sp,#0]            ;1300
000902  e005              B        |L1.2320|
                  |L1.2308|
000904  2018              MOVS     r0,#0x18              ;1303
000906  9000              STR      r0,[sp,#0]            ;1303
000908  e002              B        |L1.2320|
                  |L1.2314|
00090a  f04f30ff          MOV      r0,#0xffffffff        ;1306
00090e  e7e3              B        |L1.2264|
                  |L1.2320|
000910  bf00              NOP                            ;1295
000912  48ba              LDR      r0,|L1.3068|
000914  7a00              LDRB     r0,[r0,#8]            ;1309  ; st
000916  f89d1000          LDRB     r1,[sp,#0]            ;1309
00091a  ebb00fe1          CMP      r0,r1,ASR #3          ;1309
00091e  d101              BNE      |L1.2340|
000920  2000              MOVS     r0,#0                 ;1310
000922  e7d9              B        |L1.2264|
                  |L1.2340|
000924  4ab5              LDR      r2,|L1.3068|
000926  6812              LDR      r2,[r2,#0]            ;1311  ; st
000928  7991              LDRB     r1,[r2,#6]            ;1311
00092a  4ab4              LDR      r2,|L1.3068|
00092c  6852              LDR      r2,[r2,#4]            ;1311  ; st
00092e  7810              LDRB     r0,[r2,#0]            ;1311
000930  466b              MOV      r3,sp                 ;1311
000932  2201              MOVS     r2,#1                 ;1311
000934  f7fffffe          BL       I2C_Write
000938  b110              CBZ      r0,|L1.2368|
00093a  f04f30ff          MOV      r0,#0xffffffff        ;1312
00093e  e7cb              B        |L1.2264|
                  |L1.2368|
000940  f89d0000          LDRB     r0,[sp,#0]            ;1313
000944  10c0              ASRS     r0,r0,#3              ;1313
000946  49ad              LDR      r1,|L1.3068|
000948  7208              STRB     r0,[r1,#8]            ;1313
00094a  2000              MOVS     r0,#0                 ;1314
00094c  e7c4              B        |L1.2264|
;;;1316   
                          ENDP

                  gyro_self_test PROC
;;;2048   
;;;2049   static int gyro_self_test(long *bias_regular, long *bias_st)
00094e  e92d5ffc          PUSH     {r2-r12,lr}
;;;2050   {
000952  4606              MOV      r6,r0
000954  460f              MOV      r7,r1
;;;2051       int jj, result = 0;
000956  2500              MOVS     r5,#0
;;;2052       unsigned char tmp[3];
;;;2053       float st_shift, st_shift_cust, st_shift_var;
;;;2054   
;;;2055       if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
000958  49a8              LDR      r1,|L1.3068|
00095a  6849              LDR      r1,[r1,#4]  ; st
00095c  7808              LDRB     r0,[r1,#0]
00095e  ab01              ADD      r3,sp,#4
000960  2203              MOVS     r2,#3
000962  210d              MOVS     r1,#0xd
000964  f7fffffe          BL       I2C_Read
000968  b110              CBZ      r0,|L1.2416|
;;;2056           return 0x07;
00096a  2007              MOVS     r0,#7
                  |L1.2412|
;;;2057   
;;;2058       tmp[0] &= 0x1F;
;;;2059       tmp[1] &= 0x1F;
;;;2060       tmp[2] &= 0x1F;
;;;2061   
;;;2062       for (jj = 0; jj < 3; jj++) {
;;;2063           st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
;;;2064           if (tmp[jj]) {
;;;2065               st_shift = 3275.f / test.gyro_sens;
;;;2066               while (--tmp[jj])
;;;2067                   st_shift *= 1.046f;
;;;2068               st_shift_var = st_shift_cust / st_shift - 1.f;
;;;2069               if (fabs(st_shift_var) > test.max_gyro_var)
;;;2070                   result |= 1 << jj;
;;;2071           } else if ((st_shift_cust < test.min_dps) ||
;;;2072               (st_shift_cust > test.max_dps))
;;;2073               result |= 1 << jj;
;;;2074       }
;;;2075       return result;
;;;2076   }
00096c  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.2416|
000970  f89d0004          LDRB     r0,[sp,#4]            ;2058
000974  f000001f          AND      r0,r0,#0x1f           ;2058
000978  f88d0004          STRB     r0,[sp,#4]            ;2058
00097c  f89d0005          LDRB     r0,[sp,#5]            ;2059
000980  f000001f          AND      r0,r0,#0x1f           ;2059
000984  f88d0005          STRB     r0,[sp,#5]            ;2059
000988  f89d0006          LDRB     r0,[sp,#6]            ;2060
00098c  f000001f          AND      r0,r0,#0x1f           ;2060
000990  f88d0006          STRB     r0,[sp,#6]            ;2060
000994  2400              MOVS     r4,#0                 ;2062
000996  e056              B        |L1.2630|
                  |L1.2456|
000998  f8560024          LDR      r0,[r6,r4,LSL #2]     ;2063
00099c  f8571024          LDR      r1,[r7,r4,LSL #2]     ;2063
0009a0  eba00b01          SUB      r11,r0,r1             ;2063
0009a4  f1bb0f00          CMP      r11,#0                ;2063
0009a8  db01              BLT      |L1.2478|
0009aa  4659              MOV      r1,r11                ;2063
0009ac  e001              B        |L1.2482|
                  |L1.2478|
0009ae  f1cb0100          RSB      r1,r11,#0             ;2063
                  |L1.2482|
0009b2  4608              MOV      r0,r1                 ;2063
0009b4  f7fffffe          BL       __aeabi_i2f
0009b8  f04f418f          MOV      r1,#0x47800000        ;2063
0009bc  9000              STR      r0,[sp,#0]            ;2063
0009be  f7fffffe          BL       __aeabi_fdiv
0009c2  4681              MOV      r9,r0                 ;2063
0009c4  a801              ADD      r0,sp,#4              ;2064
0009c6  5d00              LDRB     r0,[r0,r4]            ;2064
0009c8  b368              CBZ      r0,|L1.2598|
0009ca  498d              LDR      r1,|L1.3072|
0009cc  6808              LDR      r0,[r1,#0]            ;2065  ; test
0009ce  f7fffffe          BL       __aeabi_ui2f
0009d2  4683              MOV      r11,r0                ;2065
0009d4  4659              MOV      r1,r11                ;2065
0009d6  488b              LDR      r0,|L1.3076|
0009d8  f7fffffe          BL       __aeabi_fdiv
0009dc  4680              MOV      r8,r0                 ;2065
0009de  e004              B        |L1.2538|
                  |L1.2528|
0009e0  4989              LDR      r1,|L1.3080|
0009e2  4640              MOV      r0,r8                 ;2067
0009e4  f7fffffe          BL       __aeabi_fmul
0009e8  4680              MOV      r8,r0                 ;2067
                  |L1.2538|
0009ea  a801              ADD      r0,sp,#4              ;2066
0009ec  5d00              LDRB     r0,[r0,r4]            ;2066
0009ee  1e40              SUBS     r0,r0,#1              ;2066
0009f0  b2c0              UXTB     r0,r0                 ;2066
0009f2  a901              ADD      r1,sp,#4              ;2066
0009f4  5508              STRB     r0,[r1,r4]            ;2066
0009f6  2800              CMP      r0,#0                 ;2066
0009f8  d1f2              BNE      |L1.2528|
0009fa  4641              MOV      r1,r8                 ;2068
0009fc  4648              MOV      r0,r9                 ;2068
0009fe  f7fffffe          BL       __aeabi_fdiv
000a02  4683              MOV      r11,r0                ;2068
000a04  f04f517e          MOV      r1,#0x3f800000        ;2068
000a08  f7fffffe          BL       __aeabi_fsub
000a0c  4682              MOV      r10,r0                ;2068
000a0e  f02a4b00          BIC      r11,r10,#0x80000000   ;2069
000a12  487b              LDR      r0,|L1.3072|
000a14  6981              LDR      r1,[r0,#0x18]         ;2069  ; test
000a16  4658              MOV      r0,r11                ;2069
000a18  f7fffffe          BL       __aeabi_cfrcmple
000a1c  d212              BCS      |L1.2628|
000a1e  2001              MOVS     r0,#1                 ;2070
000a20  40a0              LSLS     r0,r0,r4              ;2070
000a22  4305              ORRS     r5,r5,r0              ;2070
000a24  e00e              B        |L1.2628|
                  |L1.2598|
000a26  4876              LDR      r0,|L1.3072|
000a28  6901              LDR      r1,[r0,#0x10]         ;2071  ; test
000a2a  4648              MOV      r0,r9                 ;2071
000a2c  f7fffffe          BL       __aeabi_cfcmple
000a30  d305              BCC      |L1.2622|
000a32  4873              LDR      r0,|L1.3072|
000a34  6941              LDR      r1,[r0,#0x14]         ;2072  ; test
000a36  4648              MOV      r0,r9                 ;2072
000a38  f7fffffe          BL       __aeabi_cfrcmple
000a3c  d202              BCS      |L1.2628|
                  |L1.2622|
000a3e  2001              MOVS     r0,#1                 ;2073
000a40  40a0              LSLS     r0,r0,r4              ;2073
000a42  4305              ORRS     r5,r5,r0              ;2073
                  |L1.2628|
000a44  1c64              ADDS     r4,r4,#1              ;2062
                  |L1.2630|
000a46  2c03              CMP      r4,#3                 ;2062
000a48  dba6              BLT      |L1.2456|
000a4a  4628              MOV      r0,r5                 ;2075
000a4c  e78e              B        |L1.2412|
;;;2077   
                          ENDP

                  get_accel_prod_shift PROC
;;;2003   #ifdef MPU6050
;;;2004   static int get_accel_prod_shift(float *st_shift)
000a4e  b57c              PUSH     {r2-r6,lr}
;;;2005   {
000a50  4605              MOV      r5,r0
;;;2006       unsigned char tmp[4], shift_code[3], ii;
;;;2007   
;;;2008       if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
000a52  496a              LDR      r1,|L1.3068|
000a54  6849              LDR      r1,[r1,#4]  ; st
000a56  7808              LDRB     r0,[r1,#0]
000a58  ab01              ADD      r3,sp,#4
000a5a  2204              MOVS     r2,#4
000a5c  210d              MOVS     r1,#0xd
000a5e  f7fffffe          BL       I2C_Read
000a62  b108              CBZ      r0,|L1.2664|
;;;2009           return 0x07;
000a64  2007              MOVS     r0,#7
                  |L1.2662|
;;;2010   
;;;2011       shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
;;;2012       shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
;;;2013       shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
;;;2014       for (ii = 0; ii < 3; ii++) {
;;;2015           if (!shift_code[ii]) {
;;;2016               st_shift[ii] = 0.f;
;;;2017               continue;
;;;2018           }
;;;2019           /* Equivalent to..
;;;2020            * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
;;;2021            */
;;;2022           st_shift[ii] = 0.34f;
;;;2023           while (--shift_code[ii])
;;;2024               st_shift[ii] *= 1.034f;
;;;2025       }
;;;2026       return 0;
;;;2027   }
000a66  bd7c              POP      {r2-r6,pc}
                  |L1.2664|
000a68  f89d0007          LDRB     r0,[sp,#7]            ;2011
000a6c  f3c01001          UBFX     r0,r0,#4,#2           ;2011
000a70  f89d1004          LDRB     r1,[sp,#4]            ;2011
000a74  f00101e0          AND      r1,r1,#0xe0           ;2011
000a78  ea4000e1          ORR      r0,r0,r1,ASR #3       ;2011
000a7c  f88d0000          STRB     r0,[sp,#0]            ;2011
000a80  f89d0007          LDRB     r0,[sp,#7]            ;2012
000a84  f3c00081          UBFX     r0,r0,#2,#2           ;2012
000a88  f89d1005          LDRB     r1,[sp,#5]            ;2012
000a8c  f00101e0          AND      r1,r1,#0xe0           ;2012
000a90  ea4000e1          ORR      r0,r0,r1,ASR #3       ;2012
000a94  f88d0001          STRB     r0,[sp,#1]            ;2012
000a98  f89d0007          LDRB     r0,[sp,#7]            ;2013
000a9c  f0000003          AND      r0,r0,#3              ;2013
000aa0  f89d1006          LDRB     r1,[sp,#6]            ;2013
000aa4  f00101e0          AND      r1,r1,#0xe0           ;2013
000aa8  ea4000e1          ORR      r0,r0,r1,ASR #3       ;2013
000aac  f88d0002          STRB     r0,[sp,#2]            ;2013
000ab0  2400              MOVS     r4,#0                 ;2014
000ab2  e01c              B        |L1.2798|
                  |L1.2740|
000ab4  f81d0004          LDRB     r0,[sp,r4]            ;2015
000ab8  b918              CBNZ     r0,|L1.2754|
000aba  2000              MOVS     r0,#0                 ;2016
000abc  f8450024          STR      r0,[r5,r4,LSL #2]     ;2016
000ac0  e013              B        |L1.2794|
                  |L1.2754|
000ac2  4852              LDR      r0,|L1.3084|
000ac4  f8450024          STR      r0,[r5,r4,LSL #2]     ;2022
000ac8  e006              B        |L1.2776|
                  |L1.2762|
000aca  f8550024          LDR      r0,[r5,r4,LSL #2]     ;2024
000ace  4950              LDR      r1,|L1.3088|
000ad0  f7fffffe          BL       __aeabi_fmul
000ad4  f8450024          STR      r0,[r5,r4,LSL #2]     ;2024
                  |L1.2776|
000ad8  f81d0004          LDRB     r0,[sp,r4]            ;2023
000adc  1e40              SUBS     r0,r0,#1              ;2023
000ade  b2c0              UXTB     r0,r0                 ;2023
000ae0  f80d0004          STRB     r0,[sp,r4]            ;2023
000ae4  2800              CMP      r0,#0                 ;2023
000ae6  d1f0              BNE      |L1.2762|
000ae8  bf00              NOP                            ;2017
                  |L1.2794|
000aea  1c60              ADDS     r0,r4,#1              ;2014
000aec  b2c4              UXTB     r4,r0                 ;2014
                  |L1.2798|
000aee  2c03              CMP      r4,#3                 ;2014
000af0  dbe0              BLT      |L1.2740|
000af2  2000              MOVS     r0,#0                 ;2026
000af4  e7b7              B        |L1.2662|
;;;2028   
                          ENDP

                  accel_self_test PROC
;;;2029   static int accel_self_test(long *bias_regular, long *bias_st)
000af6  e92d4ffe          PUSH     {r1-r11,lr}
;;;2030   {
000afa  4606              MOV      r6,r0
000afc  460f              MOV      r7,r1
;;;2031       int jj, result = 0;
000afe  2500              MOVS     r5,#0
;;;2032       float st_shift[3], st_shift_cust, st_shift_var;
;;;2033   
;;;2034       get_accel_prod_shift(st_shift);
000b00  4668              MOV      r0,sp
000b02  f7fffffe          BL       get_accel_prod_shift
;;;2035       for(jj = 0; jj < 3; jj++) {
000b06  2400              MOVS     r4,#0
000b08  e042              B        |L1.2960|
                  |L1.2826|
;;;2036           st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
000b0a  f8560024          LDR      r0,[r6,r4,LSL #2]
000b0e  f8571024          LDR      r1,[r7,r4,LSL #2]
000b12  eba00a01          SUB      r10,r0,r1
000b16  f1ba0f00          CMP      r10,#0
000b1a  db01              BLT      |L1.2848|
000b1c  4651              MOV      r1,r10
000b1e  e001              B        |L1.2852|
                  |L1.2848|
000b20  f1ca0100          RSB      r1,r10,#0
                  |L1.2852|
000b24  4608              MOV      r0,r1
000b26  f7fffffe          BL       __aeabi_i2f
000b2a  4683              MOV      r11,r0
000b2c  f04f418f          MOV      r1,#0x47800000
000b30  f7fffffe          BL       __aeabi_fdiv
000b34  4680              MOV      r8,r0
;;;2037           if (st_shift[jj]) {
000b36  f85d0024          LDR      r0,[sp,r4,LSL #2]
000b3a  2100              MOVS     r1,#0
000b3c  f7fffffe          BL       __aeabi_cfcmpeq
000b40  d016              BEQ      |L1.2928|
;;;2038               st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
000b42  f85d1024          LDR      r1,[sp,r4,LSL #2]
000b46  4640              MOV      r0,r8
000b48  f7fffffe          BL       __aeabi_fdiv
000b4c  4682              MOV      r10,r0
000b4e  f04f517e          MOV      r1,#0x3f800000
000b52  f7fffffe          BL       __aeabi_fsub
000b56  4681              MOV      r9,r0
;;;2039               if (fabs(st_shift_var) > test.max_accel_var)
000b58  f0294a00          BIC      r10,r9,#0x80000000
000b5c  4828              LDR      r0,|L1.3072|
000b5e  6a41              LDR      r1,[r0,#0x24]  ; test
000b60  4650              MOV      r0,r10
000b62  f7fffffe          BL       __aeabi_cfrcmple
000b66  d212              BCS      |L1.2958|
;;;2040                   result |= 1 << jj;
000b68  2001              MOVS     r0,#1
000b6a  40a0              LSLS     r0,r0,r4
000b6c  4305              ORRS     r5,r5,r0
000b6e  e00e              B        |L1.2958|
                  |L1.2928|
;;;2041           } else if ((st_shift_cust < test.min_g) ||
000b70  4823              LDR      r0,|L1.3072|
000b72  69c1              LDR      r1,[r0,#0x1c]  ; test
000b74  4640              MOV      r0,r8
000b76  f7fffffe          BL       __aeabi_cfcmple
000b7a  d305              BCC      |L1.2952|
;;;2042               (st_shift_cust > test.max_g))
000b7c  4820              LDR      r0,|L1.3072|
000b7e  6a01              LDR      r1,[r0,#0x20]  ; test
000b80  4640              MOV      r0,r8
000b82  f7fffffe          BL       __aeabi_cfrcmple
000b86  d202              BCS      |L1.2958|
                  |L1.2952|
;;;2043               result |= 1 << jj;
000b88  2001              MOVS     r0,#1
000b8a  40a0              LSLS     r0,r0,r4
000b8c  4305              ORRS     r5,r5,r0
                  |L1.2958|
000b8e  1c64              ADDS     r4,r4,#1              ;2035
                  |L1.2960|
000b90  2c03              CMP      r4,#3                 ;2035
000b92  dbba              BLT      |L1.2826|
;;;2044       }
;;;2045   
;;;2046       return result;
000b94  4628              MOV      r0,r5
;;;2047   }
000b96  e8bd8ffe          POP      {r1-r11,pc}
;;;2048   
                          ENDP

                  get_st_biases PROC
;;;2132   
;;;2133   static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
000b9a  e92d4ff0          PUSH     {r4-r11,lr}
;;;2134   {
000b9e  b087              SUB      sp,sp,#0x1c
000ba0  4605              MOV      r5,r0
000ba2  460c              MOV      r4,r1
000ba4  4691              MOV      r9,r2
;;;2135       unsigned char data[MAX_PACKET_LENGTH];
;;;2136       unsigned char packet_count, ii;
;;;2137       unsigned short fifo_count;
;;;2138   
;;;2139       data[0] = 0x01;
000ba6  2001              MOVS     r0,#1
000ba8  f88d0010          STRB     r0,[sp,#0x10]
;;;2140       data[1] = 0;
000bac  2000              MOVS     r0,#0
000bae  f88d0011          STRB     r0,[sp,#0x11]
;;;2141       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
000bb2  4a12              LDR      r2,|L1.3068|
000bb4  6812              LDR      r2,[r2,#0]  ; st
000bb6  7c91              LDRB     r1,[r2,#0x12]
000bb8  4a10              LDR      r2,|L1.3068|
000bba  6852              LDR      r2,[r2,#4]  ; st
000bbc  7810              LDRB     r0,[r2,#0]
000bbe  ab04              ADD      r3,sp,#0x10
000bc0  2202              MOVS     r2,#2
000bc2  f7fffffe          BL       I2C_Write
000bc6  b120              CBZ      r0,|L1.3026|
;;;2142           return -1;
000bc8  f04f30ff          MOV      r0,#0xffffffff
                  |L1.3020|
;;;2143       delay_ms(200);
;;;2144       data[0] = 0;
;;;2145       if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
;;;2146           return -1;
;;;2147       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
;;;2148           return -1;
;;;2149       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
;;;2150           return -1;
;;;2151       if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
;;;2152           return -1;
;;;2153       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
;;;2154           return -1;
;;;2155       data[0] = BIT_FIFO_RST | BIT_DMP_RST;
;;;2156       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
;;;2157           return -1;
;;;2158       delay_ms(15);
;;;2159       data[0] = st.test->reg_lpf;
;;;2160       if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
;;;2161           return -1;
;;;2162       data[0] = st.test->reg_rate_div;
;;;2163       if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
;;;2164           return -1;
;;;2165       if (hw_test)
;;;2166           data[0] = st.test->reg_gyro_fsr | 0xE0;
;;;2167       else
;;;2168           data[0] = st.test->reg_gyro_fsr;
;;;2169       if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
;;;2170           return -1;
;;;2171   
;;;2172       if (hw_test)
;;;2173           data[0] = st.test->reg_accel_fsr | 0xE0;
;;;2174       else
;;;2175           data[0] = test.reg_accel_fsr;
;;;2176       if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
;;;2177           return -1;
;;;2178       if (hw_test)
;;;2179           delay_ms(200);
;;;2180   
;;;2181       /* Fill FIFO for test.wait_ms milliseconds. */
;;;2182       data[0] = BIT_FIFO_EN;
;;;2183       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
;;;2184           return -1;
;;;2185   
;;;2186       data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
;;;2187       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
;;;2188           return -1;
;;;2189       delay_ms(test.wait_ms);
;;;2190       data[0] = 0;
;;;2191       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
;;;2192           return -1;
;;;2193   
;;;2194       if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
;;;2195           return -1;
;;;2196   
;;;2197       fifo_count = (data[0] << 8) | data[1];
;;;2198       packet_count = fifo_count / MAX_PACKET_LENGTH;
;;;2199       gyro[0] = gyro[1] = gyro[2] = 0;
;;;2200       accel[0] = accel[1] = accel[2] = 0;
;;;2201   
;;;2202       for (ii = 0; ii < packet_count; ii++) {
;;;2203           short accel_cur[3], gyro_cur[3];
;;;2204           if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
;;;2205               return -1;
;;;2206           accel_cur[0] = ((short)data[0] << 8) | data[1];
;;;2207           accel_cur[1] = ((short)data[2] << 8) | data[3];
;;;2208           accel_cur[2] = ((short)data[4] << 8) | data[5];
;;;2209           accel[0] += (long)accel_cur[0];
;;;2210           accel[1] += (long)accel_cur[1];
;;;2211           accel[2] += (long)accel_cur[2];
;;;2212           gyro_cur[0] = (((short)data[6] << 8) | data[7]);
;;;2213           gyro_cur[1] = (((short)data[8] << 8) | data[9]);
;;;2214           gyro_cur[2] = (((short)data[10] << 8) | data[11]);
;;;2215           gyro[0] += (long)gyro_cur[0];
;;;2216           gyro[1] += (long)gyro_cur[1];
;;;2217           gyro[2] += (long)gyro_cur[2];
;;;2218       }
;;;2219   #ifdef EMPL_NO_64BIT
;;;2220       gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
;;;2221       gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
;;;2222       gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
;;;2223       if (has_accel) {
;;;2224           accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
;;;2225               packet_count);
;;;2226           accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
;;;2227               packet_count);
;;;2228           accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
;;;2229               packet_count);
;;;2230           /* Don't remove gravity! */
;;;2231           accel[2] -= 65536L;
;;;2232       }
;;;2233   #else
;;;2234       gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
;;;2235       gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
;;;2236       gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
;;;2237       accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
;;;2238           packet_count);
;;;2239       accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
;;;2240           packet_count);
;;;2241       accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
;;;2242           packet_count);
;;;2243       /* Don't remove gravity! */
;;;2244       if (accel[2] > 0L)
;;;2245           accel[2] -= 65536L;
;;;2246       else
;;;2247           accel[2] += 65536L;
;;;2248   #endif
;;;2249   
;;;2250       return 0;
;;;2251   }
000bcc  b007              ADD      sp,sp,#0x1c
000bce  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.3026|
000bd2  20c8              MOVS     r0,#0xc8              ;2143
000bd4  f7fffffe          BL       delay_ms
000bd8  2000              MOVS     r0,#0                 ;2144
000bda  f88d0010          STRB     r0,[sp,#0x10]         ;2144
000bde  4a07              LDR      r2,|L1.3068|
000be0  6812              LDR      r2,[r2,#0]            ;2145  ; st
000be2  7bd1              LDRB     r1,[r2,#0xf]          ;2145
000be4  4a05              LDR      r2,|L1.3068|
000be6  6852              LDR      r2,[r2,#4]            ;2145  ; st
000be8  7810              LDRB     r0,[r2,#0]            ;2145
000bea  ab04              ADD      r3,sp,#0x10           ;2145
000bec  2201              MOVS     r2,#1                 ;2145
000bee  f7fffffe          BL       I2C_Write
000bf2  b178              CBZ      r0,|L1.3092|
000bf4  f04f30ff          MOV      r0,#0xffffffff        ;2146
000bf8  e7e8              B        |L1.3020|
000bfa  0000              DCW      0x0000
                  |L1.3068|
                          DCD      ||st||
                  |L1.3072|
                          DCD      test
                  |L1.3076|
                          DCD      0x454cb000
                  |L1.3080|
                          DCD      0x3f85e354
                  |L1.3084|
                          DCD      0x3eae147b
                  |L1.3088|
                          DCD      0x3f845a1d
                  |L1.3092|
000c14  4afc              LDR      r2,|L1.4104|
000c16  6812              LDR      r2,[r2,#0]            ;2147  ; st
000c18  7951              LDRB     r1,[r2,#5]            ;2147
000c1a  4afb              LDR      r2,|L1.4104|
000c1c  6852              LDR      r2,[r2,#4]            ;2147  ; st
000c1e  7810              LDRB     r0,[r2,#0]            ;2147
000c20  ab04              ADD      r3,sp,#0x10           ;2147
000c22  2201              MOVS     r2,#1                 ;2147
000c24  f7fffffe          BL       I2C_Write
000c28  b110              CBZ      r0,|L1.3120|
000c2a  f04f30ff          MOV      r0,#0xffffffff        ;2148
000c2e  e7cd              B        |L1.3020|
                  |L1.3120|
000c30  4af5              LDR      r2,|L1.4104|
000c32  6812              LDR      r2,[r2,#0]            ;2149  ; st
000c34  7c91              LDRB     r1,[r2,#0x12]         ;2149
000c36  4af4              LDR      r2,|L1.4104|
000c38  6852              LDR      r2,[r2,#4]            ;2149  ; st
000c3a  7810              LDRB     r0,[r2,#0]            ;2149
000c3c  ab04              ADD      r3,sp,#0x10           ;2149
000c3e  2201              MOVS     r2,#1                 ;2149
000c40  f7fffffe          BL       I2C_Write
000c44  b110              CBZ      r0,|L1.3148|
000c46  f04f30ff          MOV      r0,#0xffffffff        ;2150
000c4a  e7bf              B        |L1.3020|
                  |L1.3148|
000c4c  4aee              LDR      r2,|L1.4104|
000c4e  6812              LDR      r2,[r2,#0]            ;2151  ; st
000c50  7dd1              LDRB     r1,[r2,#0x17]         ;2151
000c52  4aed              LDR      r2,|L1.4104|
000c54  6852              LDR      r2,[r2,#4]            ;2151  ; st
000c56  7810              LDRB     r0,[r2,#0]            ;2151
000c58  ab04              ADD      r3,sp,#0x10           ;2151
000c5a  2201              MOVS     r2,#1                 ;2151
000c5c  f7fffffe          BL       I2C_Write
000c60  b110              CBZ      r0,|L1.3176|
000c62  f04f30ff          MOV      r0,#0xffffffff        ;2152
000c66  e7b1              B        |L1.3020|
                  |L1.3176|
000c68  4ae7              LDR      r2,|L1.4104|
000c6a  6812              LDR      r2,[r2,#0]            ;2153  ; st
000c6c  7911              LDRB     r1,[r2,#4]            ;2153
000c6e  4ae6              LDR      r2,|L1.4104|
000c70  6852              LDR      r2,[r2,#4]            ;2153  ; st
000c72  7810              LDRB     r0,[r2,#0]            ;2153
000c74  ab04              ADD      r3,sp,#0x10           ;2153
000c76  2201              MOVS     r2,#1                 ;2153
000c78  f7fffffe          BL       I2C_Write
000c7c  b110              CBZ      r0,|L1.3204|
000c7e  f04f30ff          MOV      r0,#0xffffffff        ;2154
000c82  e7a3              B        |L1.3020|
                  |L1.3204|
000c84  200c              MOVS     r0,#0xc               ;2155
000c86  f88d0010          STRB     r0,[sp,#0x10]         ;2155
000c8a  4adf              LDR      r2,|L1.4104|
000c8c  6812              LDR      r2,[r2,#0]            ;2156  ; st
000c8e  7911              LDRB     r1,[r2,#4]            ;2156
000c90  4add              LDR      r2,|L1.4104|
000c92  6852              LDR      r2,[r2,#4]            ;2156  ; st
000c94  7810              LDRB     r0,[r2,#0]            ;2156
000c96  ab04              ADD      r3,sp,#0x10           ;2156
000c98  2201              MOVS     r2,#1                 ;2156
000c9a  f7fffffe          BL       I2C_Write
000c9e  b110              CBZ      r0,|L1.3238|
000ca0  f04f30ff          MOV      r0,#0xffffffff        ;2157
000ca4  e792              B        |L1.3020|
                  |L1.3238|
000ca6  200f              MOVS     r0,#0xf               ;2158
000ca8  f7fffffe          BL       delay_ms
000cac  48d6              LDR      r0,|L1.4104|
000cae  6a80              LDR      r0,[r0,#0x28]         ;2159  ; st
000cb0  7a40              LDRB     r0,[r0,#9]            ;2159
000cb2  f88d0010          STRB     r0,[sp,#0x10]         ;2159
000cb6  4ad4              LDR      r2,|L1.4104|
000cb8  6812              LDR      r2,[r2,#0]            ;2160  ; st
000cba  7891              LDRB     r1,[r2,#2]            ;2160
000cbc  4ad2              LDR      r2,|L1.4104|
000cbe  6852              LDR      r2,[r2,#4]            ;2160  ; st
000cc0  7810              LDRB     r0,[r2,#0]            ;2160
000cc2  ab04              ADD      r3,sp,#0x10           ;2160
000cc4  2201              MOVS     r2,#1                 ;2160
000cc6  f7fffffe          BL       I2C_Write
000cca  b110              CBZ      r0,|L1.3282|
000ccc  f04f30ff          MOV      r0,#0xffffffff        ;2161
000cd0  e77c              B        |L1.3020|
                  |L1.3282|
000cd2  48cd              LDR      r0,|L1.4104|
000cd4  6a80              LDR      r0,[r0,#0x28]         ;2162  ; st
000cd6  7a00              LDRB     r0,[r0,#8]            ;2162
000cd8  f88d0010          STRB     r0,[sp,#0x10]         ;2162
000cdc  4aca              LDR      r2,|L1.4104|
000cde  6812              LDR      r2,[r2,#0]            ;2163  ; st
000ce0  7851              LDRB     r1,[r2,#1]            ;2163
000ce2  4ac9              LDR      r2,|L1.4104|
000ce4  6852              LDR      r2,[r2,#4]            ;2163  ; st
000ce6  7810              LDRB     r0,[r2,#0]            ;2163
000ce8  ab04              ADD      r3,sp,#0x10           ;2163
000cea  2201              MOVS     r2,#1                 ;2163
000cec  f7fffffe          BL       I2C_Write
000cf0  b110              CBZ      r0,|L1.3320|
000cf2  f04f30ff          MOV      r0,#0xffffffff        ;2164
000cf6  e769              B        |L1.3020|
                  |L1.3320|
000cf8  f1b90f00          CMP      r9,#0                 ;2165
000cfc  d007              BEQ      |L1.3342|
000cfe  48c2              LDR      r0,|L1.4104|
000d00  6a80              LDR      r0,[r0,#0x28]         ;2166  ; st
000d02  7a80              LDRB     r0,[r0,#0xa]          ;2166
000d04  f04000e0          ORR      r0,r0,#0xe0           ;2166
000d08  f88d0010          STRB     r0,[sp,#0x10]         ;2166
000d0c  e004              B        |L1.3352|
                  |L1.3342|
000d0e  48be              LDR      r0,|L1.4104|
000d10  6a80              LDR      r0,[r0,#0x28]         ;2168  ; st
000d12  7a80              LDRB     r0,[r0,#0xa]          ;2168
000d14  f88d0010          STRB     r0,[sp,#0x10]         ;2168
                  |L1.3352|
000d18  4abb              LDR      r2,|L1.4104|
000d1a  6812              LDR      r2,[r2,#0]            ;2169  ; st
000d1c  7991              LDRB     r1,[r2,#6]            ;2169
000d1e  4aba              LDR      r2,|L1.4104|
000d20  6852              LDR      r2,[r2,#4]            ;2169  ; st
000d22  7810              LDRB     r0,[r2,#0]            ;2169
000d24  ab04              ADD      r3,sp,#0x10           ;2169
000d26  2201              MOVS     r2,#1                 ;2169
000d28  f7fffffe          BL       I2C_Write
000d2c  b110              CBZ      r0,|L1.3380|
000d2e  f04f30ff          MOV      r0,#0xffffffff        ;2170
000d32  e74b              B        |L1.3020|
                  |L1.3380|
000d34  f1b90f00          CMP      r9,#0                 ;2172
000d38  d007              BEQ      |L1.3402|
000d3a  48b3              LDR      r0,|L1.4104|
000d3c  6a80              LDR      r0,[r0,#0x28]         ;2173  ; st
000d3e  7ac0              LDRB     r0,[r0,#0xb]          ;2173
000d40  f04000e0          ORR      r0,r0,#0xe0           ;2173
000d44  f88d0010          STRB     r0,[sp,#0x10]         ;2173
000d48  e003              B        |L1.3410|
                  |L1.3402|
000d4a  48b0              LDR      r0,|L1.4108|
000d4c  7ac0              LDRB     r0,[r0,#0xb]          ;2175  ; test
000d4e  f88d0010          STRB     r0,[sp,#0x10]         ;2175
                  |L1.3410|
000d52  4aad              LDR      r2,|L1.4104|
000d54  6812              LDR      r2,[r2,#0]            ;2176  ; st
000d56  79d1              LDRB     r1,[r2,#7]            ;2176
000d58  4aab              LDR      r2,|L1.4104|
000d5a  6852              LDR      r2,[r2,#4]            ;2176  ; st
000d5c  7810              LDRB     r0,[r2,#0]            ;2176
000d5e  ab04              ADD      r3,sp,#0x10           ;2176
000d60  2201              MOVS     r2,#1                 ;2176
000d62  f7fffffe          BL       I2C_Write
000d66  b110              CBZ      r0,|L1.3438|
000d68  f04f30ff          MOV      r0,#0xffffffff        ;2177
000d6c  e72e              B        |L1.3020|
                  |L1.3438|
000d6e  f1b90f00          CMP      r9,#0                 ;2178
000d72  d002              BEQ      |L1.3450|
000d74  20c8              MOVS     r0,#0xc8              ;2179
000d76  f7fffffe          BL       delay_ms
                  |L1.3450|
000d7a  2040              MOVS     r0,#0x40              ;2182
000d7c  f88d0010          STRB     r0,[sp,#0x10]         ;2182
000d80  4aa1              LDR      r2,|L1.4104|
000d82  6812              LDR      r2,[r2,#0]            ;2183  ; st
000d84  7911              LDRB     r1,[r2,#4]            ;2183
000d86  4aa0              LDR      r2,|L1.4104|
000d88  6852              LDR      r2,[r2,#4]            ;2183  ; st
000d8a  7810              LDRB     r0,[r2,#0]            ;2183
000d8c  ab04              ADD      r3,sp,#0x10           ;2183
000d8e  2201              MOVS     r2,#1                 ;2183
000d90  f7fffffe          BL       I2C_Write
000d94  b110              CBZ      r0,|L1.3484|
000d96  f04f30ff          MOV      r0,#0xffffffff        ;2184
000d9a  e717              B        |L1.3020|
                  |L1.3484|
000d9c  2078              MOVS     r0,#0x78              ;2186
000d9e  f88d0010          STRB     r0,[sp,#0x10]         ;2186
000da2  4a99              LDR      r2,|L1.4104|
000da4  6812              LDR      r2,[r2,#0]            ;2187  ; st
000da6  7951              LDRB     r1,[r2,#5]            ;2187
000da8  4a97              LDR      r2,|L1.4104|
000daa  6852              LDR      r2,[r2,#4]            ;2187  ; st
000dac  7810              LDRB     r0,[r2,#0]            ;2187
000dae  ab04              ADD      r3,sp,#0x10           ;2187
000db0  2201              MOVS     r2,#1                 ;2187
000db2  f7fffffe          BL       I2C_Write
000db6  b110              CBZ      r0,|L1.3518|
000db8  f04f30ff          MOV      r0,#0xffffffff        ;2188
000dbc  e706              B        |L1.3020|
                  |L1.3518|
000dbe  4993              LDR      r1,|L1.4108|
000dc0  8988              LDRH     r0,[r1,#0xc]          ;2189  ; test
000dc2  f7fffffe          BL       delay_ms
000dc6  2000              MOVS     r0,#0                 ;2190
000dc8  f88d0010          STRB     r0,[sp,#0x10]         ;2190
000dcc  4a8e              LDR      r2,|L1.4104|
000dce  6812              LDR      r2,[r2,#0]            ;2191  ; st
000dd0  7951              LDRB     r1,[r2,#5]            ;2191
000dd2  4a8d              LDR      r2,|L1.4104|
000dd4  6852              LDR      r2,[r2,#4]            ;2191  ; st
000dd6  7810              LDRB     r0,[r2,#0]            ;2191
000dd8  ab04              ADD      r3,sp,#0x10           ;2191
000dda  2201              MOVS     r2,#1                 ;2191
000ddc  f7fffffe          BL       I2C_Write
000de0  b110              CBZ      r0,|L1.3560|
000de2  f04f30ff          MOV      r0,#0xffffffff        ;2192
000de6  e6f1              B        |L1.3020|
                  |L1.3560|
000de8  4a87              LDR      r2,|L1.4104|
000dea  6812              LDR      r2,[r2,#0]            ;2194  ; st
000dec  7a91              LDRB     r1,[r2,#0xa]          ;2194
000dee  4a86              LDR      r2,|L1.4104|
000df0  6852              LDR      r2,[r2,#4]            ;2194  ; st
000df2  7810              LDRB     r0,[r2,#0]            ;2194
000df4  ab04              ADD      r3,sp,#0x10           ;2194
000df6  2202              MOVS     r2,#2                 ;2194
000df8  f7fffffe          BL       I2C_Read
000dfc  b110              CBZ      r0,|L1.3588|
000dfe  f04f30ff          MOV      r0,#0xffffffff        ;2195
000e02  e6e3              B        |L1.3020|
                  |L1.3588|
000e04  f89d0011          LDRB     r0,[sp,#0x11]         ;2197
000e08  f89d1010          LDRB     r1,[sp,#0x10]         ;2197
000e0c  ea402b01          ORR      r11,r0,r1,LSL #8      ;2197
000e10  200c              MOVS     r0,#0xc               ;2198
000e12  fb9bf0f0          SDIV     r0,r11,r0             ;2198
000e16  b2c6              UXTB     r6,r0                 ;2198
000e18  2000              MOVS     r0,#0                 ;2199
000e1a  60a8              STR      r0,[r5,#8]            ;2199
000e1c  6068              STR      r0,[r5,#4]            ;2199
000e1e  6028              STR      r0,[r5,#0]            ;2199
000e20  60a0              STR      r0,[r4,#8]            ;2200
000e22  6060              STR      r0,[r4,#4]            ;2200
000e24  6020              STR      r0,[r4,#0]            ;2200
000e26  4682              MOV      r10,r0                ;2202
000e28  e065              B        |L1.3830|
                  |L1.3626|
000e2a  4a77              LDR      r2,|L1.4104|
000e2c  6812              LDR      r2,[r2,#0]            ;2204  ; st
000e2e  7ad1              LDRB     r1,[r2,#0xb]          ;2204
000e30  4a75              LDR      r2,|L1.4104|
000e32  6852              LDR      r2,[r2,#4]            ;2204  ; st
000e34  7810              LDRB     r0,[r2,#0]            ;2204
000e36  ab04              ADD      r3,sp,#0x10           ;2204
000e38  220c              MOVS     r2,#0xc               ;2204
000e3a  f7fffffe          BL       I2C_Read
000e3e  b110              CBZ      r0,|L1.3654|
000e40  f04f30ff          MOV      r0,#0xffffffff        ;2205
000e44  e6c2              B        |L1.3020|
                  |L1.3654|
000e46  f89d0011          LDRB     r0,[sp,#0x11]         ;2206
000e4a  f89d1010          LDRB     r1,[sp,#0x10]         ;2206
000e4e  ea402001          ORR      r0,r0,r1,LSL #8       ;2206
000e52  b200              SXTH     r0,r0                 ;2206
000e54  f8ad0008          STRH     r0,[sp,#8]            ;2206
000e58  f89d0013          LDRB     r0,[sp,#0x13]         ;2207
000e5c  f89d1012          LDRB     r1,[sp,#0x12]         ;2207
000e60  ea402001          ORR      r0,r0,r1,LSL #8       ;2207
000e64  b200              SXTH     r0,r0                 ;2207
000e66  f8ad000a          STRH     r0,[sp,#0xa]          ;2207
000e6a  f89d0015          LDRB     r0,[sp,#0x15]         ;2208
000e6e  f89d1014          LDRB     r1,[sp,#0x14]         ;2208
000e72  ea402001          ORR      r0,r0,r1,LSL #8       ;2208
000e76  b200              SXTH     r0,r0                 ;2208
000e78  f8ad000c          STRH     r0,[sp,#0xc]          ;2208
000e7c  f9bd1008          LDRSH    r1,[sp,#8]            ;2209
000e80  6820              LDR      r0,[r4,#0]            ;2209
000e82  4408              ADD      r0,r0,r1              ;2209
000e84  6020              STR      r0,[r4,#0]            ;2209
000e86  f9bd100a          LDRSH    r1,[sp,#0xa]          ;2210
000e8a  6860              LDR      r0,[r4,#4]            ;2210
000e8c  4408              ADD      r0,r0,r1              ;2210
000e8e  6060              STR      r0,[r4,#4]            ;2210
000e90  f9bd100c          LDRSH    r1,[sp,#0xc]          ;2211
000e94  68a0              LDR      r0,[r4,#8]            ;2211
000e96  4408              ADD      r0,r0,r1              ;2211
000e98  60a0              STR      r0,[r4,#8]            ;2211
000e9a  f89d0017          LDRB     r0,[sp,#0x17]         ;2212
000e9e  f89d1016          LDRB     r1,[sp,#0x16]         ;2212
000ea2  ea402001          ORR      r0,r0,r1,LSL #8       ;2212
000ea6  b200              SXTH     r0,r0                 ;2212
000ea8  f8ad0000          STRH     r0,[sp,#0]            ;2212
000eac  f89d0019          LDRB     r0,[sp,#0x19]         ;2213
000eb0  f89d1018          LDRB     r1,[sp,#0x18]         ;2213
000eb4  ea402001          ORR      r0,r0,r1,LSL #8       ;2213
000eb8  b200              SXTH     r0,r0                 ;2213
000eba  f8ad0002          STRH     r0,[sp,#2]            ;2213
000ebe  f89d001b          LDRB     r0,[sp,#0x1b]         ;2214
000ec2  f89d101a          LDRB     r1,[sp,#0x1a]         ;2214
000ec6  ea402001          ORR      r0,r0,r1,LSL #8       ;2214
000eca  b200              SXTH     r0,r0                 ;2214
000ecc  f8ad0004          STRH     r0,[sp,#4]            ;2214
000ed0  f9bd1000          LDRSH    r1,[sp,#0]            ;2215
000ed4  6828              LDR      r0,[r5,#0]            ;2215
000ed6  4408              ADD      r0,r0,r1              ;2215
000ed8  6028              STR      r0,[r5,#0]            ;2215
000eda  f9bd1002          LDRSH    r1,[sp,#2]            ;2216
000ede  6868              LDR      r0,[r5,#4]            ;2216
000ee0  4408              ADD      r0,r0,r1              ;2216
000ee2  6068              STR      r0,[r5,#4]            ;2216
000ee4  f9bd1004          LDRSH    r1,[sp,#4]            ;2217
000ee8  68a8              LDR      r0,[r5,#8]            ;2217
000eea  4408              ADD      r0,r0,r1              ;2217
000eec  60a8              STR      r0,[r5,#8]            ;2217
000eee  f10a0001          ADD      r0,r10,#1             ;2202
000ef2  f0000aff          AND      r10,r0,#0xff          ;2202
                  |L1.3830|
000ef6  45b2              CMP      r10,r6                ;2202
000ef8  db97              BLT      |L1.3626|
000efa  4844              LDR      r0,|L1.4108|
000efc  f8d0c000          LDR      r12,[r0,#0]           ;2234  ; test
000f00  6828              LDR      r0,[r5,#0]            ;2234
000f02  17c1              ASRS     r1,r0,#31             ;2234
000f04  0409              LSLS     r1,r1,#16             ;2234
000f06  ea414110          ORR      r1,r1,r0,LSR #16      ;2234
000f0a  0407              LSLS     r7,r0,#16             ;2234
000f0c  4662              MOV      r2,r12                ;2234
000f0e  2300              MOVS     r3,#0                 ;2234
000f10  4638              MOV      r0,r7                 ;2234
000f12  f7fffffe          BL       __aeabi_ldivmod
000f16  4632              MOV      r2,r6                 ;2234
000f18  2300              MOVS     r3,#0                 ;2234
000f1a  e9cd0102          STRD     r0,r1,[sp,#8]         ;2234
000f1e  f7fffffe          BL       __aeabi_ldivmod
000f22  6028              STR      r0,[r5,#0]            ;2234
000f24  4839              LDR      r0,|L1.4108|
000f26  f8d0c000          LDR      r12,[r0,#0]           ;2235  ; test
000f2a  6868              LDR      r0,[r5,#4]            ;2235
000f2c  17c1              ASRS     r1,r0,#31             ;2235
000f2e  0409              LSLS     r1,r1,#16             ;2235
000f30  ea414110          ORR      r1,r1,r0,LSR #16      ;2235
000f34  0407              LSLS     r7,r0,#16             ;2235
000f36  4662              MOV      r2,r12                ;2235
000f38  2300              MOVS     r3,#0                 ;2235
000f3a  4638              MOV      r0,r7                 ;2235
000f3c  f7fffffe          BL       __aeabi_ldivmod
000f40  4632              MOV      r2,r6                 ;2235
000f42  2300              MOVS     r3,#0                 ;2235
000f44  e9cd0102          STRD     r0,r1,[sp,#8]         ;2235
000f48  f7fffffe          BL       __aeabi_ldivmod
000f4c  6068              STR      r0,[r5,#4]            ;2235
000f4e  482f              LDR      r0,|L1.4108|
000f50  f8d0c000          LDR      r12,[r0,#0]           ;2236  ; test
000f54  68a8              LDR      r0,[r5,#8]            ;2236
000f56  17c1              ASRS     r1,r0,#31             ;2236
000f58  0409              LSLS     r1,r1,#16             ;2236
000f5a  ea414110          ORR      r1,r1,r0,LSR #16      ;2236
000f5e  0407              LSLS     r7,r0,#16             ;2236
000f60  4662              MOV      r2,r12                ;2236
000f62  2300              MOVS     r3,#0                 ;2236
000f64  4638              MOV      r0,r7                 ;2236
000f66  f7fffffe          BL       __aeabi_ldivmod
000f6a  4632              MOV      r2,r6                 ;2236
000f6c  2300              MOVS     r3,#0                 ;2236
000f6e  e9cd0102          STRD     r0,r1,[sp,#8]         ;2236
000f72  f7fffffe          BL       __aeabi_ldivmod
000f76  60a8              STR      r0,[r5,#8]            ;2236
000f78  4824              LDR      r0,|L1.4108|
000f7a  f8d0c004          LDR      r12,[r0,#4]           ;2237  ; test
000f7e  6821              LDR      r1,[r4,#0]            ;2237
000f80  17c8              ASRS     r0,r1,#31             ;2237
000f82  0400              LSLS     r0,r0,#16             ;2237
000f84  ea404811          ORR      r8,r0,r1,LSR #16      ;2237
000f88  040f              LSLS     r7,r1,#16             ;2237
000f8a  4662              MOV      r2,r12                ;2237
000f8c  2300              MOVS     r3,#0                 ;2237
000f8e  4638              MOV      r0,r7                 ;2237
000f90  4641              MOV      r1,r8                 ;2237
000f92  f7fffffe          BL       __aeabi_ldivmod
000f96  4632              MOV      r2,r6                 ;2237
000f98  2300              MOVS     r3,#0                 ;2237
000f9a  e9cd0102          STRD     r0,r1,[sp,#8]         ;2237
000f9e  f7fffffe          BL       __aeabi_ldivmod
000fa2  6020              STR      r0,[r4,#0]            ;2237
000fa4  4819              LDR      r0,|L1.4108|
000fa6  f8d0c004          LDR      r12,[r0,#4]           ;2239  ; test
000faa  6860              LDR      r0,[r4,#4]            ;2239
000fac  17c1              ASRS     r1,r0,#31             ;2239
000fae  0409              LSLS     r1,r1,#16             ;2239
000fb0  ea414110          ORR      r1,r1,r0,LSR #16      ;2239
000fb4  0407              LSLS     r7,r0,#16             ;2239
000fb6  4662              MOV      r2,r12                ;2239
000fb8  2300              MOVS     r3,#0                 ;2239
000fba  4638              MOV      r0,r7                 ;2239
000fbc  f7fffffe          BL       __aeabi_ldivmod
000fc0  4632              MOV      r2,r6                 ;2239
000fc2  2300              MOVS     r3,#0                 ;2239
000fc4  e9cd0102          STRD     r0,r1,[sp,#8]         ;2239
000fc8  f7fffffe          BL       __aeabi_ldivmod
000fcc  6060              STR      r0,[r4,#4]            ;2239
000fce  480f              LDR      r0,|L1.4108|
000fd0  f8d0c004          LDR      r12,[r0,#4]           ;2241  ; test
000fd4  68a0              LDR      r0,[r4,#8]            ;2241
000fd6  17c1              ASRS     r1,r0,#31             ;2241
000fd8  0409              LSLS     r1,r1,#16             ;2241
000fda  ea414110          ORR      r1,r1,r0,LSR #16      ;2241
000fde  0407              LSLS     r7,r0,#16             ;2241
000fe0  4662              MOV      r2,r12                ;2241
000fe2  2300              MOVS     r3,#0                 ;2241
000fe4  4638              MOV      r0,r7                 ;2241
000fe6  f7fffffe          BL       __aeabi_ldivmod
000fea  4632              MOV      r2,r6                 ;2241
000fec  2300              MOVS     r3,#0                 ;2241
000fee  e9cd0102          STRD     r0,r1,[sp,#8]         ;2241
000ff2  f7fffffe          BL       __aeabi_ldivmod
000ff6  60a0              STR      r0,[r4,#8]            ;2241
000ff8  68a0              LDR      r0,[r4,#8]            ;2244
000ffa  2800              CMP      r0,#0                 ;2244
000ffc  dd08              BLE      |L1.4112|
000ffe  68a0              LDR      r0,[r4,#8]            ;2245
001000  f5a03080          SUB      r0,r0,#0x10000        ;2245
001004  60a0              STR      r0,[r4,#8]            ;2245
001006  e007              B        |L1.4120|
                  |L1.4104|
                          DCD      ||st||
                  |L1.4108|
                          DCD      test
                  |L1.4112|
001010  68a0              LDR      r0,[r4,#8]            ;2247
001012  f5003080          ADD      r0,r0,#0x10000        ;2247
001016  60a0              STR      r0,[r4,#8]            ;2247
                  |L1.4120|
001018  2000              MOVS     r0,#0                 ;2250
00101a  e5d7              B        |L1.3020|
;;;2252   
                          ENDP

                  mpu_get_fifo_config PROC
;;;1619    */
;;;1620   int mpu_get_fifo_config(unsigned char *sensors)
00101c  4601              MOV      r1,r0
;;;1621   {
;;;1622       sensors[0] = st.chip_cfg.fifo_enable;
00101e  48fa              LDR      r0,|L1.5128|
001020  7c00              LDRB     r0,[r0,#0x10]
001022  7008              STRB     r0,[r1,#0]
;;;1623       return 0;
001024  2000              MOVS     r0,#0
;;;1624   }
001026  4770              BX       lr
;;;1625   
                          ENDP

                  mpu_get_sample_rate PROC
;;;1455    */
;;;1456   int mpu_get_sample_rate(unsigned short *rate)
001028  4601              MOV      r1,r0
;;;1457   {
;;;1458       if (st.chip_cfg.dmp_on)
00102a  48f7              LDR      r0,|L1.5128|
00102c  f8900024          LDRB     r0,[r0,#0x24]
001030  b110              CBZ      r0,|L1.4152|
;;;1459           return -1;
001032  f04f30ff          MOV      r0,#0xffffffff
                  |L1.4150|
;;;1460       else
;;;1461           rate[0] = st.chip_cfg.sample_rate;
;;;1462       return 0;
;;;1463   }
001036  4770              BX       lr
                  |L1.4152|
001038  48f3              LDR      r0,|L1.5128|
00103a  89c0              LDRH     r0,[r0,#0xe]          ;1461
00103c  8008              STRH     r0,[r1,#0]            ;1461
00103e  2000              MOVS     r0,#0                 ;1462
001040  e7f9              B        |L1.4150|
;;;1464   
                          ENDP

                  mpu_get_lpf PROC
;;;1386    */
;;;1387   int mpu_get_lpf(unsigned short *lpf)
001042  4601              MOV      r1,r0
;;;1388   {
;;;1389       switch (st.chip_cfg.lpf) {
001044  48f0              LDR      r0,|L1.5128|
001046  7ac0              LDRB     r0,[r0,#0xb]
001048  2808              CMP      r0,#8
00104a  d217              BCS      |L1.4220|
00104c  e8dff000          TBB      [pc,r0]
001050  1704070a          DCB      0x17,0x04,0x07,0x0a
001054  0d101318          DCB      0x0d,0x10,0x13,0x18
;;;1390       case INV_FILTER_188HZ:
;;;1391           lpf[0] = 188;
001058  20bc              MOVS     r0,#0xbc
00105a  8008              STRH     r0,[r1,#0]
;;;1392           break;
00105c  e013              B        |L1.4230|
;;;1393       case INV_FILTER_98HZ:
;;;1394           lpf[0] = 98;
00105e  2062              MOVS     r0,#0x62
001060  8008              STRH     r0,[r1,#0]
;;;1395           break;
001062  e010              B        |L1.4230|
;;;1396       case INV_FILTER_42HZ:
;;;1397           lpf[0] = 42;
001064  202a              MOVS     r0,#0x2a
001066  8008              STRH     r0,[r1,#0]
;;;1398           break;
001068  e00d              B        |L1.4230|
;;;1399       case INV_FILTER_20HZ:
;;;1400           lpf[0] = 20;
00106a  2014              MOVS     r0,#0x14
00106c  8008              STRH     r0,[r1,#0]
;;;1401           break;
00106e  e00a              B        |L1.4230|
;;;1402       case INV_FILTER_10HZ:
;;;1403           lpf[0] = 10;
001070  200a              MOVS     r0,#0xa
001072  8008              STRH     r0,[r1,#0]
;;;1404           break;
001074  e007              B        |L1.4230|
;;;1405       case INV_FILTER_5HZ:
;;;1406           lpf[0] = 5;
001076  2005              MOVS     r0,#5
001078  8008              STRH     r0,[r1,#0]
;;;1407           break;
00107a  e004              B        |L1.4230|
                  |L1.4220|
;;;1408       case INV_FILTER_256HZ_NOLPF2:
00107c  bf00              NOP      
;;;1409       case INV_FILTER_2100HZ_NOLPF:
00107e  bf00              NOP      
;;;1410       default:
;;;1411           lpf[0] = 0;
001080  2000              MOVS     r0,#0
001082  8008              STRH     r0,[r1,#0]
;;;1412           break;
001084  bf00              NOP      
                  |L1.4230|
001086  bf00              NOP                            ;1392
;;;1413       }
;;;1414       return 0;
001088  2000              MOVS     r0,#0
;;;1415   }
00108a  4770              BX       lr
;;;1416   
                          ENDP

                  mpu_get_accel_fsr PROC
;;;1321    */
;;;1322   int mpu_get_accel_fsr(unsigned char *fsr)
00108c  4601              MOV      r1,r0
;;;1323   {
;;;1324       switch (st.chip_cfg.accel_fsr) {
00108e  48de              LDR      r0,|L1.5128|
001090  7a40              LDRB     r0,[r0,#9]
001092  b130              CBZ      r0,|L1.4258|
001094  2801              CMP      r0,#1
001096  d007              BEQ      |L1.4264|
001098  2802              CMP      r0,#2
00109a  d008              BEQ      |L1.4270|
00109c  2803              CMP      r0,#3
00109e  d10c              BNE      |L1.4282|
0010a0  e008              B        |L1.4276|
                  |L1.4258|
;;;1325       case INV_FSR_2G:
;;;1326           fsr[0] = 2;
0010a2  2002              MOVS     r0,#2
0010a4  7008              STRB     r0,[r1,#0]
;;;1327           break;
0010a6  e00b              B        |L1.4288|
                  |L1.4264|
;;;1328       case INV_FSR_4G:
;;;1329           fsr[0] = 4;
0010a8  2004              MOVS     r0,#4
0010aa  7008              STRB     r0,[r1,#0]
;;;1330           break;
0010ac  e008              B        |L1.4288|
                  |L1.4270|
;;;1331       case INV_FSR_8G:
;;;1332           fsr[0] = 8;
0010ae  2008              MOVS     r0,#8
0010b0  7008              STRB     r0,[r1,#0]
;;;1333           break;
0010b2  e005              B        |L1.4288|
                  |L1.4276|
;;;1334       case INV_FSR_16G:
;;;1335           fsr[0] = 16;
0010b4  2010              MOVS     r0,#0x10
0010b6  7008              STRB     r0,[r1,#0]
;;;1336           break;
0010b8  e002              B        |L1.4288|
                  |L1.4282|
;;;1337       default:
;;;1338           return -1;
0010ba  f04f30ff          MOV      r0,#0xffffffff
                  |L1.4286|
;;;1339       }
;;;1340       if (st.chip_cfg.accel_half)
;;;1341           fsr[0] <<= 1;
;;;1342       return 0;
;;;1343   }
0010be  4770              BX       lr
                  |L1.4288|
0010c0  bf00              NOP                            ;1327
0010c2  48d1              LDR      r0,|L1.5128|
0010c4  7cc0              LDRB     r0,[r0,#0x13]         ;1340
0010c6  b118              CBZ      r0,|L1.4304|
0010c8  7808              LDRB     r0,[r1,#0]            ;1341
0010ca  0640              LSLS     r0,r0,#25             ;1341
0010cc  0e00              LSRS     r0,r0,#24             ;1341
0010ce  7008              STRB     r0,[r1,#0]            ;1341
                  |L1.4304|
0010d0  2000              MOVS     r0,#0                 ;1342
0010d2  e7f4              B        |L1.4286|
;;;1344   
                          ENDP

                  mpu_get_gyro_fsr PROC
;;;1257    */
;;;1258   int mpu_get_gyro_fsr(unsigned short *fsr)
0010d4  4601              MOV      r1,r0
;;;1259   {
;;;1260       switch (st.chip_cfg.gyro_fsr) {
0010d6  48cc              LDR      r0,|L1.5128|
0010d8  7a00              LDRB     r0,[r0,#8]  ; st
0010da  b130              CBZ      r0,|L1.4330|
0010dc  2801              CMP      r0,#1
0010de  d007              BEQ      |L1.4336|
0010e0  2802              CMP      r0,#2
0010e2  d009              BEQ      |L1.4344|
0010e4  2803              CMP      r0,#3
0010e6  d10f              BNE      |L1.4360|
0010e8  e00a              B        |L1.4352|
                  |L1.4330|
;;;1261       case INV_FSR_250DPS:
;;;1262           fsr[0] = 250;
0010ea  20fa              MOVS     r0,#0xfa
0010ec  8008              STRH     r0,[r1,#0]
;;;1263           break;
0010ee  e00e              B        |L1.4366|
                  |L1.4336|
;;;1264       case INV_FSR_500DPS:
;;;1265           fsr[0] = 500;
0010f0  f44f70fa          MOV      r0,#0x1f4
0010f4  8008              STRH     r0,[r1,#0]
;;;1266           break;
0010f6  e00a              B        |L1.4366|
                  |L1.4344|
;;;1267       case INV_FSR_1000DPS:
;;;1268           fsr[0] = 1000;
0010f8  f44f707a          MOV      r0,#0x3e8
0010fc  8008              STRH     r0,[r1,#0]
;;;1269           break;
0010fe  e006              B        |L1.4366|
                  |L1.4352|
;;;1270       case INV_FSR_2000DPS:
;;;1271           fsr[0] = 2000;
001100  f44f60fa          MOV      r0,#0x7d0
001104  8008              STRH     r0,[r1,#0]
;;;1272           break;
001106  e002              B        |L1.4366|
                  |L1.4360|
;;;1273       default:
;;;1274           fsr[0] = 0;
001108  2000              MOVS     r0,#0
00110a  8008              STRH     r0,[r1,#0]
;;;1275           break;
00110c  bf00              NOP      
                  |L1.4366|
00110e  bf00              NOP                            ;1263
;;;1276       }
;;;1277       return 0;
001110  2000              MOVS     r0,#0
;;;1278   }
001112  4770              BX       lr
;;;1279   
                          ENDP

                  mpu_run_self_test PROC
;;;2272    */
;;;2273   int mpu_run_self_test(long *gyro, long *accel)
001114  e92d4ff0          PUSH     {r4-r11,lr}
;;;2274   {
001118  b08d              SUB      sp,sp,#0x34
00111a  4683              MOV      r11,r0
00111c  460f              MOV      r7,r1
;;;2275   #ifdef MPU6050
;;;2276       const unsigned char tries = 2;
00111e  2002              MOVS     r0,#2
001120  900c              STR      r0,[sp,#0x30]
;;;2277       long gyro_st[3], accel_st[3];
;;;2278       unsigned char accel_result, gyro_result;
;;;2279   #ifdef AK89xx_SECONDARY
;;;2280       unsigned char compass_result;
;;;2281   #endif
;;;2282       int ii;
;;;2283   #endif
;;;2284       int result;
;;;2285       unsigned char accel_fsr, fifo_sensors, sensors_on;
;;;2286       unsigned short gyro_fsr, sample_rate, lpf;
;;;2287       unsigned char dmp_was_on;
;;;2288   
;;;2289       if (st.chip_cfg.dmp_on) {
001122  48b9              LDR      r0,|L1.5128|
001124  f8900024          LDRB     r0,[r0,#0x24]
001128  b120              CBZ      r0,|L1.4404|
;;;2290           mpu_set_dmp_state(0);
00112a  2000              MOVS     r0,#0
00112c  f7fffffe          BL       mpu_set_dmp_state
;;;2291           dmp_was_on = 1;
001130  2601              MOVS     r6,#1
001132  e000              B        |L1.4406|
                  |L1.4404|
;;;2292       } else
;;;2293           dmp_was_on = 0;
001134  2600              MOVS     r6,#0
                  |L1.4406|
;;;2294   
;;;2295       /* Get initial settings. */
;;;2296       mpu_get_gyro_fsr(&gyro_fsr);
001136  a803              ADD      r0,sp,#0xc
001138  f7fffffe          BL       mpu_get_gyro_fsr
;;;2297       mpu_get_accel_fsr(&accel_fsr);
00113c  a805              ADD      r0,sp,#0x14
00113e  f7fffffe          BL       mpu_get_accel_fsr
;;;2298       mpu_get_lpf(&lpf);
001142  a801              ADD      r0,sp,#4
001144  f7fffffe          BL       mpu_get_lpf
;;;2299       mpu_get_sample_rate(&sample_rate);
001148  a802              ADD      r0,sp,#8
00114a  f7fffffe          BL       mpu_get_sample_rate
;;;2300       sensors_on = st.chip_cfg.sensors;
00114e  48ae              LDR      r0,|L1.5128|
001150  f890a00a          LDRB     r10,[r0,#0xa]
;;;2301       mpu_get_fifo_config(&fifo_sensors);
001154  a804              ADD      r0,sp,#0x10
001156  f7fffffe          BL       mpu_get_fifo_config
;;;2302   
;;;2303       /* For older chips, the self-test will be different. */
;;;2304   #if defined MPU6050
;;;2305       for (ii = 0; ii < tries; ii++)
00115a  2400              MOVS     r4,#0
00115c  e007              B        |L1.4462|
                  |L1.4446|
;;;2306           if (!get_st_biases(gyro, accel, 0))
00115e  2200              MOVS     r2,#0
001160  4639              MOV      r1,r7
001162  4658              MOV      r0,r11
001164  f7fffffe          BL       get_st_biases
001168  b900              CBNZ     r0,|L1.4460|
;;;2307               break;
00116a  e002              B        |L1.4466|
                  |L1.4460|
00116c  1c64              ADDS     r4,r4,#1              ;2305
                  |L1.4462|
00116e  2c02              CMP      r4,#2                 ;2305
001170  dbf5              BLT      |L1.4446|
                  |L1.4466|
001172  bf00              NOP      
;;;2308       if (ii == tries) {
001174  2c02              CMP      r4,#2
001176  d101              BNE      |L1.4476|
;;;2309           /* If we reach this point, we most likely encountered an I2C error.
;;;2310            * We'll just report an error for all three sensors.
;;;2311            */
;;;2312           result = 0;
001178  2500              MOVS     r5,#0
;;;2313           goto restore;
00117a  e028              B        |L1.4558|
                  |L1.4476|
;;;2314       }
;;;2315       for (ii = 0; ii < tries; ii++)
00117c  2400              MOVS     r4,#0
00117e  e007              B        |L1.4496|
                  |L1.4480|
;;;2316           if (!get_st_biases(gyro_st, accel_st, 1))
001180  2201              MOVS     r2,#1
001182  a906              ADD      r1,sp,#0x18
001184  a809              ADD      r0,sp,#0x24
001186  f7fffffe          BL       get_st_biases
00118a  b900              CBNZ     r0,|L1.4494|
;;;2317               break;
00118c  e002              B        |L1.4500|
                  |L1.4494|
00118e  1c64              ADDS     r4,r4,#1              ;2315
                  |L1.4496|
001190  2c02              CMP      r4,#2                 ;2315
001192  dbf5              BLT      |L1.4480|
                  |L1.4500|
001194  bf00              NOP      
;;;2318       if (ii == tries) {
001196  2c02              CMP      r4,#2
001198  d101              BNE      |L1.4510|
;;;2319           /* Again, probably an I2C error. */
;;;2320           result = 0;
00119a  2500              MOVS     r5,#0
;;;2321           goto restore;
00119c  e017              B        |L1.4558|
                  |L1.4510|
;;;2322       }
;;;2323       accel_result = accel_self_test(accel, accel_st);
00119e  a906              ADD      r1,sp,#0x18
0011a0  4638              MOV      r0,r7
0011a2  f7fffffe          BL       accel_self_test
0011a6  f00008ff          AND      r8,r0,#0xff
;;;2324       gyro_result = gyro_self_test(gyro, gyro_st);
0011aa  a909              ADD      r1,sp,#0x24
0011ac  4658              MOV      r0,r11
0011ae  f7fffffe          BL       gyro_self_test
0011b2  f00009ff          AND      r9,r0,#0xff
;;;2325   
;;;2326       result = 0;
0011b6  2500              MOVS     r5,#0
;;;2327       if (!gyro_result)
0011b8  f1b90f00          CMP      r9,#0
0011bc  d101              BNE      |L1.4546|
;;;2328           result |= 0x01;
0011be  f0450501          ORR      r5,r5,#1
                  |L1.4546|
;;;2329       if (!accel_result)
0011c2  f1b80f00          CMP      r8,#0
0011c6  d101              BNE      |L1.4556|
;;;2330           result |= 0x02;
0011c8  f0450502          ORR      r5,r5,#2
                  |L1.4556|
;;;2331   
;;;2332   #ifdef AK89xx_SECONDARY
;;;2333       compass_result = compass_self_test();
;;;2334       if (!compass_result)
;;;2335           result |= 0x04;
;;;2336   #endif
;;;2337   restore:
0011cc  bf00              NOP      
                  |L1.4558|
;;;2338   #elif defined MPU6500
;;;2339       /* For now, this function will return a "pass" result for all three sensors
;;;2340        * for compatibility with current test applications.
;;;2341        */
;;;2342       get_st_biases(gyro, accel, 0);
;;;2343       result = 0x7;
;;;2344   #endif
;;;2345       /* Set to invalid values to ensure no I2C writes are skipped. */
;;;2346       st.chip_cfg.gyro_fsr = 0xFF;
0011ce  20ff              MOVS     r0,#0xff
0011d0  498d              LDR      r1,|L1.5128|
0011d2  7208              STRB     r0,[r1,#8]
;;;2347       st.chip_cfg.accel_fsr = 0xFF;
0011d4  21ff              MOVS     r1,#0xff
0011d6  488c              LDR      r0,|L1.5128|
0011d8  7241              STRB     r1,[r0,#9]
;;;2348       st.chip_cfg.lpf = 0xFF;
0011da  72c1              STRB     r1,[r0,#0xb]
;;;2349       st.chip_cfg.sample_rate = 0xFFFF;
0011dc  f64f71ff          MOV      r1,#0xffff
0011e0  81c1              STRH     r1,[r0,#0xe]
;;;2350       st.chip_cfg.sensors = 0xFF;
0011e2  21ff              MOVS     r1,#0xff
0011e4  7281              STRB     r1,[r0,#0xa]
;;;2351       st.chip_cfg.fifo_enable = 0xFF;
0011e6  7401              STRB     r1,[r0,#0x10]
;;;2352       st.chip_cfg.clk_src = INV_CLK_PLL;
0011e8  2101              MOVS     r1,#1
0011ea  7301              STRB     r1,[r0,#0xc]
;;;2353       mpu_set_gyro_fsr(gyro_fsr);
0011ec  f8bd000c          LDRH     r0,[sp,#0xc]
0011f0  f7fffffe          BL       mpu_set_gyro_fsr
;;;2354       mpu_set_accel_fsr(accel_fsr);
0011f4  f89d0014          LDRB     r0,[sp,#0x14]
0011f8  f7fffffe          BL       mpu_set_accel_fsr
;;;2355       mpu_set_lpf(lpf);
0011fc  f8bd0004          LDRH     r0,[sp,#4]
001200  f7fffffe          BL       mpu_set_lpf
;;;2356       mpu_set_sample_rate(sample_rate);
001204  f8bd0008          LDRH     r0,[sp,#8]
001208  f7fffffe          BL       mpu_set_sample_rate
;;;2357       mpu_set_sensors(sensors_on);
00120c  4650              MOV      r0,r10
00120e  f7fffffe          BL       mpu_set_sensors
;;;2358       mpu_configure_fifo(fifo_sensors);
001212  f89d0010          LDRB     r0,[sp,#0x10]
001216  f7fffffe          BL       mpu_configure_fifo
;;;2359   
;;;2360       if (dmp_was_on)
00121a  b116              CBZ      r6,|L1.4642|
;;;2361           mpu_set_dmp_state(1);
00121c  2001              MOVS     r0,#1
00121e  f7fffffe          BL       mpu_set_dmp_state
                  |L1.4642|
;;;2362   
;;;2363       return result;
001222  4628              MOV      r0,r5
;;;2364   }
001224  b00d              ADD      sp,sp,#0x34
001226  e8bd8ff0          POP      {r4-r11,pc}
;;;2365   
                          ENDP

                  run_self_test PROC
;;;55      */
;;;56     void run_self_test(void)
00122a  b570              PUSH     {r4-r6,lr}
;;;57     {
00122c  b088              SUB      sp,sp,#0x20
;;;58         int result;
;;;59     //    char test_packet[4] = {0};
;;;60         long gyro[3], accel[3];
;;;61     
;;;62         result = mpu_run_self_test(gyro, accel);
00122e  a902              ADD      r1,sp,#8
001230  a805              ADD      r0,sp,#0x14
001232  f7fffffe          BL       mpu_run_self_test
001236  4604              MOV      r4,r0
;;;63         if (result == 0x7) {
001238  2c07              CMP      r4,#7
00123a  d13c              BNE      |L1.4790|
;;;64             /* Test passed. We can trust the gyro data here, so let's push it down
;;;65              * to the DMP.
;;;66              */
;;;67             float sens;
;;;68             unsigned short accel_sens;
;;;69             mpu_get_gyro_sens(&sens);
00123c  a801              ADD      r0,sp,#4
00123e  f7fffffe          BL       mpu_get_gyro_sens
;;;70             gyro[0] = (long)(gyro[0] * sens);
001242  9805              LDR      r0,[sp,#0x14]
001244  f7fffffe          BL       __aeabi_i2f
001248  4606              MOV      r6,r0
00124a  9901              LDR      r1,[sp,#4]
00124c  f7fffffe          BL       __aeabi_fmul
001250  4605              MOV      r5,r0
001252  f7fffffe          BL       __aeabi_f2iz
001256  9005              STR      r0,[sp,#0x14]
;;;71             gyro[1] = (long)(gyro[1] * sens);
001258  9806              LDR      r0,[sp,#0x18]
00125a  f7fffffe          BL       __aeabi_i2f
00125e  4606              MOV      r6,r0
001260  9901              LDR      r1,[sp,#4]
001262  f7fffffe          BL       __aeabi_fmul
001266  4605              MOV      r5,r0
001268  f7fffffe          BL       __aeabi_f2iz
00126c  9006              STR      r0,[sp,#0x18]
;;;72             gyro[2] = (long)(gyro[2] * sens);
00126e  9807              LDR      r0,[sp,#0x1c]
001270  f7fffffe          BL       __aeabi_i2f
001274  4606              MOV      r6,r0
001276  9901              LDR      r1,[sp,#4]
001278  f7fffffe          BL       __aeabi_fmul
00127c  4605              MOV      r5,r0
00127e  f7fffffe          BL       __aeabi_f2iz
001282  9007              STR      r0,[sp,#0x1c]
;;;73             dmp_set_gyro_bias(gyro);
001284  a805              ADD      r0,sp,#0x14
001286  f7fffffe          BL       dmp_set_gyro_bias
;;;74             mpu_get_accel_sens(&accel_sens);
00128a  4668              MOV      r0,sp
00128c  f7fffffe          BL       mpu_get_accel_sens
;;;75             accel[0] *= accel_sens;
001290  f8bd1000          LDRH     r1,[sp,#0]
001294  9802              LDR      r0,[sp,#8]
001296  4348              MULS     r0,r1,r0
001298  9002              STR      r0,[sp,#8]
;;;76             accel[1] *= accel_sens;
00129a  f8bd1000          LDRH     r1,[sp,#0]
00129e  9803              LDR      r0,[sp,#0xc]
0012a0  4348              MULS     r0,r1,r0
0012a2  9003              STR      r0,[sp,#0xc]
;;;77             accel[2] *= accel_sens;
0012a4  f8bd1000          LDRH     r1,[sp,#0]
0012a8  9804              LDR      r0,[sp,#0x10]
0012aa  4348              MULS     r0,r1,r0
0012ac  9004              STR      r0,[sp,#0x10]
;;;78             dmp_set_accel_bias(accel);
0012ae  a802              ADD      r0,sp,#8
0012b0  f7fffffe          BL       dmp_set_accel_bias
;;;79         }
0012b4  bf00              NOP      
                  |L1.4790|
;;;80     }
0012b6  b008              ADD      sp,sp,#0x20
0012b8  bd70              POP      {r4-r6,pc}
;;;81     
                          ENDP

                  inv_row_2_scale PROC
;;;102    }
;;;103     unsigned short inv_row_2_scale(const signed char *row)
0012ba  4601              MOV      r1,r0
;;;104    {
;;;105        unsigned short b;
;;;106    
;;;107        if (row[0] > 0)
0012bc  f9912000          LDRSB    r2,[r1,#0]
0012c0  2a00              CMP      r2,#0
0012c2  dd01              BLE      |L1.4808|
;;;108            b = 0;
0012c4  2000              MOVS     r0,#0
0012c6  e01e              B        |L1.4870|
                  |L1.4808|
;;;109        else if (row[0] < 0)
0012c8  f9912000          LDRSB    r2,[r1,#0]
0012cc  2a00              CMP      r2,#0
0012ce  da01              BGE      |L1.4820|
;;;110            b = 4;
0012d0  2004              MOVS     r0,#4
0012d2  e018              B        |L1.4870|
                  |L1.4820|
;;;111        else if (row[1] > 0)
0012d4  f9912001          LDRSB    r2,[r1,#1]
0012d8  2a00              CMP      r2,#0
0012da  dd01              BLE      |L1.4832|
;;;112            b = 1;
0012dc  2001              MOVS     r0,#1
0012de  e012              B        |L1.4870|
                  |L1.4832|
;;;113        else if (row[1] < 0)
0012e0  f9912001          LDRSB    r2,[r1,#1]
0012e4  2a00              CMP      r2,#0
0012e6  da01              BGE      |L1.4844|
;;;114            b = 5;
0012e8  2005              MOVS     r0,#5
0012ea  e00c              B        |L1.4870|
                  |L1.4844|
;;;115        else if (row[2] > 0)
0012ec  f9912002          LDRSB    r2,[r1,#2]
0012f0  2a00              CMP      r2,#0
0012f2  dd01              BLE      |L1.4856|
;;;116            b = 2;
0012f4  2002              MOVS     r0,#2
0012f6  e006              B        |L1.4870|
                  |L1.4856|
;;;117        else if (row[2] < 0)
0012f8  f9912002          LDRSB    r2,[r1,#2]
0012fc  2a00              CMP      r2,#0
0012fe  da01              BGE      |L1.4868|
;;;118            b = 6;
001300  2006              MOVS     r0,#6
001302  e000              B        |L1.4870|
                  |L1.4868|
;;;119        else
;;;120            b = 7;      // error
001304  2007              MOVS     r0,#7
                  |L1.4870|
;;;121        return b;
;;;122    }
001306  4770              BX       lr
;;;123    
                          ENDP

                  inv_orientation_matrix_to_scalar PROC
;;;81     
;;;82      unsigned short inv_orientation_matrix_to_scalar(
001308  b510              PUSH     {r4,lr}
;;;83         const signed char *mtx)
;;;84     {
00130a  4604              MOV      r4,r0
;;;85         unsigned short scalar;
;;;86     
;;;87         /*
;;;88            XYZ  010_001_000 Identity Matrix
;;;89            XZY  001_010_000
;;;90            YXZ  010_000_001
;;;91            YZX  000_010_001
;;;92            ZXY  001_000_010
;;;93            ZYX  000_001_010
;;;94          */
;;;95     
;;;96         scalar  = inv_row_2_scale(mtx);
00130c  4620              MOV      r0,r4
00130e  f7fffffe          BL       inv_row_2_scale
001312  4603              MOV      r3,r0
;;;97         scalar |= inv_row_2_scale(mtx + 3) << 3;
001314  1ce0              ADDS     r0,r4,#3
001316  f7fffffe          BL       inv_row_2_scale
00131a  ea4300c0          ORR      r0,r3,r0,LSL #3
00131e  b283              UXTH     r3,r0
;;;98         scalar |= inv_row_2_scale(mtx + 6) << 6;
001320  1da0              ADDS     r0,r4,#6
001322  f7fffffe          BL       inv_row_2_scale
001326  ea431080          ORR      r0,r3,r0,LSL #6
00132a  b283              UXTH     r3,r0
;;;99     
;;;100    
;;;101        return scalar;
00132c  4618              MOV      r0,r3
;;;102    }
00132e  bd10              POP      {r4,pc}
;;;103     unsigned short inv_row_2_scale(const signed char *row)
                          ENDP

                  get_ms PROC
;;;124    
;;;125    void get_ms(unsigned long *time)
001330  4770              BX       lr
;;;126    {
;;;127    
;;;128    }
;;;129    
                          ENDP

                  mpu_reg_dump PROC
;;;816     */
;;;817    int mpu_reg_dump(void)
001332  b538              PUSH     {r3-r5,lr}
;;;818    {
;;;819        unsigned char ii;
;;;820        unsigned char data;
;;;821    
;;;822        for (ii = 0; ii < st.hw->num_reg; ii++) {
001334  2400              MOVS     r4,#0
001336  e019              B        |L1.4972|
                  |L1.4920|
;;;823            if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
001338  4833              LDR      r0,|L1.5128|
00133a  6800              LDR      r0,[r0,#0]  ; st
00133c  7ac0              LDRB     r0,[r0,#0xb]
00133e  42a0              CMP      r0,r4
001340  d004              BEQ      |L1.4940|
001342  4831              LDR      r0,|L1.5128|
001344  6800              LDR      r0,[r0,#0]  ; st
001346  7d40              LDRB     r0,[r0,#0x15]
001348  42a0              CMP      r0,r4
00134a  d100              BNE      |L1.4942|
                  |L1.4940|
;;;824                continue;
00134c  e00c              B        |L1.4968|
                  |L1.4942|
;;;825            if (i2c_read(st.hw->addr, ii, 1, &data))
00134e  492e              LDR      r1,|L1.5128|
001350  6849              LDR      r1,[r1,#4]  ; st
001352  7808              LDRB     r0,[r1,#0]
001354  466b              MOV      r3,sp
001356  2201              MOVS     r2,#1
001358  4621              MOV      r1,r4
00135a  f7fffffe          BL       I2C_Read
00135e  b110              CBZ      r0,|L1.4966|
;;;826                return -1;
001360  f04f30ff          MOV      r0,#0xffffffff
                  |L1.4964|
;;;827            //log_i("%#5x: %#5x\r\n", ii, data);
;;;828        }
;;;829        return 0;
;;;830    }
001364  bd38              POP      {r3-r5,pc}
                  |L1.4966|
001366  bf00              NOP                            ;824
                  |L1.4968|
001368  1c60              ADDS     r0,r4,#1              ;822
00136a  b2c4              UXTB     r4,r0                 ;822
                  |L1.4972|
00136c  4826              LDR      r0,|L1.5128|
00136e  6840              LDR      r0,[r0,#4]            ;822  ; st
001370  7900              LDRB     r0,[r0,#4]            ;822
001372  42a0              CMP      r0,r4                 ;822
001374  dce0              BGT      |L1.4920|
001376  2000              MOVS     r0,#0                 ;829
001378  e7f4              B        |L1.4964|
;;;831    
                          ENDP

                  mpu_read_reg PROC
;;;838     */
;;;839    int mpu_read_reg(unsigned char reg, unsigned char *data)
00137a  b570              PUSH     {r4-r6,lr}
;;;840    {
00137c  4604              MOV      r4,r0
00137e  460d              MOV      r5,r1
;;;841        if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
001380  4821              LDR      r0,|L1.5128|
001382  6800              LDR      r0,[r0,#0]  ; st
001384  7ac0              LDRB     r0,[r0,#0xb]
001386  42a0              CMP      r0,r4
001388  d004              BEQ      |L1.5012|
00138a  481f              LDR      r0,|L1.5128|
00138c  6800              LDR      r0,[r0,#0]  ; st
00138e  7d40              LDRB     r0,[r0,#0x15]
001390  42a0              CMP      r0,r4
001392  d102              BNE      |L1.5018|
                  |L1.5012|
;;;842            return -1;
001394  f04f30ff          MOV      r0,#0xffffffff
                  |L1.5016|
;;;843        if (reg >= st.hw->num_reg)
;;;844            return -1;
;;;845        return i2c_read(st.hw->addr, reg, 1, data);
;;;846    }
001398  bd70              POP      {r4-r6,pc}
                  |L1.5018|
00139a  481b              LDR      r0,|L1.5128|
00139c  6840              LDR      r0,[r0,#4]            ;843  ; st
00139e  7900              LDRB     r0,[r0,#4]            ;843
0013a0  42a0              CMP      r0,r4                 ;843
0013a2  dc02              BGT      |L1.5034|
0013a4  f04f30ff          MOV      r0,#0xffffffff        ;844
0013a8  e7f6              B        |L1.5016|
                  |L1.5034|
0013aa  4917              LDR      r1,|L1.5128|
0013ac  6849              LDR      r1,[r1,#4]            ;845  ; st
0013ae  7808              LDRB     r0,[r1,#0]            ;845
0013b0  462b              MOV      r3,r5                 ;845
0013b2  2201              MOVS     r2,#1                 ;845
0013b4  4621              MOV      r1,r4                 ;845
0013b6  f7fffffe          BL       I2C_Read
0013ba  e7ed              B        |L1.5016|
;;;847    
                          ENDP

                  mpu_init PROC
;;;860     */
;;;861    int mpu_init(void)
0013bc  b51c              PUSH     {r2-r4,lr}
;;;862    {
;;;863        unsigned char data[6], rev;
;;;864    
;;;865        /* Reset device. */
;;;866        data[0] = 0x80;//BIT_RESET;
0013be  2080              MOVS     r0,#0x80
0013c0  f88d0000          STRB     r0,[sp,#0]
;;;867        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &(data[0])))
0013c4  4a10              LDR      r2,|L1.5128|
0013c6  6812              LDR      r2,[r2,#0]  ; st
0013c8  7c91              LDRB     r1,[r2,#0x12]
0013ca  4a0f              LDR      r2,|L1.5128|
0013cc  6852              LDR      r2,[r2,#4]  ; st
0013ce  7810              LDRB     r0,[r2,#0]
0013d0  466b              MOV      r3,sp
0013d2  2201              MOVS     r2,#1
0013d4  f7fffffe          BL       I2C_Write
0013d8  b110              CBZ      r0,|L1.5088|
;;;868            return -1;
0013da  f04f30ff          MOV      r0,#0xffffffff
                  |L1.5086|
;;;869        delay_ms(100);
;;;870    
;;;871        /* Wake up chip. */
;;;872        data[0] = 0x00;
;;;873        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &(data[0])))
;;;874            return -1;
;;;875    
;;;876    #if defined MPU6050
;;;877        /* Check product revision. */
;;;878        if (i2c_read(st.hw->addr, st.reg->accel_offs, 6, data))
;;;879            return -1;
;;;880        rev = ((data[5] & 0x01) << 2) | ((data[3] & 0x01) << 1) |
;;;881            (data[1] & 0x01);
;;;882    
;;;883        if (rev) {
;;;884            /* Congrats, these parts are better. */
;;;885            if (rev == 1)
;;;886                st.chip_cfg.accel_half = 1;
;;;887            else if (rev == 2)
;;;888                st.chip_cfg.accel_half = 0;
;;;889            else {
;;;890                //log_e("Unsupported software product rev %d.\n");
;;;891                return -1;
;;;892            }
;;;893        } else {
;;;894            if (i2c_read(st.hw->addr, st.reg->prod_id, 1, &(data[0])))
;;;895                return -1;
;;;896            rev = data[0] & 0x0F;
;;;897            if (!rev) {
;;;898               // log_e("Product ID read as 0 indicates device is either "
;;;899                    //"incompatible or an MPU3050.\n");
;;;900                return -1;
;;;901            } else if (rev == 4) {
;;;902                //log_i("Half sensitivity part found.\n");
;;;903                st.chip_cfg.accel_half = 1;
;;;904            } else
;;;905                st.chip_cfg.accel_half = 0;
;;;906        }
;;;907    #elif defined MPU6500
;;;908    #define MPU6500_MEM_REV_ADDR    (0x17)
;;;909        if (mpu_read_mem(MPU6500_MEM_REV_ADDR, 1, &rev))
;;;910            return -1;
;;;911        if (rev == 0x1)
;;;912            st.chip_cfg.accel_half = 0;
;;;913        else {
;;;914            //log_e("Unsupported software product rev %d.\n", rev);
;;;915            return -1;
;;;916        }
;;;917    
;;;918        /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
;;;919         * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
;;;920         */
;;;921        data[0] = BIT_FIFO_SIZE_1024 | 0x8;
;;;922        if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, data))
;;;923            return -1;
;;;924    #endif
;;;925    
;;;926        /* Set to invalid values to ensure no I2C writes are skipped. */
;;;927        st.chip_cfg.sensors = 0xFF;
;;;928        st.chip_cfg.gyro_fsr = 0xFF;
;;;929        st.chip_cfg.accel_fsr = 0xFF;
;;;930        st.chip_cfg.lpf = 0xFF;
;;;931        st.chip_cfg.sample_rate = 0xFFFF;
;;;932        st.chip_cfg.fifo_enable = 0xFF;
;;;933        st.chip_cfg.bypass_mode = 0xFF;
;;;934    #ifdef AK89xx_SECONDARY
;;;935        st.chip_cfg.compass_sample_rate = 0xFFFF;
;;;936    #endif
;;;937        /* mpu_set_sensors always preserves this setting. */
;;;938        st.chip_cfg.clk_src = INV_CLK_PLL;
;;;939        /* Handled in next call to mpu_set_bypass. */
;;;940        st.chip_cfg.active_low_int = 1;
;;;941        st.chip_cfg.latched_int = 0;
;;;942        st.chip_cfg.int_motion_only = 0;
;;;943        st.chip_cfg.lp_accel_mode = 0;
;;;944        memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
;;;945        st.chip_cfg.dmp_on = 0;
;;;946        st.chip_cfg.dmp_loaded = 0;
;;;947        st.chip_cfg.dmp_sample_rate = 0;
;;;948    
;;;949        if (mpu_set_gyro_fsr(2000))
;;;950            return -1;
;;;951        if (mpu_set_accel_fsr(2))
;;;952            return -1;
;;;953        if (mpu_set_lpf(42))
;;;954            return -1;
;;;955        if (mpu_set_sample_rate(50))
;;;956            return -1;
;;;957        if (mpu_configure_fifo(0))
;;;958            return -1;
;;;959    
;;;960        /*if (int_param)
;;;961            reg_int_cb(int_param);*/
;;;962    
;;;963    #ifdef AK89xx_SECONDARY
;;;964        setup_compass();
;;;965        if (mpu_set_compass_sample_rate(10))
;;;966            return -1;
;;;967    #else
;;;968        /* Already disabled by setup_compass. */
;;;969        if (mpu_set_bypass(0))
;;;970            return -1;
;;;971    #endif
;;;972    
;;;973        mpu_set_sensors(0);
;;;974        return 0;
;;;975    }
0013de  bd1c              POP      {r2-r4,pc}
                  |L1.5088|
0013e0  2064              MOVS     r0,#0x64              ;869
0013e2  f7fffffe          BL       delay_ms
0013e6  2000              MOVS     r0,#0                 ;872
0013e8  f88d0000          STRB     r0,[sp,#0]            ;872
0013ec  4a06              LDR      r2,|L1.5128|
0013ee  6812              LDR      r2,[r2,#0]            ;873  ; st
0013f0  7c91              LDRB     r1,[r2,#0x12]         ;873
0013f2  4a05              LDR      r2,|L1.5128|
0013f4  6852              LDR      r2,[r2,#4]            ;873  ; st
0013f6  7810              LDRB     r0,[r2,#0]            ;873
0013f8  466b              MOV      r3,sp                 ;873
0013fa  2201              MOVS     r2,#1                 ;873
0013fc  f7fffffe          BL       I2C_Write
001400  b120              CBZ      r0,|L1.5132|
001402  f04f30ff          MOV      r0,#0xffffffff        ;874
001406  e7ea              B        |L1.5086|
                  |L1.5128|
                          DCD      ||st||
                  |L1.5132|
00140c  4afe              LDR      r2,|L1.6152|
00140e  6812              LDR      r2,[r2,#0]            ;878  ; st
001410  7d91              LDRB     r1,[r2,#0x16]         ;878
001412  4afd              LDR      r2,|L1.6152|
001414  6852              LDR      r2,[r2,#4]            ;878  ; st
001416  7810              LDRB     r0,[r2,#0]            ;878
001418  466b              MOV      r3,sp                 ;878
00141a  2206              MOVS     r2,#6                 ;878
00141c  f7fffffe          BL       I2C_Read
001420  b110              CBZ      r0,|L1.5160|
001422  f04f30ff          MOV      r0,#0xffffffff        ;879
001426  e7da              B        |L1.5086|
                  |L1.5160|
001428  f89d0005          LDRB     r0,[sp,#5]            ;880
00142c  07c0              LSLS     r0,r0,#31             ;880
00142e  0f40              LSRS     r0,r0,#29             ;880
001430  f89d1003          LDRB     r1,[sp,#3]            ;880
001434  f0010101          AND      r1,r1,#1              ;880
001438  ea400041          ORR      r0,r0,r1,LSL #1       ;880
00143c  f89d1001          LDRB     r1,[sp,#1]            ;880
001440  f0010101          AND      r1,r1,#1              ;880
001444  ea400401          ORR      r4,r0,r1              ;880
001448  b174              CBZ      r4,|L1.5224|
00144a  2c01              CMP      r4,#1                 ;885
00144c  d103              BNE      |L1.5206|
00144e  2101              MOVS     r1,#1                 ;886
001450  48ed              LDR      r0,|L1.6152|
001452  74c1              STRB     r1,[r0,#0x13]         ;886
001454  e027              B        |L1.5286|
                  |L1.5206|
001456  2c02              CMP      r4,#2                 ;887
001458  d103              BNE      |L1.5218|
00145a  2100              MOVS     r1,#0                 ;888
00145c  48ea              LDR      r0,|L1.6152|
00145e  74c1              STRB     r1,[r0,#0x13]         ;888
001460  e021              B        |L1.5286|
                  |L1.5218|
001462  f04f30ff          MOV      r0,#0xffffffff        ;891
001466  e7ba              B        |L1.5086|
                  |L1.5224|
001468  4ae7              LDR      r2,|L1.6152|
00146a  6812              LDR      r2,[r2,#0]            ;894  ; st
00146c  78d1              LDRB     r1,[r2,#3]            ;894
00146e  4ae6              LDR      r2,|L1.6152|
001470  6852              LDR      r2,[r2,#4]            ;894  ; st
001472  7810              LDRB     r0,[r2,#0]            ;894
001474  466b              MOV      r3,sp                 ;894
001476  2201              MOVS     r2,#1                 ;894
001478  f7fffffe          BL       I2C_Read
00147c  b110              CBZ      r0,|L1.5252|
00147e  f04f30ff          MOV      r0,#0xffffffff        ;895
001482  e7ac              B        |L1.5086|
                  |L1.5252|
001484  f89d0000          LDRB     r0,[sp,#0]            ;896
001488  f000040f          AND      r4,r0,#0xf            ;896
00148c  b914              CBNZ     r4,|L1.5268|
00148e  f04f30ff          MOV      r0,#0xffffffff        ;900
001492  e7a4              B        |L1.5086|
                  |L1.5268|
001494  2c04              CMP      r4,#4                 ;901
001496  d103              BNE      |L1.5280|
001498  2101              MOVS     r1,#1                 ;903
00149a  48db              LDR      r0,|L1.6152|
00149c  74c1              STRB     r1,[r0,#0x13]         ;903
00149e  e002              B        |L1.5286|
                  |L1.5280|
0014a0  2100              MOVS     r1,#0                 ;905
0014a2  48d9              LDR      r0,|L1.6152|
0014a4  74c1              STRB     r1,[r0,#0x13]         ;905
                  |L1.5286|
0014a6  21ff              MOVS     r1,#0xff              ;927
0014a8  48d7              LDR      r0,|L1.6152|
0014aa  7281              STRB     r1,[r0,#0xa]          ;927
0014ac  20ff              MOVS     r0,#0xff              ;928
0014ae  49d6              LDR      r1,|L1.6152|
0014b0  7208              STRB     r0,[r1,#8]            ;928
0014b2  21ff              MOVS     r1,#0xff              ;929
0014b4  48d4              LDR      r0,|L1.6152|
0014b6  7241              STRB     r1,[r0,#9]            ;929
0014b8  72c1              STRB     r1,[r0,#0xb]          ;930
0014ba  f64f71ff          MOV      r1,#0xffff            ;931
0014be  81c1              STRH     r1,[r0,#0xe]          ;931
0014c0  21ff              MOVS     r1,#0xff              ;932
0014c2  7401              STRB     r1,[r0,#0x10]         ;932
0014c4  7481              STRB     r1,[r0,#0x12]         ;933
0014c6  2101              MOVS     r1,#1                 ;938
0014c8  7301              STRB     r1,[r0,#0xc]          ;938
0014ca  f8801022          STRB     r1,[r0,#0x22]         ;940
0014ce  2100              MOVS     r1,#0                 ;941
0014d0  f8801023          STRB     r1,[r0,#0x23]         ;941
0014d4  7541              STRB     r1,[r0,#0x15]         ;942
0014d6  7501              STRB     r1,[r0,#0x14]         ;943
0014d8  3016              ADDS     r0,r0,#0x16           ;944
0014da  6001              STR      r1,[r0,#0]            ;944
0014dc  6041              STR      r1,[r0,#4]            ;944
0014de  6081              STR      r1,[r0,#8]            ;944
0014e0  3816              SUBS     r0,r0,#0x16           ;945
0014e2  f8801024          STRB     r1,[r0,#0x24]         ;945
0014e6  f8801025          STRB     r1,[r0,#0x25]         ;946
0014ea  84c1              STRH     r1,[r0,#0x26]         ;947
0014ec  f44f60fa          MOV      r0,#0x7d0             ;949
0014f0  f7fffffe          BL       mpu_set_gyro_fsr
0014f4  b110              CBZ      r0,|L1.5372|
0014f6  f04f30ff          MOV      r0,#0xffffffff        ;950
0014fa  e770              B        |L1.5086|
                  |L1.5372|
0014fc  2002              MOVS     r0,#2                 ;951
0014fe  f7fffffe          BL       mpu_set_accel_fsr
001502  b110              CBZ      r0,|L1.5386|
001504  f04f30ff          MOV      r0,#0xffffffff        ;952
001508  e769              B        |L1.5086|
                  |L1.5386|
00150a  202a              MOVS     r0,#0x2a              ;953
00150c  f7fffffe          BL       mpu_set_lpf
001510  b110              CBZ      r0,|L1.5400|
001512  f04f30ff          MOV      r0,#0xffffffff        ;954
001516  e762              B        |L1.5086|
                  |L1.5400|
001518  2032              MOVS     r0,#0x32              ;955
00151a  f7fffffe          BL       mpu_set_sample_rate
00151e  b110              CBZ      r0,|L1.5414|
001520  f04f30ff          MOV      r0,#0xffffffff        ;956
001524  e75b              B        |L1.5086|
                  |L1.5414|
001526  2000              MOVS     r0,#0                 ;957
001528  f7fffffe          BL       mpu_configure_fifo
00152c  b110              CBZ      r0,|L1.5428|
00152e  f04f30ff          MOV      r0,#0xffffffff        ;958
001532  e754              B        |L1.5086|
                  |L1.5428|
001534  2000              MOVS     r0,#0                 ;969
001536  f7fffffe          BL       mpu_set_bypass
00153a  b110              CBZ      r0,|L1.5442|
00153c  f04f30ff          MOV      r0,#0xffffffff        ;970
001540  e74d              B        |L1.5086|
                  |L1.5442|
001542  2000              MOVS     r0,#0                 ;973
001544  f7fffffe          BL       mpu_set_sensors
001548  2000              MOVS     r0,#0                 ;974
00154a  e748              B        |L1.5086|
;;;976    
                          ENDP

                  mpu_get_gyro_reg PROC
;;;1075    */
;;;1076   int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
00154c  b57c              PUSH     {r2-r6,lr}
;;;1077   {
00154e  4604              MOV      r4,r0
001550  460d              MOV      r5,r1
;;;1078       unsigned char tmp[6];
;;;1079   
;;;1080       if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
001552  48ad              LDR      r0,|L1.6152|
001554  7a80              LDRB     r0,[r0,#0xa]
001556  f0000070          AND      r0,r0,#0x70
00155a  b910              CBNZ     r0,|L1.5474|
;;;1081           return -1;
00155c  f04f30ff          MOV      r0,#0xffffffff
                  |L1.5472|
;;;1082   
;;;1083       if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
;;;1084           return -1;
;;;1085       data[0] = (tmp[0] << 8) | tmp[1];
;;;1086       data[1] = (tmp[2] << 8) | tmp[3];
;;;1087       data[2] = (tmp[4] << 8) | tmp[5];
;;;1088   //    if (timestamp)
;;;1089   //        get_ms(timestamp);
;;;1090       return 0;
;;;1091   }
001560  bd7c              POP      {r2-r6,pc}
                  |L1.5474|
001562  4aa9              LDR      r2,|L1.6152|
001564  6812              LDR      r2,[r2,#0]            ;1083  ; st
001566  7b11              LDRB     r1,[r2,#0xc]          ;1083
001568  4aa7              LDR      r2,|L1.6152|
00156a  6852              LDR      r2,[r2,#4]            ;1083  ; st
00156c  7810              LDRB     r0,[r2,#0]            ;1083
00156e  466b              MOV      r3,sp                 ;1083
001570  2206              MOVS     r2,#6                 ;1083
001572  f7fffffe          BL       I2C_Read
001576  b110              CBZ      r0,|L1.5502|
001578  f04f30ff          MOV      r0,#0xffffffff        ;1084
00157c  e7f0              B        |L1.5472|
                  |L1.5502|
00157e  f89d0001          LDRB     r0,[sp,#1]            ;1085
001582  f89d1000          LDRB     r1,[sp,#0]            ;1085
001586  ea402001          ORR      r0,r0,r1,LSL #8       ;1085
00158a  b200              SXTH     r0,r0                 ;1085
00158c  8020              STRH     r0,[r4,#0]            ;1085
00158e  f89d0003          LDRB     r0,[sp,#3]            ;1086
001592  f89d1002          LDRB     r1,[sp,#2]            ;1086
001596  ea402001          ORR      r0,r0,r1,LSL #8       ;1086
00159a  b200              SXTH     r0,r0                 ;1086
00159c  8060              STRH     r0,[r4,#2]            ;1086
00159e  f89d0005          LDRB     r0,[sp,#5]            ;1087
0015a2  f89d1004          LDRB     r1,[sp,#4]            ;1087
0015a6  ea402001          ORR      r0,r0,r1,LSL #8       ;1087
0015aa  b200              SXTH     r0,r0                 ;1087
0015ac  80a0              STRH     r0,[r4,#4]            ;1087
0015ae  2000              MOVS     r0,#0                 ;1090
0015b0  e7d6              B        |L1.5472|
;;;1092   
                          ENDP

                  mpu_get_accel_reg PROC
;;;1098    */
;;;1099   int mpu_get_accel_reg(short *data, unsigned long *timestamp)
0015b2  b57c              PUSH     {r2-r6,lr}
;;;1100   {
0015b4  4604              MOV      r4,r0
0015b6  460d              MOV      r5,r1
;;;1101       unsigned char tmp[6];
;;;1102   
;;;1103       if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
0015b8  4893              LDR      r0,|L1.6152|
0015ba  7a80              LDRB     r0,[r0,#0xa]
0015bc  f0000008          AND      r0,r0,#8
0015c0  b910              CBNZ     r0,|L1.5576|
;;;1104           return -1;
0015c2  f04f30ff          MOV      r0,#0xffffffff
                  |L1.5574|
;;;1105   
;;;1106       if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
;;;1107           return -1;
;;;1108       data[0] = (tmp[0] << 8) | tmp[1];
;;;1109       data[1] = (tmp[2] << 8) | tmp[3];
;;;1110       data[2] = (tmp[4] << 8) | tmp[5];
;;;1111       if (timestamp)
;;;1112           get_ms(timestamp);
;;;1113       return 0;
;;;1114   }
0015c6  bd7c              POP      {r2-r6,pc}
                  |L1.5576|
0015c8  4a8f              LDR      r2,|L1.6152|
0015ca  6812              LDR      r2,[r2,#0]            ;1106  ; st
0015cc  7b51              LDRB     r1,[r2,#0xd]          ;1106
0015ce  4a8e              LDR      r2,|L1.6152|
0015d0  6852              LDR      r2,[r2,#4]            ;1106  ; st
0015d2  7810              LDRB     r0,[r2,#0]            ;1106
0015d4  466b              MOV      r3,sp                 ;1106
0015d6  2206              MOVS     r2,#6                 ;1106
0015d8  f7fffffe          BL       I2C_Read
0015dc  b110              CBZ      r0,|L1.5604|
0015de  f04f30ff          MOV      r0,#0xffffffff        ;1107
0015e2  e7f0              B        |L1.5574|
                  |L1.5604|
0015e4  f89d0001          LDRB     r0,[sp,#1]            ;1108
0015e8  f89d1000          LDRB     r1,[sp,#0]            ;1108
0015ec  ea402001          ORR      r0,r0,r1,LSL #8       ;1108
0015f0  b200              SXTH     r0,r0                 ;1108
0015f2  8020              STRH     r0,[r4,#0]            ;1108
0015f4  f89d0003          LDRB     r0,[sp,#3]            ;1109
0015f8  f89d1002          LDRB     r1,[sp,#2]            ;1109
0015fc  ea402001          ORR      r0,r0,r1,LSL #8       ;1109
001600  b200              SXTH     r0,r0                 ;1109
001602  8060              STRH     r0,[r4,#2]            ;1109
001604  f89d0005          LDRB     r0,[sp,#5]            ;1110
001608  f89d1004          LDRB     r1,[sp,#4]            ;1110
00160c  ea402001          ORR      r0,r0,r1,LSL #8       ;1110
001610  b200              SXTH     r0,r0                 ;1110
001612  80a0              STRH     r0,[r4,#4]            ;1110
001614  b115              CBZ      r5,|L1.5660|
001616  4628              MOV      r0,r5                 ;1112
001618  f7fffffe          BL       get_ms
                  |L1.5660|
00161c  2000              MOVS     r0,#0                 ;1113
00161e  e7d2              B        |L1.5574|
;;;1115   
                          ENDP

                  mpu_get_temperature PROC
;;;1121    */
;;;1122   int mpu_get_temperature(long *data, unsigned long *timestamp)
001620  e92d4ffe          PUSH     {r1-r11,lr}
;;;1123   {
001624  4605              MOV      r5,r0
001626  460c              MOV      r4,r1
;;;1124       unsigned char tmp[2];
;;;1125       short raw;
;;;1126   
;;;1127       if (!(st.chip_cfg.sensors))
001628  4877              LDR      r0,|L1.6152|
00162a  7a80              LDRB     r0,[r0,#0xa]
00162c  b918              CBNZ     r0,|L1.5686|
;;;1128           return -1;
00162e  f04f30ff          MOV      r0,#0xffffffff
                  |L1.5682|
;;;1129   
;;;1130       if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
;;;1131           return -1;
;;;1132       raw = (tmp[0] << 8) | tmp[1];
;;;1133       if (timestamp)
;;;1134           get_ms(timestamp);
;;;1135   
;;;1136       data[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
;;;1137       return 0;
;;;1138   }
001632  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.5686|
001636  4a74              LDR      r2,|L1.6152|
001638  6812              LDR      r2,[r2,#0]            ;1130  ; st
00163a  7b91              LDRB     r1,[r2,#0xe]          ;1130
00163c  4a72              LDR      r2,|L1.6152|
00163e  6852              LDR      r2,[r2,#4]            ;1130  ; st
001640  7810              LDRB     r0,[r2,#0]            ;1130
001642  ab02              ADD      r3,sp,#8              ;1130
001644  2202              MOVS     r2,#2                 ;1130
001646  f7fffffe          BL       I2C_Read
00164a  b110              CBZ      r0,|L1.5714|
00164c  f04f30ff          MOV      r0,#0xffffffff        ;1131
001650  e7ef              B        |L1.5682|
                  |L1.5714|
001652  f89d0009          LDRB     r0,[sp,#9]            ;1132
001656  f89d1008          LDRB     r1,[sp,#8]            ;1132
00165a  ea402001          ORR      r0,r0,r1,LSL #8       ;1132
00165e  b206              SXTH     r6,r0                 ;1132
001660  b114              CBZ      r4,|L1.5736|
001662  4620              MOV      r0,r4                 ;1134
001664  f7fffffe          BL       get_ms
                  |L1.5736|
001668  4967              LDR      r1,|L1.6152|
00166a  6849              LDR      r1,[r1,#4]            ;1136  ; st
00166c  88c8              LDRH     r0,[r1,#6]            ;1136
00166e  f7fffffe          BL       __aeabi_ui2f
001672  4965              LDR      r1,|L1.6152|
001674  9001              STR      r0,[sp,#4]            ;1136
001676  6849              LDR      r1,[r1,#4]            ;1136  ; st
001678  f9b10008          LDRSH    r0,[r1,#8]            ;1136
00167c  f7fffffe          BL       __aeabi_i2f
001680  4683              MOV      r11,r0                ;1136
001682  4630              MOV      r0,r6                 ;1136
001684  f7fffffe          BL       __aeabi_i2f
001688  4659              MOV      r1,r11                ;1136
00168a  9000              STR      r0,[sp,#0]            ;1136
00168c  f7fffffe          BL       __aeabi_fsub
001690  4682              MOV      r10,r0                ;1136
001692  9901              LDR      r1,[sp,#4]            ;1136
001694  f7fffffe          BL       __aeabi_fdiv
001698  4681              MOV      r9,r0                 ;1136
00169a  495c              LDR      r1,|L1.6156|
00169c  f7fffffe          BL       __aeabi_fadd
0016a0  4680              MOV      r8,r0                 ;1136
0016a2  f04f418f          MOV      r1,#0x47800000        ;1136
0016a6  f7fffffe          BL       __aeabi_fmul
0016aa  4607              MOV      r7,r0                 ;1136
0016ac  f7fffffe          BL       __aeabi_f2iz
0016b0  6028              STR      r0,[r5,#0]            ;1136
0016b2  2000              MOVS     r0,#0                 ;1137
0016b4  e7bd              B        |L1.5682|
;;;1139   
                          ENDP

                  mpu_set_accel_bias PROC
;;;1146    */
;;;1147   int mpu_set_accel_bias(const long *accel_bias)
0016b6  b510              PUSH     {r4,lr}
;;;1148   {
0016b8  b088              SUB      sp,sp,#0x20
0016ba  4604              MOV      r4,r0
;;;1149       unsigned char data[6];
;;;1150       short accel_hw[3];
;;;1151       short got_accel[3];
;;;1152       short fg[3];
;;;1153   
;;;1154       if (!accel_bias)
0016bc  b91c              CBNZ     r4,|L1.5830|
;;;1155           return -1;
0016be  f04f30ff          MOV      r0,#0xffffffff
                  |L1.5826|
;;;1156       if (!accel_bias[0] && !accel_bias[1] && !accel_bias[2])
;;;1157           return 0;
;;;1158   
;;;1159       if (i2c_read(st.hw->addr, 3, 3, data))
;;;1160           return -1;
;;;1161       fg[0] = ((data[0] >> 4) + 8) & 0xf;
;;;1162       fg[1] = ((data[1] >> 4) + 8) & 0xf;
;;;1163       fg[2] = ((data[2] >> 4) + 8) & 0xf;
;;;1164   
;;;1165       accel_hw[0] = (short)(accel_bias[0] * 2 / (64 + fg[0]));
;;;1166       accel_hw[1] = (short)(accel_bias[1] * 2 / (64 + fg[1]));
;;;1167       accel_hw[2] = (short)(accel_bias[2] * 2 / (64 + fg[2]));
;;;1168   
;;;1169       if (i2c_read(st.hw->addr, 0x06, 6, data))
;;;1170           return -1;
;;;1171   
;;;1172       got_accel[0] = ((short)data[0] << 8) | data[1];
;;;1173       got_accel[1] = ((short)data[2] << 8) | data[3];
;;;1174       got_accel[2] = ((short)data[4] << 8) | data[5];
;;;1175   
;;;1176       accel_hw[0] += got_accel[0];
;;;1177       accel_hw[1] += got_accel[1];
;;;1178       accel_hw[2] += got_accel[2];
;;;1179   
;;;1180       data[0] = (accel_hw[0] >> 8) & 0xff;
;;;1181       data[1] = (accel_hw[0]) & 0xff;
;;;1182       data[2] = (accel_hw[1] >> 8) & 0xff;
;;;1183       data[3] = (accel_hw[1]) & 0xff;
;;;1184       data[4] = (accel_hw[2] >> 8) & 0xff;
;;;1185       data[5] = (accel_hw[2]) & 0xff;
;;;1186   
;;;1187       if (i2c_write(st.hw->addr, 0x06, 6, data))
;;;1188           return -1;
;;;1189       return 0;
;;;1190   }
0016c2  b008              ADD      sp,sp,#0x20
0016c4  bd10              POP      {r4,pc}
                  |L1.5830|
0016c6  6820              LDR      r0,[r4,#0]            ;1156
0016c8  b928              CBNZ     r0,|L1.5846|
0016ca  6860              LDR      r0,[r4,#4]            ;1156
0016cc  b918              CBNZ     r0,|L1.5846|
0016ce  68a0              LDR      r0,[r4,#8]            ;1156
0016d0  b908              CBNZ     r0,|L1.5846|
0016d2  2000              MOVS     r0,#0                 ;1157
0016d4  e7f5              B        |L1.5826|
                  |L1.5846|
0016d6  494c              LDR      r1,|L1.6152|
0016d8  6849              LDR      r1,[r1,#4]            ;1159  ; st
0016da  7808              LDRB     r0,[r1,#0]            ;1159
0016dc  ab06              ADD      r3,sp,#0x18           ;1159
0016de  2203              MOVS     r2,#3                 ;1159
0016e0  4611              MOV      r1,r2                 ;1159
0016e2  f7fffffe          BL       I2C_Read
0016e6  b110              CBZ      r0,|L1.5870|
0016e8  f04f30ff          MOV      r0,#0xffffffff        ;1160
0016ec  e7e9              B        |L1.5826|
                  |L1.5870|
0016ee  f89d0018          LDRB     r0,[sp,#0x18]         ;1161
0016f2  2108              MOVS     r1,#8                 ;1161
0016f4  eb011020          ADD      r0,r1,r0,ASR #4       ;1161
0016f8  f000000f          AND      r0,r0,#0xf            ;1161
0016fc  f8ad0000          STRH     r0,[sp,#0]            ;1161
001700  f89d0019          LDRB     r0,[sp,#0x19]         ;1162
001704  eb011020          ADD      r0,r1,r0,ASR #4       ;1162
001708  f000000f          AND      r0,r0,#0xf            ;1162
00170c  f8ad0002          STRH     r0,[sp,#2]            ;1162
001710  f89d001a          LDRB     r0,[sp,#0x1a]         ;1163
001714  eb011020          ADD      r0,r1,r0,ASR #4       ;1163
001718  f000000f          AND      r0,r0,#0xf            ;1163
00171c  f8ad0004          STRH     r0,[sp,#4]            ;1163
001720  6820              LDR      r0,[r4,#0]            ;1165
001722  0041              LSLS     r1,r0,#1              ;1165
001724  f9bd0000          LDRSH    r0,[sp,#0]            ;1165
001728  3040              ADDS     r0,r0,#0x40           ;1165
00172a  fb91f0f0          SDIV     r0,r1,r0              ;1165
00172e  b200              SXTH     r0,r0                 ;1165
001730  f8ad0010          STRH     r0,[sp,#0x10]         ;1165
001734  6860              LDR      r0,[r4,#4]            ;1166
001736  0041              LSLS     r1,r0,#1              ;1166
001738  f9bd0002          LDRSH    r0,[sp,#2]            ;1166
00173c  3040              ADDS     r0,r0,#0x40           ;1166
00173e  fb91f0f0          SDIV     r0,r1,r0              ;1166
001742  b200              SXTH     r0,r0                 ;1166
001744  f8ad0012          STRH     r0,[sp,#0x12]         ;1166
001748  68a0              LDR      r0,[r4,#8]            ;1167
00174a  0041              LSLS     r1,r0,#1              ;1167
00174c  f9bd0004          LDRSH    r0,[sp,#4]            ;1167
001750  3040              ADDS     r0,r0,#0x40           ;1167
001752  fb91f0f0          SDIV     r0,r1,r0              ;1167
001756  b200              SXTH     r0,r0                 ;1167
001758  f8ad0014          STRH     r0,[sp,#0x14]         ;1167
00175c  492a              LDR      r1,|L1.6152|
00175e  6849              LDR      r1,[r1,#4]            ;1169  ; st
001760  7808              LDRB     r0,[r1,#0]            ;1169
001762  ab06              ADD      r3,sp,#0x18           ;1169
001764  2206              MOVS     r2,#6                 ;1169
001766  4611              MOV      r1,r2                 ;1169
001768  f7fffffe          BL       I2C_Read
00176c  b110              CBZ      r0,|L1.6004|
00176e  f04f30ff          MOV      r0,#0xffffffff        ;1170
001772  e7a6              B        |L1.5826|
                  |L1.6004|
001774  f89d0019          LDRB     r0,[sp,#0x19]         ;1172
001778  f89d1018          LDRB     r1,[sp,#0x18]         ;1172
00177c  ea402001          ORR      r0,r0,r1,LSL #8       ;1172
001780  b200              SXTH     r0,r0                 ;1172
001782  f8ad0008          STRH     r0,[sp,#8]            ;1172
001786  f89d001b          LDRB     r0,[sp,#0x1b]         ;1173
00178a  f89d101a          LDRB     r1,[sp,#0x1a]         ;1173
00178e  ea402001          ORR      r0,r0,r1,LSL #8       ;1173
001792  b200              SXTH     r0,r0                 ;1173
001794  f8ad000a          STRH     r0,[sp,#0xa]          ;1173
001798  f89d001d          LDRB     r0,[sp,#0x1d]         ;1174
00179c  f89d101c          LDRB     r1,[sp,#0x1c]         ;1174
0017a0  ea402001          ORR      r0,r0,r1,LSL #8       ;1174
0017a4  b200              SXTH     r0,r0                 ;1174
0017a6  f8ad000c          STRH     r0,[sp,#0xc]          ;1174
0017aa  f8bd0010          LDRH     r0,[sp,#0x10]         ;1176
0017ae  f8bd1008          LDRH     r1,[sp,#8]            ;1176
0017b2  4408              ADD      r0,r0,r1              ;1176
0017b4  b200              SXTH     r0,r0                 ;1176
0017b6  f8ad0010          STRH     r0,[sp,#0x10]         ;1176
0017ba  f8bd0012          LDRH     r0,[sp,#0x12]         ;1177
0017be  f8bd100a          LDRH     r1,[sp,#0xa]          ;1177
0017c2  4408              ADD      r0,r0,r1              ;1177
0017c4  b200              SXTH     r0,r0                 ;1177
0017c6  f8ad0012          STRH     r0,[sp,#0x12]         ;1177
0017ca  f8bd0014          LDRH     r0,[sp,#0x14]         ;1178
0017ce  f8bd100c          LDRH     r1,[sp,#0xc]          ;1178
0017d2  4408              ADD      r0,r0,r1              ;1178
0017d4  b200              SXTH     r0,r0                 ;1178
0017d6  f8ad0014          STRH     r0,[sp,#0x14]         ;1178
0017da  f8bd0010          LDRH     r0,[sp,#0x10]         ;1180
0017de  0a00              LSRS     r0,r0,#8              ;1180
0017e0  f88d0018          STRB     r0,[sp,#0x18]         ;1180
0017e4  f8bd0010          LDRH     r0,[sp,#0x10]         ;1181
0017e8  b2c0              UXTB     r0,r0                 ;1181
0017ea  f88d0019          STRB     r0,[sp,#0x19]         ;1181
0017ee  f8bd0012          LDRH     r0,[sp,#0x12]         ;1182
0017f2  0a00              LSRS     r0,r0,#8              ;1182
0017f4  f88d001a          STRB     r0,[sp,#0x1a]         ;1182
0017f8  f8bd0012          LDRH     r0,[sp,#0x12]         ;1183
0017fc  b2c0              UXTB     r0,r0                 ;1183
0017fe  f88d001b          STRB     r0,[sp,#0x1b]         ;1183
001802  f8bd0014          LDRH     r0,[sp,#0x14]         ;1184
001806  e003              B        |L1.6160|
                  |L1.6152|
                          DCD      ||st||
                  |L1.6156|
                          DCD      0x420c0000
                  |L1.6160|
001810  0a00              LSRS     r0,r0,#8              ;1184
001812  f88d001c          STRB     r0,[sp,#0x1c]         ;1184
001816  f8bd0014          LDRH     r0,[sp,#0x14]         ;1185
00181a  b2c0              UXTB     r0,r0                 ;1185
00181c  f88d001d          STRB     r0,[sp,#0x1d]         ;1185
001820  49fd              LDR      r1,|L1.7192|
001822  6849              LDR      r1,[r1,#4]            ;1187  ; st
001824  7808              LDRB     r0,[r1,#0]            ;1187
001826  ab06              ADD      r3,sp,#0x18           ;1187
001828  2206              MOVS     r2,#6                 ;1187
00182a  4611              MOV      r1,r2                 ;1187
00182c  f7fffffe          BL       I2C_Write
001830  b110              CBZ      r0,|L1.6200|
001832  f04f30ff          MOV      r0,#0xffffffff        ;1188
001836  e744              B        |L1.5826|
                  |L1.6200|
001838  2000              MOVS     r0,#0                 ;1189
00183a  e742              B        |L1.5826|
;;;1191   
                          ENDP

                  mpu_get_compass_sample_rate PROC
;;;1517    */
;;;1518   int mpu_get_compass_sample_rate(unsigned short *rate)
00183c  4601              MOV      r1,r0
;;;1519   {
;;;1520   #ifdef AK89xx_SECONDARY
;;;1521       rate[0] = st.chip_cfg.compass_sample_rate;
;;;1522       return 0;
;;;1523   #else
;;;1524       rate[0] = 0;
00183e  2000              MOVS     r0,#0
001840  8008              STRH     r0,[r1,#0]
;;;1525       return -1;
001842  1e40              SUBS     r0,r0,#1
;;;1526   #endif
;;;1527   }
001844  4770              BX       lr
;;;1528   
                          ENDP

                  mpu_set_compass_sample_rate PROC
;;;1539    */
;;;1540   int mpu_set_compass_sample_rate(unsigned short rate)
001846  4601              MOV      r1,r0
;;;1541   {
;;;1542   #ifdef AK89xx_SECONDARY
;;;1543       unsigned char div;
;;;1544       if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
;;;1545           return -1;
;;;1546   
;;;1547       div = st.chip_cfg.sample_rate / rate - 1;
;;;1548       if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
;;;1549           return -1;
;;;1550       st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
;;;1551       return 0;
;;;1552   #else
;;;1553       return -1;
001848  f04f30ff          MOV      r0,#0xffffffff
;;;1554   #endif
;;;1555   }
00184c  4770              BX       lr
;;;1556   
                          ENDP

                  mpu_get_power_state PROC
;;;1676    */
;;;1677   int mpu_get_power_state(unsigned char *power_on)
00184e  4601              MOV      r1,r0
;;;1678   {
;;;1679       if (st.chip_cfg.sensors)
001850  48f1              LDR      r0,|L1.7192|
001852  7a80              LDRB     r0,[r0,#0xa]
001854  b110              CBZ      r0,|L1.6236|
;;;1680           power_on[0] = 1;
001856  2001              MOVS     r0,#1
001858  7008              STRB     r0,[r1,#0]
00185a  e001              B        |L1.6240|
                  |L1.6236|
;;;1681       else
;;;1682           power_on[0] = 0;
00185c  2000              MOVS     r0,#0
00185e  7008              STRB     r0,[r1,#0]
                  |L1.6240|
;;;1683       return 0;
001860  2000              MOVS     r0,#0
;;;1684   }
001862  4770              BX       lr
;;;1685   
                          ENDP

                  mpu_get_int_status PROC
;;;1772    */
;;;1773   int mpu_get_int_status(short *status)
001864  b538              PUSH     {r3-r5,lr}
;;;1774   {
001866  4604              MOV      r4,r0
;;;1775       unsigned char tmp[2];
;;;1776       if (!st.chip_cfg.sensors)
001868  48eb              LDR      r0,|L1.7192|
00186a  7a80              LDRB     r0,[r0,#0xa]
00186c  b910              CBNZ     r0,|L1.6260|
;;;1777           return -1;
00186e  f04f30ff          MOV      r0,#0xffffffff
                  |L1.6258|
;;;1778       if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
;;;1779           return -1;
;;;1780       status[0] = (tmp[0] << 8) | tmp[1];
;;;1781       return 0;
;;;1782   }
001872  bd38              POP      {r3-r5,pc}
                  |L1.6260|
001874  4ae8              LDR      r2,|L1.7192|
001876  6812              LDR      r2,[r2,#0]            ;1778  ; st
001878  7c11              LDRB     r1,[r2,#0x10]         ;1778
00187a  4ae7              LDR      r2,|L1.7192|
00187c  6852              LDR      r2,[r2,#4]            ;1778  ; st
00187e  7810              LDRB     r0,[r2,#0]            ;1778
001880  466b              MOV      r3,sp                 ;1778
001882  2202              MOVS     r2,#2                 ;1778
001884  f7fffffe          BL       I2C_Read
001888  b110              CBZ      r0,|L1.6288|
00188a  f04f30ff          MOV      r0,#0xffffffff        ;1779
00188e  e7f0              B        |L1.6258|
                  |L1.6288|
001890  f89d0001          LDRB     r0,[sp,#1]            ;1780
001894  f89d1000          LDRB     r1,[sp,#0]            ;1780
001898  ea402001          ORR      r0,r0,r1,LSL #8       ;1780
00189c  b200              SXTH     r0,r0                 ;1780
00189e  8020              STRH     r0,[r4,#0]            ;1780
0018a0  2000              MOVS     r0,#0                 ;1781
0018a2  e7e6              B        |L1.6258|
;;;1783   
                          ENDP

                  mpu_read_fifo PROC
;;;1801    */
;;;1802   int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
0018a4  e92d4ffe          PUSH     {r1-r11,lr}
;;;1803           unsigned char *sensors, unsigned char *more)
;;;1804   {
0018a8  4607              MOV      r7,r0
0018aa  4688              MOV      r8,r1
0018ac  4692              MOV      r10,r2
0018ae  461d              MOV      r5,r3
0018b0  f8ddb030          LDR      r11,[sp,#0x30]
;;;1805       /* Assumes maximum packet size is gyro (6) + accel (6). */
;;;1806       unsigned char data[MAX_PACKET_LENGTH];
;;;1807       unsigned char packet_size = 0;
0018b4  2600              MOVS     r6,#0
;;;1808       unsigned short fifo_count, index = 0;
0018b6  2400              MOVS     r4,#0
;;;1809   
;;;1810       if (st.chip_cfg.dmp_on)
0018b8  48d7              LDR      r0,|L1.7192|
0018ba  f8900024          LDRB     r0,[r0,#0x24]
0018be  b110              CBZ      r0,|L1.6342|
;;;1811           return -1;
0018c0  1e60              SUBS     r0,r4,#1
                  |L1.6338|
;;;1812   
;;;1813       sensors[0] = 0;
;;;1814       if (!st.chip_cfg.sensors)
;;;1815           return -1;
;;;1816       if (!st.chip_cfg.fifo_enable)
;;;1817           return -1;
;;;1818   
;;;1819       if (st.chip_cfg.fifo_enable & INV_X_GYRO)
;;;1820           packet_size += 2;
;;;1821       if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
;;;1822           packet_size += 2;
;;;1823       if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
;;;1824           packet_size += 2;
;;;1825       if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
;;;1826           packet_size += 6;
;;;1827   
;;;1828       if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
;;;1829           return -1;
;;;1830       fifo_count = (data[0] << 8) | data[1];
;;;1831       if (fifo_count < packet_size)
;;;1832           return 0;
;;;1833   //    log_i("FIFO count: %hd\n", fifo_count);
;;;1834       if (fifo_count > (st.hw->max_fifo >> 1)) {
;;;1835           /* FIFO is 50% full, better check overflow bit. */
;;;1836           if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
;;;1837               return -1;
;;;1838           if (data[0] & BIT_FIFO_OVERFLOW) {
;;;1839               mpu_reset_fifo();
;;;1840               return -2;
;;;1841           }
;;;1842       }
;;;1843       get_ms((unsigned long*)timestamp);
;;;1844   
;;;1845       if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
;;;1846           return -1;
;;;1847       more[0] = fifo_count / packet_size - 1;
;;;1848       sensors[0] = 0;
;;;1849   
;;;1850       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
;;;1851           accel[0] = (data[index+0] << 8) | data[index+1];
;;;1852           accel[1] = (data[index+2] << 8) | data[index+3];
;;;1853           accel[2] = (data[index+4] << 8) | data[index+5];
;;;1854           sensors[0] |= INV_XYZ_ACCEL;
;;;1855           index += 6;
;;;1856       }
;;;1857       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
;;;1858           gyro[0] = (data[index+0] << 8) | data[index+1];
;;;1859           sensors[0] |= INV_X_GYRO;
;;;1860           index += 2;
;;;1861       }
;;;1862       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
;;;1863           gyro[1] = (data[index+0] << 8) | data[index+1];
;;;1864           sensors[0] |= INV_Y_GYRO;
;;;1865           index += 2;
;;;1866       }
;;;1867       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
;;;1868           gyro[2] = (data[index+0] << 8) | data[index+1];
;;;1869           sensors[0] |= INV_Z_GYRO;
;;;1870           index += 2;
;;;1871       }
;;;1872   
;;;1873       return 0;
;;;1874   }
0018c2  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.6342|
0018c6  2000              MOVS     r0,#0                 ;1813
0018c8  7028              STRB     r0,[r5,#0]            ;1813
0018ca  48d3              LDR      r0,|L1.7192|
0018cc  7a80              LDRB     r0,[r0,#0xa]          ;1814
0018ce  b910              CBNZ     r0,|L1.6358|
0018d0  f04f30ff          MOV      r0,#0xffffffff        ;1815
0018d4  e7f5              B        |L1.6338|
                  |L1.6358|
0018d6  48d0              LDR      r0,|L1.7192|
0018d8  7c00              LDRB     r0,[r0,#0x10]         ;1816
0018da  b910              CBNZ     r0,|L1.6370|
0018dc  f04f30ff          MOV      r0,#0xffffffff        ;1817
0018e0  e7ef              B        |L1.6338|
                  |L1.6370|
0018e2  48cd              LDR      r0,|L1.7192|
0018e4  7c00              LDRB     r0,[r0,#0x10]         ;1819
0018e6  f0000040          AND      r0,r0,#0x40           ;1819
0018ea  b108              CBZ      r0,|L1.6384|
0018ec  1cb0              ADDS     r0,r6,#2              ;1820
0018ee  b2c6              UXTB     r6,r0                 ;1820
                  |L1.6384|
0018f0  48c9              LDR      r0,|L1.7192|
0018f2  7c00              LDRB     r0,[r0,#0x10]         ;1821
0018f4  f0000020          AND      r0,r0,#0x20           ;1821
0018f8  b108              CBZ      r0,|L1.6398|
0018fa  1cb0              ADDS     r0,r6,#2              ;1822
0018fc  b2c6              UXTB     r6,r0                 ;1822
                  |L1.6398|
0018fe  48c6              LDR      r0,|L1.7192|
001900  7c00              LDRB     r0,[r0,#0x10]         ;1823
001902  f0000010          AND      r0,r0,#0x10           ;1823
001906  b108              CBZ      r0,|L1.6412|
001908  1cb0              ADDS     r0,r6,#2              ;1824
00190a  b2c6              UXTB     r6,r0                 ;1824
                  |L1.6412|
00190c  48c2              LDR      r0,|L1.7192|
00190e  7c00              LDRB     r0,[r0,#0x10]         ;1825
001910  f0000008          AND      r0,r0,#8              ;1825
001914  b108              CBZ      r0,|L1.6426|
001916  1db0              ADDS     r0,r6,#6              ;1826
001918  b2c6              UXTB     r6,r0                 ;1826
                  |L1.6426|
00191a  4abf              LDR      r2,|L1.7192|
00191c  6812              LDR      r2,[r2,#0]            ;1828  ; st
00191e  7a91              LDRB     r1,[r2,#0xa]          ;1828
001920  4abd              LDR      r2,|L1.7192|
001922  6852              LDR      r2,[r2,#4]            ;1828  ; st
001924  7810              LDRB     r0,[r2,#0]            ;1828
001926  466b              MOV      r3,sp                 ;1828
001928  2202              MOVS     r2,#2                 ;1828
00192a  f7fffffe          BL       I2C_Read
00192e  b110              CBZ      r0,|L1.6454|
001930  f04f30ff          MOV      r0,#0xffffffff        ;1829
001934  e7c5              B        |L1.6338|
                  |L1.6454|
001936  f89d0001          LDRB     r0,[sp,#1]            ;1830
00193a  f89d1000          LDRB     r1,[sp,#0]            ;1830
00193e  ea402901          ORR      r9,r0,r1,LSL #8       ;1830
001942  45b1              CMP      r9,r6                 ;1831
001944  da01              BGE      |L1.6474|
001946  2000              MOVS     r0,#0                 ;1832
001948  e7bb              B        |L1.6338|
                  |L1.6474|
00194a  48b3              LDR      r0,|L1.7192|
00194c  6840              LDR      r0,[r0,#4]            ;1834  ; st
00194e  8840              LDRH     r0,[r0,#2]            ;1834
001950  ebb90f60          CMP      r9,r0,ASR #1          ;1834
001954  dd17              BLE      |L1.6534|
001956  4ab0              LDR      r2,|L1.7192|
001958  6812              LDR      r2,[r2,#0]            ;1836  ; st
00195a  7c51              LDRB     r1,[r2,#0x11]         ;1836
00195c  4aae              LDR      r2,|L1.7192|
00195e  6852              LDR      r2,[r2,#4]            ;1836  ; st
001960  7810              LDRB     r0,[r2,#0]            ;1836
001962  466b              MOV      r3,sp                 ;1836
001964  2201              MOVS     r2,#1                 ;1836
001966  f7fffffe          BL       I2C_Read
00196a  b110              CBZ      r0,|L1.6514|
00196c  f04f30ff          MOV      r0,#0xffffffff        ;1837
001970  e7a7              B        |L1.6338|
                  |L1.6514|
001972  f89d0000          LDRB     r0,[sp,#0]            ;1838
001976  f0000010          AND      r0,r0,#0x10           ;1838
00197a  b120              CBZ      r0,|L1.6534|
00197c  f7fffffe          BL       mpu_reset_fifo
001980  f06f0001          MVN      r0,#1                 ;1840
001984  e79d              B        |L1.6338|
                  |L1.6534|
001986  4650              MOV      r0,r10                ;1843
001988  f7fffffe          BL       get_ms
00198c  4aa2              LDR      r2,|L1.7192|
00198e  6812              LDR      r2,[r2,#0]            ;1845  ; st
001990  7ad1              LDRB     r1,[r2,#0xb]          ;1845
001992  4aa1              LDR      r2,|L1.7192|
001994  6852              LDR      r2,[r2,#4]            ;1845  ; st
001996  7810              LDRB     r0,[r2,#0]            ;1845
001998  466b              MOV      r3,sp                 ;1845
00199a  4632              MOV      r2,r6                 ;1845
00199c  f7fffffe          BL       I2C_Read
0019a0  b110              CBZ      r0,|L1.6568|
0019a2  f04f30ff          MOV      r0,#0xffffffff        ;1846
0019a6  e78c              B        |L1.6338|
                  |L1.6568|
0019a8  fb99f0f6          SDIV     r0,r9,r6              ;1847
0019ac  1e40              SUBS     r0,r0,#1              ;1847
0019ae  f88b0000          STRB     r0,[r11,#0]           ;1847
0019b2  2000              MOVS     r0,#0                 ;1848
0019b4  7028              STRB     r0,[r5,#0]            ;1848
0019b6  42b4              CMP      r4,r6                 ;1850
0019b8  d02a              BEQ      |L1.6672|
0019ba  4897              LDR      r0,|L1.7192|
0019bc  7c00              LDRB     r0,[r0,#0x10]         ;1850
0019be  f0000008          AND      r0,r0,#8              ;1850
0019c2  b328              CBZ      r0,|L1.6672|
0019c4  1c60              ADDS     r0,r4,#1              ;1851
0019c6  f81d0000          LDRB     r0,[sp,r0]            ;1851
0019ca  f81d1004          LDRB     r1,[sp,r4]            ;1851
0019ce  ea402001          ORR      r0,r0,r1,LSL #8       ;1851
0019d2  b200              SXTH     r0,r0                 ;1851
0019d4  f8a80000          STRH     r0,[r8,#0]            ;1851
0019d8  1ce0              ADDS     r0,r4,#3              ;1852
0019da  f81d1000          LDRB     r1,[sp,r0]            ;1852
0019de  1ca0              ADDS     r0,r4,#2              ;1852
0019e0  f81d0000          LDRB     r0,[sp,r0]            ;1852
0019e4  ea412000          ORR      r0,r1,r0,LSL #8       ;1852
0019e8  b200              SXTH     r0,r0                 ;1852
0019ea  f8a80002          STRH     r0,[r8,#2]            ;1852
0019ee  1d60              ADDS     r0,r4,#5              ;1853
0019f0  f81d1000          LDRB     r1,[sp,r0]            ;1853
0019f4  1d20              ADDS     r0,r4,#4              ;1853
0019f6  f81d0000          LDRB     r0,[sp,r0]            ;1853
0019fa  ea412000          ORR      r0,r1,r0,LSL #8       ;1853
0019fe  b200              SXTH     r0,r0                 ;1853
001a00  f8a80004          STRH     r0,[r8,#4]            ;1853
001a04  7828              LDRB     r0,[r5,#0]            ;1854
001a06  f0400008          ORR      r0,r0,#8              ;1854
001a0a  7028              STRB     r0,[r5,#0]            ;1854
001a0c  1da0              ADDS     r0,r4,#6              ;1855
001a0e  b284              UXTH     r4,r0                 ;1855
                  |L1.6672|
001a10  42b4              CMP      r4,r6                 ;1857
001a12  d013              BEQ      |L1.6716|
001a14  4880              LDR      r0,|L1.7192|
001a16  7c00              LDRB     r0,[r0,#0x10]         ;1857
001a18  f0000040          AND      r0,r0,#0x40           ;1857
001a1c  b170              CBZ      r0,|L1.6716|
001a1e  1c60              ADDS     r0,r4,#1              ;1858
001a20  f81d0000          LDRB     r0,[sp,r0]            ;1858
001a24  f81d1004          LDRB     r1,[sp,r4]            ;1858
001a28  ea402001          ORR      r0,r0,r1,LSL #8       ;1858
001a2c  b200              SXTH     r0,r0                 ;1858
001a2e  8038              STRH     r0,[r7,#0]            ;1858
001a30  7828              LDRB     r0,[r5,#0]            ;1859
001a32  f0400040          ORR      r0,r0,#0x40           ;1859
001a36  7028              STRB     r0,[r5,#0]            ;1859
001a38  1ca0              ADDS     r0,r4,#2              ;1860
001a3a  b284              UXTH     r4,r0                 ;1860
                  |L1.6716|
001a3c  42b4              CMP      r4,r6                 ;1862
001a3e  d013              BEQ      |L1.6760|
001a40  4875              LDR      r0,|L1.7192|
001a42  7c00              LDRB     r0,[r0,#0x10]         ;1862
001a44  f0000020          AND      r0,r0,#0x20           ;1862
001a48  b170              CBZ      r0,|L1.6760|
001a4a  1c60              ADDS     r0,r4,#1              ;1863
001a4c  f81d0000          LDRB     r0,[sp,r0]            ;1863
001a50  f81d1004          LDRB     r1,[sp,r4]            ;1863
001a54  ea402001          ORR      r0,r0,r1,LSL #8       ;1863
001a58  b200              SXTH     r0,r0                 ;1863
001a5a  8078              STRH     r0,[r7,#2]            ;1863
001a5c  7828              LDRB     r0,[r5,#0]            ;1864
001a5e  f0400020          ORR      r0,r0,#0x20           ;1864
001a62  7028              STRB     r0,[r5,#0]            ;1864
001a64  1ca0              ADDS     r0,r4,#2              ;1865
001a66  b284              UXTH     r4,r0                 ;1865
                  |L1.6760|
001a68  42b4              CMP      r4,r6                 ;1867
001a6a  d013              BEQ      |L1.6804|
001a6c  486a              LDR      r0,|L1.7192|
001a6e  7c00              LDRB     r0,[r0,#0x10]         ;1867
001a70  f0000010          AND      r0,r0,#0x10           ;1867
001a74  b170              CBZ      r0,|L1.6804|
001a76  1c60              ADDS     r0,r4,#1              ;1868
001a78  f81d0000          LDRB     r0,[sp,r0]            ;1868
001a7c  f81d1004          LDRB     r1,[sp,r4]            ;1868
001a80  ea402001          ORR      r0,r0,r1,LSL #8       ;1868
001a84  b200              SXTH     r0,r0                 ;1868
001a86  80b8              STRH     r0,[r7,#4]            ;1868
001a88  7828              LDRB     r0,[r5,#0]            ;1869
001a8a  f0400010          ORR      r0,r0,#0x10           ;1869
001a8e  7028              STRB     r0,[r5,#0]            ;1869
001a90  1ca0              ADDS     r0,r4,#2              ;1870
001a92  b284              UXTH     r4,r0                 ;1870
                  |L1.6804|
001a94  2000              MOVS     r0,#0                 ;1873
001a96  e714              B        |L1.6338|
;;;1875   
                          ENDP

                  mpu_read_fifo_stream PROC
;;;1882    */
;;;1883   int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
001a98  b5f8              PUSH     {r3-r7,lr}
;;;1884       unsigned char *more)
;;;1885   {
001a9a  4604              MOV      r4,r0
001a9c  460f              MOV      r7,r1
001a9e  4616              MOV      r6,r2
;;;1886       unsigned char tmp[2];
;;;1887       unsigned short fifo_count;
;;;1888       if (!st.chip_cfg.dmp_on)
001aa0  485d              LDR      r0,|L1.7192|
001aa2  f8900024          LDRB     r0,[r0,#0x24]
001aa6  b910              CBNZ     r0,|L1.6830|
;;;1889           return -1;
001aa8  f04f30ff          MOV      r0,#0xffffffff
                  |L1.6828|
;;;1890       if (!st.chip_cfg.sensors)
;;;1891           return -1;
;;;1892   
;;;1893       if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
;;;1894           return -1;
;;;1895       fifo_count = (tmp[0] << 8) | tmp[1];
;;;1896       if (fifo_count < length) {
;;;1897           more[0] = 0;
;;;1898           return -1;
;;;1899       }
;;;1900       if (fifo_count > (st.hw->max_fifo >> 1)) {
;;;1901           /* FIFO is 50% full, better check overflow bit. */
;;;1902           if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
;;;1903               return -1;
;;;1904           if (tmp[0] & BIT_FIFO_OVERFLOW) {
;;;1905               mpu_reset_fifo();
;;;1906               return -2;
;;;1907           }
;;;1908       }
;;;1909   
;;;1910       if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
;;;1911           return -1;
;;;1912       more[0] = fifo_count / length - 1;
;;;1913       return 0;
;;;1914   }
001aac  bdf8              POP      {r3-r7,pc}
                  |L1.6830|
001aae  485a              LDR      r0,|L1.7192|
001ab0  7a80              LDRB     r0,[r0,#0xa]          ;1890
001ab2  b910              CBNZ     r0,|L1.6842|
001ab4  f04f30ff          MOV      r0,#0xffffffff        ;1891
001ab8  e7f8              B        |L1.6828|
                  |L1.6842|
001aba  4a57              LDR      r2,|L1.7192|
001abc  6812              LDR      r2,[r2,#0]            ;1893  ; st
001abe  7a91              LDRB     r1,[r2,#0xa]          ;1893
001ac0  4a55              LDR      r2,|L1.7192|
001ac2  6852              LDR      r2,[r2,#4]            ;1893  ; st
001ac4  7810              LDRB     r0,[r2,#0]            ;1893
001ac6  466b              MOV      r3,sp                 ;1893
001ac8  2202              MOVS     r2,#2                 ;1893
001aca  f7fffffe          BL       I2C_Read
001ace  b110              CBZ      r0,|L1.6870|
001ad0  f04f30ff          MOV      r0,#0xffffffff        ;1894
001ad4  e7ea              B        |L1.6828|
                  |L1.6870|
001ad6  f89d0001          LDRB     r0,[sp,#1]            ;1895
001ada  f89d1000          LDRB     r1,[sp,#0]            ;1895
001ade  ea402501          ORR      r5,r0,r1,LSL #8       ;1895
001ae2  42a5              CMP      r5,r4                 ;1896
001ae4  da03              BGE      |L1.6894|
001ae6  2000              MOVS     r0,#0                 ;1897
001ae8  7030              STRB     r0,[r6,#0]            ;1897
001aea  1e40              SUBS     r0,r0,#1              ;1898
001aec  e7de              B        |L1.6828|
                  |L1.6894|
001aee  484a              LDR      r0,|L1.7192|
001af0  6840              LDR      r0,[r0,#4]            ;1900  ; st
001af2  8840              LDRH     r0,[r0,#2]            ;1900
001af4  ebb50f60          CMP      r5,r0,ASR #1          ;1900
001af8  dd17              BLE      |L1.6954|
001afa  4a47              LDR      r2,|L1.7192|
001afc  6812              LDR      r2,[r2,#0]            ;1902  ; st
001afe  7c51              LDRB     r1,[r2,#0x11]         ;1902
001b00  4a45              LDR      r2,|L1.7192|
001b02  6852              LDR      r2,[r2,#4]            ;1902  ; st
001b04  7810              LDRB     r0,[r2,#0]            ;1902
001b06  466b              MOV      r3,sp                 ;1902
001b08  2201              MOVS     r2,#1                 ;1902
001b0a  f7fffffe          BL       I2C_Read
001b0e  b110              CBZ      r0,|L1.6934|
001b10  f04f30ff          MOV      r0,#0xffffffff        ;1903
001b14  e7ca              B        |L1.6828|
                  |L1.6934|
001b16  f89d0000          LDRB     r0,[sp,#0]            ;1904
001b1a  f0000010          AND      r0,r0,#0x10           ;1904
001b1e  b120              CBZ      r0,|L1.6954|
001b20  f7fffffe          BL       mpu_reset_fifo
001b24  f06f0001          MVN      r0,#1                 ;1906
001b28  e7c0              B        |L1.6828|
                  |L1.6954|
001b2a  b2e2              UXTB     r2,r4                 ;1910
001b2c  4b3a              LDR      r3,|L1.7192|
001b2e  681b              LDR      r3,[r3,#0]            ;1910  ; st
001b30  7ad9              LDRB     r1,[r3,#0xb]          ;1910
001b32  4b39              LDR      r3,|L1.7192|
001b34  685b              LDR      r3,[r3,#4]            ;1910  ; st
001b36  7818              LDRB     r0,[r3,#0]            ;1910
001b38  463b              MOV      r3,r7                 ;1910
001b3a  f7fffffe          BL       I2C_Read
001b3e  b110              CBZ      r0,|L1.6982|
001b40  f04f30ff          MOV      r0,#0xffffffff        ;1911
001b44  e7b2              B        |L1.6828|
                  |L1.6982|
001b46  fb95f0f4          SDIV     r0,r5,r4              ;1912
001b4a  1e40              SUBS     r0,r0,#1              ;1912
001b4c  7030              STRB     r0,[r6,#0]            ;1912
001b4e  2000              MOVS     r0,#0                 ;1913
001b50  e7ac              B        |L1.6828|
;;;1915   
                          ENDP

                  mpu_set_int_level PROC
;;;1970    */
;;;1971   int mpu_set_int_level(unsigned char active_low)
001b52  4601              MOV      r1,r0
;;;1972   {
;;;1973       st.chip_cfg.active_low_int = active_low;
001b54  4830              LDR      r0,|L1.7192|
001b56  f8801022          STRB     r1,[r0,#0x22]
;;;1974       return 0;
001b5a  2000              MOVS     r0,#0
;;;1975   }
001b5c  4770              BX       lr
;;;1976   
                          ENDP

                  mpu_write_mem PROC
;;;2374    */
;;;2375   int mpu_write_mem(unsigned short mem_addr, unsigned short length,
001b5e  b5f8              PUSH     {r3-r7,lr}
;;;2376           unsigned char *data)
;;;2377   {
001b60  4604              MOV      r4,r0
001b62  460d              MOV      r5,r1
001b64  4616              MOV      r6,r2
;;;2378       unsigned char tmp[2];
;;;2379   
;;;2380       if (!data)
001b66  b916              CBNZ     r6,|L1.7022|
;;;2381           return -1;
001b68  f04f30ff          MOV      r0,#0xffffffff
                  |L1.7020|
;;;2382       if (!st.chip_cfg.sensors)
;;;2383           return -1;
;;;2384   
;;;2385       tmp[0] = (unsigned char)(mem_addr >> 8);
;;;2386       tmp[1] = (unsigned char)(mem_addr & 0xFF);
;;;2387   
;;;2388       /* Check bank boundaries. */
;;;2389       if (tmp[1] + length > st.hw->bank_size)
;;;2390           return -1;
;;;2391   
;;;2392       if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
;;;2393           return -1;
;;;2394       if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
;;;2395           return -1;
;;;2396       return 0;
;;;2397   }
001b6c  bdf8              POP      {r3-r7,pc}
                  |L1.7022|
001b6e  482a              LDR      r0,|L1.7192|
001b70  7a80              LDRB     r0,[r0,#0xa]          ;2382
001b72  b910              CBNZ     r0,|L1.7034|
001b74  f04f30ff          MOV      r0,#0xffffffff        ;2383
001b78  e7f8              B        |L1.7020|
                  |L1.7034|
001b7a  1220              ASRS     r0,r4,#8              ;2385
001b7c  f88d0000          STRB     r0,[sp,#0]            ;2385
001b80  b2e0              UXTB     r0,r4                 ;2386
001b82  f88d0001          STRB     r0,[sp,#1]            ;2386
001b86  f89d0001          LDRB     r0,[sp,#1]            ;2389
001b8a  4428              ADD      r0,r0,r5              ;2389
001b8c  4922              LDR      r1,|L1.7192|
001b8e  6849              LDR      r1,[r1,#4]            ;2389  ; st
001b90  8949              LDRH     r1,[r1,#0xa]          ;2389
001b92  4288              CMP      r0,r1                 ;2389
001b94  dd02              BLE      |L1.7068|
001b96  f04f30ff          MOV      r0,#0xffffffff        ;2390
001b9a  e7e7              B        |L1.7020|
                  |L1.7068|
001b9c  4a1e              LDR      r2,|L1.7192|
001b9e  6812              LDR      r2,[r2,#0]            ;2392  ; st
001ba0  7e11              LDRB     r1,[r2,#0x18]         ;2392
001ba2  4a1d              LDR      r2,|L1.7192|
001ba4  6852              LDR      r2,[r2,#4]            ;2392  ; st
001ba6  7810              LDRB     r0,[r2,#0]            ;2392
001ba8  466b              MOV      r3,sp                 ;2392
001baa  2202              MOVS     r2,#2                 ;2392
001bac  f7fffffe          BL       I2C_Write
001bb0  b110              CBZ      r0,|L1.7096|
001bb2  f04f30ff          MOV      r0,#0xffffffff        ;2393
001bb6  e7d9              B        |L1.7020|
                  |L1.7096|
001bb8  b2ea              UXTB     r2,r5                 ;2394
001bba  4b17              LDR      r3,|L1.7192|
001bbc  681b              LDR      r3,[r3,#0]            ;2394  ; st
001bbe  7d59              LDRB     r1,[r3,#0x15]         ;2394
001bc0  4b15              LDR      r3,|L1.7192|
001bc2  685b              LDR      r3,[r3,#4]            ;2394  ; st
001bc4  7818              LDRB     r0,[r3,#0]            ;2394
001bc6  4633              MOV      r3,r6                 ;2394
001bc8  f7fffffe          BL       I2C_Write
001bcc  b110              CBZ      r0,|L1.7124|
001bce  f04f30ff          MOV      r0,#0xffffffff        ;2395
001bd2  e7cb              B        |L1.7020|
                  |L1.7124|
001bd4  2000              MOVS     r0,#0                 ;2396
001bd6  e7c9              B        |L1.7020|
;;;2398   
                          ENDP

                  mpu_read_mem PROC
;;;2407    */
;;;2408   int mpu_read_mem(unsigned short mem_addr, unsigned short length,
001bd8  b5f8              PUSH     {r3-r7,lr}
;;;2409           unsigned char *data)
;;;2410   {
001bda  4604              MOV      r4,r0
001bdc  460d              MOV      r5,r1
001bde  4616              MOV      r6,r2
;;;2411       unsigned char tmp[2];
;;;2412   
;;;2413       if (!data)
001be0  b916              CBNZ     r6,|L1.7144|
;;;2414           return -1;
001be2  f04f30ff          MOV      r0,#0xffffffff
                  |L1.7142|
;;;2415       if (!st.chip_cfg.sensors)
;;;2416           return -1;
;;;2417   
;;;2418       tmp[0] = (unsigned char)(mem_addr >> 8);
;;;2419       tmp[1] = (unsigned char)(mem_addr & 0xFF);
;;;2420   
;;;2421       /* Check bank boundaries. */
;;;2422       if (tmp[1] + length > st.hw->bank_size)
;;;2423           return -1;
;;;2424   
;;;2425       if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
;;;2426           return -1;
;;;2427       if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
;;;2428           return -1;
;;;2429       return 0;
;;;2430   }
001be6  bdf8              POP      {r3-r7,pc}
                  |L1.7144|
001be8  480b              LDR      r0,|L1.7192|
001bea  7a80              LDRB     r0,[r0,#0xa]          ;2415
001bec  b910              CBNZ     r0,|L1.7156|
001bee  f04f30ff          MOV      r0,#0xffffffff        ;2416
001bf2  e7f8              B        |L1.7142|
                  |L1.7156|
001bf4  1220              ASRS     r0,r4,#8              ;2418
001bf6  f88d0000          STRB     r0,[sp,#0]            ;2418
001bfa  b2e0              UXTB     r0,r4                 ;2419
001bfc  f88d0001          STRB     r0,[sp,#1]            ;2419
001c00  f89d0001          LDRB     r0,[sp,#1]            ;2422
001c04  4428              ADD      r0,r0,r5              ;2422
001c06  4904              LDR      r1,|L1.7192|
001c08  6849              LDR      r1,[r1,#4]            ;2422  ; st
001c0a  8949              LDRH     r1,[r1,#0xa]          ;2422
001c0c  4288              CMP      r0,r1                 ;2422
001c0e  dd05              BLE      |L1.7196|
001c10  f04f30ff          MOV      r0,#0xffffffff        ;2423
001c14  e7e7              B        |L1.7142|
001c16  0000              DCW      0x0000
                  |L1.7192|
                          DCD      ||st||
                  |L1.7196|
001c1c  4ac3              LDR      r2,|L1.7980|
001c1e  6812              LDR      r2,[r2,#0]            ;2425  ; st
001c20  7e11              LDRB     r1,[r2,#0x18]         ;2425
001c22  4ac2              LDR      r2,|L1.7980|
001c24  6852              LDR      r2,[r2,#4]            ;2425  ; st
001c26  7810              LDRB     r0,[r2,#0]            ;2425
001c28  466b              MOV      r3,sp                 ;2425
001c2a  2202              MOVS     r2,#2                 ;2425
001c2c  f7fffffe          BL       I2C_Write
001c30  b110              CBZ      r0,|L1.7224|
001c32  f04f30ff          MOV      r0,#0xffffffff        ;2426
001c36  e7d6              B        |L1.7142|
                  |L1.7224|
001c38  b2ea              UXTB     r2,r5                 ;2427
001c3a  4bbc              LDR      r3,|L1.7980|
001c3c  681b              LDR      r3,[r3,#0]            ;2427  ; st
001c3e  7d59              LDRB     r1,[r3,#0x15]         ;2427
001c40  4bba              LDR      r3,|L1.7980|
001c42  685b              LDR      r3,[r3,#4]            ;2427  ; st
001c44  7818              LDRB     r0,[r3,#0]            ;2427
001c46  4633              MOV      r3,r6                 ;2427
001c48  f7fffffe          BL       I2C_Read
001c4c  b110              CBZ      r0,|L1.7252|
001c4e  f04f30ff          MOV      r0,#0xffffffff        ;2428
001c52  e7c8              B        |L1.7142|
                  |L1.7252|
001c54  2000              MOVS     r0,#0                 ;2429
001c56  e7c6              B        |L1.7142|
;;;2431   
                          ENDP

                  mpu_load_firmware PROC
;;;2439    */
;;;2440   int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
001c58  e92d43f0          PUSH     {r4-r9,lr}
;;;2441       unsigned short start_addr, unsigned short sample_rate)
;;;2442   {
001c5c  b085              SUB      sp,sp,#0x14
001c5e  4605              MOV      r5,r0
001c60  460e              MOV      r6,r1
001c62  4690              MOV      r8,r2
001c64  4699              MOV      r9,r3
;;;2443       unsigned short ii;
;;;2444       unsigned short this_write;
;;;2445       /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
;;;2446   #define LOAD_CHUNK  (16)
;;;2447       unsigned char cur[LOAD_CHUNK], tmp[2];
;;;2448   
;;;2449       if (st.chip_cfg.dmp_loaded)
001c66  48b1              LDR      r0,|L1.7980|
001c68  f8900025          LDRB     r0,[r0,#0x25]
001c6c  b120              CBZ      r0,|L1.7288|
;;;2450           /* DMP should only be loaded once. */
;;;2451           return -1;
001c6e  f04f30ff          MOV      r0,#0xffffffff
                  |L1.7282|
;;;2452   
;;;2453       if (!firmware)
;;;2454           return -1;
;;;2455       for (ii = 0; ii < length; ii += this_write) {
;;;2456           this_write = min(LOAD_CHUNK, length - ii);
;;;2457           if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
;;;2458               return -1;
;;;2459           if (mpu_read_mem(ii, this_write, cur))
;;;2460               return -1;
;;;2461           if (memcmp(firmware+ii, cur, this_write))
;;;2462               return -2;
;;;2463       }
;;;2464   
;;;2465       /* Set program start address. */
;;;2466       tmp[0] = start_addr >> 8;
;;;2467       tmp[1] = start_addr & 0xFF;
;;;2468       if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
;;;2469           return -1;
;;;2470   
;;;2471       st.chip_cfg.dmp_loaded = 1;
;;;2472       st.chip_cfg.dmp_sample_rate = sample_rate;
;;;2473       return 0;
;;;2474   }
001c72  b005              ADD      sp,sp,#0x14
001c74  e8bd83f0          POP      {r4-r9,pc}
                  |L1.7288|
001c78  b916              CBNZ     r6,|L1.7296|
001c7a  f04f30ff          MOV      r0,#0xffffffff        ;2454
001c7e  e7f8              B        |L1.7282|
                  |L1.7296|
001c80  2400              MOVS     r4,#0                 ;2455
001c82  e023              B        |L1.7372|
                  |L1.7300|
001c84  1b28              SUBS     r0,r5,r4              ;2456
001c86  2810              CMP      r0,#0x10              ;2456
001c88  dd01              BLE      |L1.7310|
001c8a  2010              MOVS     r0,#0x10              ;2456
001c8c  e000              B        |L1.7312|
                  |L1.7310|
001c8e  1b28              SUBS     r0,r5,r4              ;2456
                  |L1.7312|
001c90  b287              UXTH     r7,r0                 ;2456
001c92  1932              ADDS     r2,r6,r4              ;2457
001c94  4639              MOV      r1,r7                 ;2457
001c96  4620              MOV      r0,r4                 ;2457
001c98  f7fffffe          BL       mpu_write_mem
001c9c  b110              CBZ      r0,|L1.7332|
001c9e  f04f30ff          MOV      r0,#0xffffffff        ;2458
001ca2  e7e6              B        |L1.7282|
                  |L1.7332|
001ca4  aa01              ADD      r2,sp,#4              ;2459
001ca6  4639              MOV      r1,r7                 ;2459
001ca8  4620              MOV      r0,r4                 ;2459
001caa  f7fffffe          BL       mpu_read_mem
001cae  b110              CBZ      r0,|L1.7350|
001cb0  f04f30ff          MOV      r0,#0xffffffff        ;2460
001cb4  e7dd              B        |L1.7282|
                  |L1.7350|
001cb6  1930              ADDS     r0,r6,r4              ;2461
001cb8  463a              MOV      r2,r7                 ;2461
001cba  a901              ADD      r1,sp,#4              ;2461
001cbc  f7fffffe          BL       memcmp
001cc0  b110              CBZ      r0,|L1.7368|
001cc2  f06f0001          MVN      r0,#1                 ;2462
001cc6  e7d4              B        |L1.7282|
                  |L1.7368|
001cc8  19e0              ADDS     r0,r4,r7              ;2455
001cca  b284              UXTH     r4,r0                 ;2455
                  |L1.7372|
001ccc  42ac              CMP      r4,r5                 ;2455
001cce  dbd9              BLT      |L1.7300|
001cd0  ea4f2028          ASR      r0,r8,#8              ;2466
001cd4  f88d0000          STRB     r0,[sp,#0]            ;2466
001cd8  f00800ff          AND      r0,r8,#0xff           ;2467
001cdc  f88d0001          STRB     r0,[sp,#1]            ;2467
001ce0  4a92              LDR      r2,|L1.7980|
001ce2  6812              LDR      r2,[r2,#0]            ;2468  ; st
001ce4  7e91              LDRB     r1,[r2,#0x1a]         ;2468
001ce6  4a91              LDR      r2,|L1.7980|
001ce8  6852              LDR      r2,[r2,#4]            ;2468  ; st
001cea  7810              LDRB     r0,[r2,#0]            ;2468
001cec  466b              MOV      r3,sp                 ;2468
001cee  2202              MOVS     r2,#2                 ;2468
001cf0  f7fffffe          BL       I2C_Write
001cf4  b110              CBZ      r0,|L1.7420|
001cf6  f04f30ff          MOV      r0,#0xffffffff        ;2469
001cfa  e7ba              B        |L1.7282|
                  |L1.7420|
001cfc  2101              MOVS     r1,#1                 ;2471
001cfe  488b              LDR      r0,|L1.7980|
001d00  f8801025          STRB     r1,[r0,#0x25]         ;2471
001d04  f8a09026          STRH     r9,[r0,#0x26]         ;2472
001d08  2000              MOVS     r0,#0                 ;2473
001d0a  e7b2              B        |L1.7282|
;;;2475   
                          ENDP

                  mpu_get_dmp_state PROC
;;;2519    */
;;;2520   int mpu_get_dmp_state(unsigned char *enabled)
001d0c  4601              MOV      r1,r0
;;;2521   {
;;;2522       enabled[0] = st.chip_cfg.dmp_on;
001d0e  4887              LDR      r0,|L1.7980|
001d10  f8900024          LDRB     r0,[r0,#0x24]
001d14  7008              STRB     r0,[r1,#0]
;;;2523       return 0;
001d16  2000              MOVS     r0,#0
;;;2524   }
001d18  4770              BX       lr
;;;2525   
                          ENDP

                  mpu_get_compass_reg PROC
;;;2638    */
;;;2639   int mpu_get_compass_reg(short *data, unsigned long *timestamp)
001d1a  4602              MOV      r2,r0
;;;2640   {
;;;2641   #ifdef AK89xx_SECONDARY
;;;2642       unsigned char tmp[9];
;;;2643   
;;;2644       if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
;;;2645           return -1;
;;;2646   
;;;2647   #ifdef AK89xx_BYPASS
;;;2648       if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
;;;2649           return -1;
;;;2650       tmp[8] = AKM_SINGLE_MEASUREMENT;
;;;2651       if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
;;;2652           return -1;
;;;2653   #else
;;;2654       if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
;;;2655           return -1;
;;;2656   #endif
;;;2657   
;;;2658   #if defined AK8975_SECONDARY
;;;2659       /* AK8975 doesn't have the overrun error bit. */
;;;2660       if (!(tmp[0] & AKM_DATA_READY))
;;;2661           return -2;
;;;2662       if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_DATA_ERROR))
;;;2663           return -3;
;;;2664   #elif defined AK8963_SECONDARY
;;;2665       /* AK8963 doesn't have the data read error bit. */
;;;2666       if (!(tmp[0] & AKM_DATA_READY) || (tmp[0] & AKM_DATA_OVERRUN))
;;;2667           return -2;
;;;2668       if (tmp[7] & AKM_OVERFLOW)
;;;2669           return -3;
;;;2670   #endif
;;;2671       data[0] = (tmp[2] << 8) | tmp[1];
;;;2672       data[1] = (tmp[4] << 8) | tmp[3];
;;;2673       data[2] = (tmp[6] << 8) | tmp[5];
;;;2674   
;;;2675       data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
;;;2676       data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
;;;2677       data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
;;;2678   
;;;2679       if (timestamp)
;;;2680           get_ms(timestamp);
;;;2681       return 0;
;;;2682   #else
;;;2683       return -1;
001d1c  f04f30ff          MOV      r0,#0xffffffff
;;;2684   #endif
;;;2685   }
001d20  4770              BX       lr
;;;2686   
                          ENDP

                  mpu_get_compass_fsr PROC
;;;2691    */
;;;2692   int mpu_get_compass_fsr(unsigned short *fsr)
001d22  4601              MOV      r1,r0
;;;2693   {
;;;2694   #ifdef AK89xx_SECONDARY
;;;2695       fsr[0] = st.hw->compass_fsr;
;;;2696       return 0;
;;;2697   #else
;;;2698       return -1;
001d24  f04f30ff          MOV      r0,#0xffffffff
;;;2699   #endif
;;;2700   }
001d28  4770              BX       lr
;;;2701   
                          ENDP

                  mpu_lp_motion_interrupt PROC
;;;2745    */
;;;2746   int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
001d2a  b5f8              PUSH     {r3-r7,lr}
;;;2747       unsigned char lpa_freq)
;;;2748   {
001d2c  4605              MOV      r5,r0
001d2e  460f              MOV      r7,r1
001d30  4614              MOV      r4,r2
;;;2749       unsigned char data[3];
;;;2750   
;;;2751       if (lpa_freq) {
001d32  2c00              CMP      r4,#0
001d34  d070              BEQ      |L1.7704|
;;;2752           unsigned char thresh_hw;
;;;2753   
;;;2754   #if defined MPU6050
;;;2755           /* TODO: Make these const/#defines. */
;;;2756           /* 1LSb = 32mg. */
;;;2757           if (thresh > 8160)
001d36  f5b55fff          CMP      r5,#0x1fe0
001d3a  dd01              BLE      |L1.7488|
;;;2758               thresh_hw = 255;
001d3c  26ff              MOVS     r6,#0xff
001d3e  e005              B        |L1.7500|
                  |L1.7488|
;;;2759           else if (thresh < 32)
001d40  2d20              CMP      r5,#0x20
001d42  da01              BGE      |L1.7496|
;;;2760               thresh_hw = 1;
001d44  2601              MOVS     r6,#1
001d46  e001              B        |L1.7500|
                  |L1.7496|
;;;2761           else
;;;2762               thresh_hw = thresh >> 5;
001d48  f3c51647          UBFX     r6,r5,#5,#8
                  |L1.7500|
;;;2763   #elif defined MPU6500
;;;2764           /* 1LSb = 4mg. */
;;;2765           if (thresh > 1020)
;;;2766               thresh_hw = 255;
;;;2767           else if (thresh < 4)
;;;2768               thresh_hw = 1;
;;;2769           else
;;;2770               thresh_hw = thresh >> 2;
;;;2771   #endif
;;;2772   
;;;2773           if (!time)
001d4c  b907              CBNZ     r7,|L1.7504|
;;;2774               /* Minimum duration must be 1ms. */
;;;2775               time = 1;
001d4e  2701              MOVS     r7,#1
                  |L1.7504|
;;;2776   
;;;2777   #if defined MPU6050
;;;2778           if (lpa_freq > 40)
001d50  2c28              CMP      r4,#0x28
001d52  dd02              BLE      |L1.7514|
;;;2779   #elif defined MPU6500
;;;2780           if (lpa_freq > 640)
;;;2781   #endif
;;;2782               /* At this point, the chip has not been re-configured, so the
;;;2783                * function can safely exit.
;;;2784                */
;;;2785               return -1;
001d54  f04f30ff          MOV      r0,#0xffffffff
                  |L1.7512|
;;;2786   
;;;2787           if (!st.chip_cfg.int_motion_only) {
;;;2788               /* Store current settings for later. */
;;;2789               if (st.chip_cfg.dmp_on) {
;;;2790                   mpu_set_dmp_state(0);
;;;2791                   st.chip_cfg.cache.dmp_on = 1;
;;;2792               } else
;;;2793                   st.chip_cfg.cache.dmp_on = 0;
;;;2794               mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
;;;2795               mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
;;;2796               mpu_get_lpf(&st.chip_cfg.cache.lpf);
;;;2797               mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
;;;2798               st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
;;;2799               mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
;;;2800           }
;;;2801   
;;;2802   #ifdef MPU6050
;;;2803           /* Disable hardware interrupts for now. */
;;;2804           set_int_enable(0);
;;;2805   
;;;2806           /* Enter full-power accel-only mode. */
;;;2807           mpu_lp_accel_mode(0);
;;;2808   
;;;2809           /* Override current LPF (and HPF) settings to obtain a valid accel
;;;2810            * reading.
;;;2811            */
;;;2812           data[0] = INV_FILTER_256HZ_NOLPF2;
;;;2813           if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
;;;2814               return -1;
;;;2815   
;;;2816           /* NOTE: Digital high pass filter should be configured here. Since this
;;;2817            * driver doesn't modify those bits anywhere, they should already be
;;;2818            * cleared by default.
;;;2819            */
;;;2820   
;;;2821           /* Configure the device to send motion interrupts. */
;;;2822           /* Enable motion interrupt. */
;;;2823           data[0] = BIT_MOT_INT_EN;
;;;2824           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
;;;2825               goto lp_int_restore;
;;;2826   
;;;2827           /* Set motion interrupt parameters. */
;;;2828           data[0] = thresh_hw;
;;;2829           data[1] = time;
;;;2830           if (i2c_write(st.hw->addr, st.reg->motion_thr, 2, data))
;;;2831               goto lp_int_restore;
;;;2832   
;;;2833           /* Force hardware to "lock" current accel sample. */
;;;2834           delay_ms(5);
;;;2835           data[0] = (st.chip_cfg.accel_fsr << 3) | BITS_HPF;
;;;2836           if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
;;;2837               goto lp_int_restore;
;;;2838   
;;;2839           /* Set up LP accel mode. */
;;;2840           data[0] = BIT_LPA_CYCLE;
;;;2841           if (lpa_freq == 1)
;;;2842               data[1] = INV_LPA_1_25HZ;
;;;2843           else if (lpa_freq <= 5)
;;;2844               data[1] = INV_LPA_5HZ;
;;;2845           else if (lpa_freq <= 20)
;;;2846               data[1] = INV_LPA_20HZ;
;;;2847           else
;;;2848               data[1] = INV_LPA_40HZ;
;;;2849           data[1] = (data[1] << 6) | BIT_STBY_XYZG;
;;;2850           if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
;;;2851               goto lp_int_restore;
;;;2852   
;;;2853           st.chip_cfg.int_motion_only = 1;
;;;2854           return 0;
;;;2855   #elif defined MPU6500
;;;2856           /* Disable hardware interrupts. */
;;;2857           set_int_enable(0);
;;;2858   
;;;2859           /* Enter full-power accel-only mode, no FIFO/DMP. */
;;;2860           data[0] = 0;
;;;2861           data[1] = 0;
;;;2862           data[2] = BIT_STBY_XYZG;
;;;2863           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, data))
;;;2864               goto lp_int_restore;
;;;2865   
;;;2866           /* Set motion threshold. */
;;;2867           data[0] = thresh_hw;
;;;2868           if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, data))
;;;2869               goto lp_int_restore;
;;;2870   
;;;2871           /* Set wake frequency. */
;;;2872           if (lpa_freq == 1)
;;;2873               data[0] = INV_LPA_1_25HZ;
;;;2874           else if (lpa_freq == 2)
;;;2875               data[0] = INV_LPA_2_5HZ;
;;;2876           else if (lpa_freq <= 5)
;;;2877               data[0] = INV_LPA_5HZ;
;;;2878           else if (lpa_freq <= 10)
;;;2879               data[0] = INV_LPA_10HZ;
;;;2880           else if (lpa_freq <= 20)
;;;2881               data[0] = INV_LPA_20HZ;
;;;2882           else if (lpa_freq <= 40)
;;;2883               data[0] = INV_LPA_40HZ;
;;;2884           else if (lpa_freq <= 80)
;;;2885               data[0] = INV_LPA_80HZ;
;;;2886           else if (lpa_freq <= 160)
;;;2887               data[0] = INV_LPA_160HZ;
;;;2888           else if (lpa_freq <= 320)
;;;2889               data[0] = INV_LPA_320HZ;
;;;2890           else
;;;2891               data[0] = INV_LPA_640HZ;
;;;2892           if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, data))
;;;2893               goto lp_int_restore;
;;;2894   
;;;2895           /* Enable motion interrupt (MPU6500 version). */
;;;2896           data[0] = BITS_WOM_EN;
;;;2897           if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
;;;2898               goto lp_int_restore;
;;;2899   
;;;2900           /* Enable cycle mode. */
;;;2901           data[0] = BIT_LPA_CYCLE;
;;;2902           if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
;;;2903               goto lp_int_restore;
;;;2904   
;;;2905           /* Enable interrupt. */
;;;2906           data[0] = BIT_MOT_INT_EN;
;;;2907           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
;;;2908               goto lp_int_restore;
;;;2909   
;;;2910           st.chip_cfg.int_motion_only = 1;
;;;2911           return 0;
;;;2912   #endif
;;;2913       } else {
;;;2914           /* Don't "restore" the previous state if no state has been saved. */
;;;2915           int ii;
;;;2916           char *cache_ptr = (char*)&st.chip_cfg.cache;
;;;2917           for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
;;;2918               if (cache_ptr[ii] != 0)
;;;2919                   goto lp_int_restore;
;;;2920           }
;;;2921           /* If we reach this point, motion interrupt mode hasn't been used yet. */
;;;2922           return -1;
;;;2923       }
;;;2924   lp_int_restore:
;;;2925       /* Set to invalid values to ensure no I2C writes are skipped. */
;;;2926       st.chip_cfg.gyro_fsr = 0xFF;
;;;2927       st.chip_cfg.accel_fsr = 0xFF;
;;;2928       st.chip_cfg.lpf = 0xFF;
;;;2929       st.chip_cfg.sample_rate = 0xFFFF;
;;;2930       st.chip_cfg.sensors = 0xFF;
;;;2931       st.chip_cfg.fifo_enable = 0xFF;
;;;2932       st.chip_cfg.clk_src = INV_CLK_PLL;
;;;2933       mpu_set_sensors(st.chip_cfg.cache.sensors_on);
;;;2934       mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
;;;2935       mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
;;;2936       mpu_set_lpf(st.chip_cfg.cache.lpf);
;;;2937       mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
;;;2938       mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
;;;2939   
;;;2940       if (st.chip_cfg.cache.dmp_on)
;;;2941           mpu_set_dmp_state(1);
;;;2942   
;;;2943   #ifdef MPU6500
;;;2944       /* Disable motion interrupt (MPU6500 version). */
;;;2945       data[0] = 0;
;;;2946       if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
;;;2947           goto lp_int_restore;
;;;2948   #endif
;;;2949   
;;;2950       st.chip_cfg.int_motion_only = 0;
;;;2951       return 0;
;;;2952   }
001d58  bdf8              POP      {r3-r7,pc}
                  |L1.7514|
001d5a  4874              LDR      r0,|L1.7980|
001d5c  7d40              LDRB     r0,[r0,#0x15]         ;2787
001d5e  bb28              CBNZ     r0,|L1.7596|
001d60  4872              LDR      r0,|L1.7980|
001d62  f8900024          LDRB     r0,[r0,#0x24]         ;2789
001d66  b138              CBZ      r0,|L1.7544|
001d68  2000              MOVS     r0,#0                 ;2790
001d6a  f7fffffe          BL       mpu_set_dmp_state
001d6e  2101              MOVS     r1,#1                 ;2791
001d70  486e              LDR      r0,|L1.7980|
001d72  f8801020          STRB     r1,[r0,#0x20]         ;2791
001d76  e003              B        |L1.7552|
                  |L1.7544|
001d78  2100              MOVS     r1,#0                 ;2793
001d7a  486c              LDR      r0,|L1.7980|
001d7c  f8801020          STRB     r1,[r0,#0x20]         ;2793
                  |L1.7552|
001d80  486a              LDR      r0,|L1.7980|
001d82  3016              ADDS     r0,r0,#0x16           ;2794
001d84  f7fffffe          BL       mpu_get_gyro_fsr
001d88  4868              LDR      r0,|L1.7980|
001d8a  3018              ADDS     r0,r0,#0x18           ;2795
001d8c  f7fffffe          BL       mpu_get_accel_fsr
001d90  4866              LDR      r0,|L1.7980|
001d92  301a              ADDS     r0,r0,#0x1a           ;2796
001d94  f7fffffe          BL       mpu_get_lpf
001d98  4864              LDR      r0,|L1.7980|
001d9a  301c              ADDS     r0,r0,#0x1c           ;2797
001d9c  f7fffffe          BL       mpu_get_sample_rate
001da0  4862              LDR      r0,|L1.7980|
001da2  7a81              LDRB     r1,[r0,#0xa]          ;2798
001da4  7781              STRB     r1,[r0,#0x1e]         ;2798
001da6  301f              ADDS     r0,r0,#0x1f           ;2799
001da8  f7fffffe          BL       mpu_get_fifo_config
                  |L1.7596|
001dac  2000              MOVS     r0,#0                 ;2804
001dae  f7fffffe          BL       set_int_enable
001db2  2000              MOVS     r0,#0                 ;2807
001db4  f7fffffe          BL       mpu_lp_accel_mode
001db8  2000              MOVS     r0,#0                 ;2812
001dba  f88d0000          STRB     r0,[sp,#0]            ;2812
001dbe  4a5b              LDR      r2,|L1.7980|
001dc0  6812              LDR      r2,[r2,#0]            ;2813  ; st
001dc2  7891              LDRB     r1,[r2,#2]            ;2813
001dc4  4a59              LDR      r2,|L1.7980|
001dc6  6852              LDR      r2,[r2,#4]            ;2813  ; st
001dc8  7810              LDRB     r0,[r2,#0]            ;2813
001dca  466b              MOV      r3,sp                 ;2813
001dcc  2201              MOVS     r2,#1                 ;2813
001dce  f7fffffe          BL       I2C_Write
001dd2  b110              CBZ      r0,|L1.7642|
001dd4  f04f30ff          MOV      r0,#0xffffffff        ;2814
001dd8  e7be              B        |L1.7512|
                  |L1.7642|
001dda  2040              MOVS     r0,#0x40              ;2823
001ddc  f88d0000          STRB     r0,[sp,#0]            ;2823
001de0  4a52              LDR      r2,|L1.7980|
001de2  6812              LDR      r2,[r2,#0]            ;2824  ; st
001de4  7bd1              LDRB     r1,[r2,#0xf]          ;2824
001de6  4a51              LDR      r2,|L1.7980|
001de8  6852              LDR      r2,[r2,#4]            ;2824  ; st
001dea  7810              LDRB     r0,[r2,#0]            ;2824
001dec  466b              MOV      r3,sp                 ;2824
001dee  2201              MOVS     r2,#1                 ;2824
001df0  f7fffffe          BL       I2C_Write
001df4  b100              CBZ      r0,|L1.7672|
001df6  e065              B        |L1.7876|
                  |L1.7672|
001df8  f88d6000          STRB     r6,[sp,#0]            ;2828
001dfc  f88d7001          STRB     r7,[sp,#1]            ;2829
001e00  4a4a              LDR      r2,|L1.7980|
001e02  6812              LDR      r2,[r2,#0]            ;2830  ; st
001e04  7a11              LDRB     r1,[r2,#8]            ;2830
001e06  4a49              LDR      r2,|L1.7980|
001e08  6852              LDR      r2,[r2,#4]            ;2830  ; st
001e0a  7810              LDRB     r0,[r2,#0]            ;2830
001e0c  466b              MOV      r3,sp                 ;2830
001e0e  2202              MOVS     r2,#2                 ;2830
001e10  f7fffffe          BL       I2C_Write
001e14  b108              CBZ      r0,|L1.7706|
001e16  e055              B        |L1.7876|
                  |L1.7704|
001e18  e047              B        |L1.7850|
                  |L1.7706|
001e1a  2005              MOVS     r0,#5                 ;2834
001e1c  f7fffffe          BL       delay_ms
001e20  4842              LDR      r0,|L1.7980|
001e22  7a40              LDRB     r0,[r0,#9]            ;2835
001e24  2107              MOVS     r1,#7                 ;2835
001e26  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2835
001e2a  b2c0              UXTB     r0,r0                 ;2835
001e2c  f88d0000          STRB     r0,[sp,#0]            ;2835
001e30  4a3e              LDR      r2,|L1.7980|
001e32  6812              LDR      r2,[r2,#0]            ;2836  ; st
001e34  79d1              LDRB     r1,[r2,#7]            ;2836
001e36  4a3d              LDR      r2,|L1.7980|
001e38  6852              LDR      r2,[r2,#4]            ;2836  ; st
001e3a  7810              LDRB     r0,[r2,#0]            ;2836
001e3c  466b              MOV      r3,sp                 ;2836
001e3e  2201              MOVS     r2,#1                 ;2836
001e40  f7fffffe          BL       I2C_Write
001e44  b100              CBZ      r0,|L1.7752|
001e46  e03d              B        |L1.7876|
                  |L1.7752|
001e48  2020              MOVS     r0,#0x20              ;2840
001e4a  f88d0000          STRB     r0,[sp,#0]            ;2840
001e4e  2c01              CMP      r4,#1                 ;2841
001e50  d103              BNE      |L1.7770|
001e52  2000              MOVS     r0,#0                 ;2842
001e54  f88d0001          STRB     r0,[sp,#1]            ;2842
001e58  e00e              B        |L1.7800|
                  |L1.7770|
001e5a  2c05              CMP      r4,#5                 ;2843
001e5c  dc03              BGT      |L1.7782|
001e5e  2001              MOVS     r0,#1                 ;2844
001e60  f88d0001          STRB     r0,[sp,#1]            ;2844
001e64  e008              B        |L1.7800|
                  |L1.7782|
001e66  2c14              CMP      r4,#0x14              ;2845
001e68  dc03              BGT      |L1.7794|
001e6a  2002              MOVS     r0,#2                 ;2846
001e6c  f88d0001          STRB     r0,[sp,#1]            ;2846
001e70  e002              B        |L1.7800|
                  |L1.7794|
001e72  2003              MOVS     r0,#3                 ;2848
001e74  f88d0001          STRB     r0,[sp,#1]            ;2848
                  |L1.7800|
001e78  f89d0001          LDRB     r0,[sp,#1]            ;2849
001e7c  2107              MOVS     r1,#7                 ;2849
001e7e  eb011080          ADD      r0,r1,r0,LSL #6       ;2849
001e82  b2c0              UXTB     r0,r0                 ;2849
001e84  f88d0001          STRB     r0,[sp,#1]            ;2849
001e88  4a28              LDR      r2,|L1.7980|
001e8a  6812              LDR      r2,[r2,#0]            ;2850  ; st
001e8c  7c91              LDRB     r1,[r2,#0x12]         ;2850
001e8e  4a27              LDR      r2,|L1.7980|
001e90  6852              LDR      r2,[r2,#4]            ;2850  ; st
001e92  7810              LDRB     r0,[r2,#0]            ;2850
001e94  466b              MOV      r3,sp                 ;2850
001e96  2202              MOVS     r2,#2                 ;2850
001e98  f7fffffe          BL       I2C_Write
001e9c  b100              CBZ      r0,|L1.7840|
001e9e  e011              B        |L1.7876|
                  |L1.7840|
001ea0  2101              MOVS     r1,#1                 ;2853
001ea2  4822              LDR      r0,|L1.7980|
001ea4  7541              STRB     r1,[r0,#0x15]         ;2853
001ea6  2000              MOVS     r0,#0                 ;2854
001ea8  e756              B        |L1.7512|
                  |L1.7850|
001eaa  4a20              LDR      r2,|L1.7980|
001eac  3216              ADDS     r2,r2,#0x16           ;2916
001eae  2100              MOVS     r1,#0                 ;2917
001eb0  e003              B        |L1.7866|
                  |L1.7858|
001eb2  5c50              LDRB     r0,[r2,r1]            ;2918
001eb4  b100              CBZ      r0,|L1.7864|
001eb6  e005              B        |L1.7876|
                  |L1.7864|
001eb8  1c49              ADDS     r1,r1,#1              ;2917
                  |L1.7866|
001eba  290c              CMP      r1,#0xc               ;2917
001ebc  d3f9              BCC      |L1.7858|
001ebe  f04f30ff          MOV      r0,#0xffffffff        ;2922
001ec2  e749              B        |L1.7512|
                  |L1.7876|
001ec4  20ff              MOVS     r0,#0xff              ;2926
001ec6  4919              LDR      r1,|L1.7980|
001ec8  7208              STRB     r0,[r1,#8]            ;2926
001eca  21ff              MOVS     r1,#0xff              ;2927
001ecc  4817              LDR      r0,|L1.7980|
001ece  7241              STRB     r1,[r0,#9]            ;2927
001ed0  72c1              STRB     r1,[r0,#0xb]          ;2928
001ed2  f64f71ff          MOV      r1,#0xffff            ;2929
001ed6  81c1              STRH     r1,[r0,#0xe]          ;2929
001ed8  21ff              MOVS     r1,#0xff              ;2930
001eda  7281              STRB     r1,[r0,#0xa]          ;2930
001edc  7401              STRB     r1,[r0,#0x10]         ;2931
001ede  2101              MOVS     r1,#1                 ;2932
001ee0  7301              STRB     r1,[r0,#0xc]          ;2932
001ee2  4601              MOV      r1,r0                 ;2933
001ee4  7f88              LDRB     r0,[r1,#0x1e]         ;2933
001ee6  f7fffffe          BL       mpu_set_sensors
001eea  4910              LDR      r1,|L1.7980|
001eec  8ac8              LDRH     r0,[r1,#0x16]         ;2934
001eee  f7fffffe          BL       mpu_set_gyro_fsr
001ef2  490e              LDR      r1,|L1.7980|
001ef4  7e08              LDRB     r0,[r1,#0x18]         ;2935
001ef6  f7fffffe          BL       mpu_set_accel_fsr
001efa  490c              LDR      r1,|L1.7980|
001efc  8b48              LDRH     r0,[r1,#0x1a]         ;2936
001efe  f7fffffe          BL       mpu_set_lpf
001f02  490a              LDR      r1,|L1.7980|
001f04  8b88              LDRH     r0,[r1,#0x1c]         ;2937
001f06  f7fffffe          BL       mpu_set_sample_rate
001f0a  4908              LDR      r1,|L1.7980|
001f0c  7fc8              LDRB     r0,[r1,#0x1f]         ;2938
001f0e  f7fffffe          BL       mpu_configure_fifo
001f12  4806              LDR      r0,|L1.7980|
001f14  f8900020          LDRB     r0,[r0,#0x20]         ;2940
001f18  b110              CBZ      r0,|L1.7968|
001f1a  2001              MOVS     r0,#1                 ;2941
001f1c  f7fffffe          BL       mpu_set_dmp_state
                  |L1.7968|
001f20  2100              MOVS     r1,#0                 ;2950
001f22  4802              LDR      r0,|L1.7980|
001f24  7541              STRB     r1,[r0,#0x15]         ;2950
001f26  2000              MOVS     r0,#0                 ;2951
001f28  e716              B        |L1.7512|
;;;2953   
                          ENDP

001f2a  0000              DCW      0x0000
                  |L1.7980|
                          DCD      ||st||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  ||hw||
000000  6800              DCB      0x68,0x00
000002  0400              DCW      0x0400
000004  7600              DCB      0x76,0x00
000006  0154              DCW      0x0154
000008  fdf70100          DCW      0xfdf7,0x0100
                  ||reg||
00000c  75191a0c          DCB      0x75,0x19,0x1a,0x0c
000010  6a231b1c          DCB      0x6a,0x23,0x1b,0x1c
000014  1f207274          DCB      0x1f,0x20,0x72,0x74
000018  433b4138          DCB      0x43,0x3b,0x41,0x38
00001c  393a6b6c          DCB      0x39,0x3a,0x6b,0x6c
000020  376f0624          DCB      0x37,0x6f,0x06,0x24
000024  6d6e7000          DCB      0x6d,0x6e,0x70,0x00
                  test
                          DCD      0x00000083
                          DCD      0x00000800
000030  00010018          DCB      0x00,0x01,0x00,0x18
000034  0032              DCW      0x0032
000036  0500              DCB      0x05,0x00
000038  41200000          DCFS     0x41200000 ; 10
00003c  42d20000          DCFS     0x42d20000 ; 105
000040  3e0f5c29          DCFS     0x3e0f5c29 ; 0.14000000059604645
000044  3e99999a          DCFS     0x3e99999a ; 0.30000001192092896
000048  3f733333          DCFS     0x3f733333 ; 0.94999998807907104
00004c  3e0f5c29          DCFS     0x3e0f5c29 ; 0.14000000059604645

                          AREA ||.data||, DATA, ALIGN=2

                  ||st||
                          DCD      ||reg||
                          DCD      ||hw||
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  0000              DCB      0x00,0x00
00000e  0000              DCW      0x0000
000010  00000000          DCB      0x00,0x00,0x00,0x00
000014  00000000          DCB      0x00,0x00,0x00,0x00
                          %        8
000020  00000000          DCB      0x00,0x00,0x00,0x00
000024  0000              DCB      0x00,0x00
000026  0000              DCW      0x0000
                          DCD      test
